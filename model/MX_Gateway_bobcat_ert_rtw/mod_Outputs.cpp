//
//  Copyright (c) 2009 Bobcat Company as an unpublished work.
//  All Rights Reserved.
//
//  The information contained herein is confidential property of Bobcat Company.
//  The use, copying, transfer or disclosure of such information is prohibited except
//  by express written agreement with Bobcat Company.
//
//  Code Generated by Simulink Real-Time Workshop
//
//  Simulink model                       : MX_Gateway


#include "mod_Outputs.h"

// Include model header file for global data
#include "MX_Gateway.h"
#include "MX_Gateway_private.h"

// Named constants for Chart: '<S437>/Fault monitor'
#define MX_Gate_IN_NO_ACTIVE_CHILD_c5m3 ((uint8_T)0U)
#define MX_Gateway_IN_Ok               ((uint8_T)1U)
#define MX_Gateway_IN_debounce_cuwh    ((uint8_T)2U)
#define MX_Gateway_IN_error_knwh       ((uint8_T)3U)

// Named constants for Chart: '<S304>/Buzzer'
#define MX_Gate_IN_NO_ACTIVE_CHILD_eiu5 ((uint8_T)0U)
#define MX_Gateway_FIFTEEN_SECONDS     ((uint16_T)1499U)
#define MX_Gateway_IN_Beep             ((uint8_T)1U)
#define MX_Gateway_IN_Below_Grade_Zone ((uint8_T)1U)
#define MX_Gateway_IN_Brief_Off        ((uint8_T)1U)
#define MX_Gateway_IN_Depth_Check      ((uint8_T)2U)
#define MX_Gateway_IN_Grade_Zone       ((uint8_T)2U)
#define MX_Gateway_IN_Multiple_Off     ((uint8_T)2U)
#define MX_Gateway_IN_Multiple_On      ((uint8_T)3U)
#define MX_Gateway_IN_No_Beep          ((uint8_T)3U)
#define MX_Gateway_IN_Off_fwwp         ((uint8_T)1U)
#define MX_Gateway_IN_On_lc3f          ((uint8_T)2U)
#define MX_Gateway_IN_On_lc3ft         ((uint8_T)4U)
#define MX_Gateway_IN_One_Beep_Long    ((uint8_T)5U)
#define MX_Gateway_IN_One_Beep_Medium  ((uint8_T)6U)
#define MX_Gateway_IN_Single_Off       ((uint8_T)7U)
#define MX_Gateway_IN_Single_On        ((uint8_T)8U)
#define MX_Gateway_IN_Warning_Zone     ((uint8_T)3U)
#define MX_Gateway_ONE_SECOND_ezbk     ((uint16_T)99U)

// Named constants for Chart: '<S386>/Diverter'
#define MX_Gate_IN_NO_ACTIVE_CHILD_fi0h ((uint8_T)0U)
#define MX_Gatew_IN_NON_FUNCTIONAL_menq ((uint8_T)2U)
#define MX_Gateway_IN_ACTIVE_azwi      ((uint8_T)1U)
#define MX_Gateway_IN_Active_hlsv      ((uint8_T)1U)
#define MX_Gateway_IN_DebounceActive   ((uint8_T)2U)
#define MX_Gateway_IN_DebounceInactive ((uint8_T)3U)
#define MX_Gateway_IN_EMEA_CONTROLS    ((uint8_T)1U)
#define MX_Gateway_IN_INACTIVE_cstq    ((uint8_T)2U)
#define MX_Gateway_IN_InactiveCheck    ((uint8_T)5U)
#define MX_Gateway_IN_Inactive_lhek    ((uint8_T)4U)
#define MX_Gateway_IN_SECOND_AUX_NA    ((uint8_T)3U)

// Named constants for Chart: '<S406>/Dump_Valve'
#define MX_Gate_IN_NO_ACTIVE_CHILD_lqez ((uint8_T)0U)
#define MX_Gateway_IN_Off_fwuc         ((uint8_T)1U)
#define MX_Gateway_IN_On_m33g          ((uint8_T)2U)

// Named constants for Chart: '<S427>/RelaySolenoid'
#define MX_Gate_IN_NO_ACTIVE_CHILD_ei1u ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE_nevi      ((uint8_T)1U)
#define MX_Gateway_IN_INACTIVE_OFF     ((uint8_T)3U)
#define MX_Gateway_IN_INACTIVE_atau    ((uint8_T)2U)

// Named constants for Chart: '<S428>/RelaySolenoid'
#define MX_Ga_IN_STARTUP_ERROR_ON_CHECK ((uint8_T)3U)
#define MX_Gate_IN_NO_ACTIVE_CHILD_aog3 ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE_gz5o      ((uint8_T)1U)
#define MX_Gateway_IN_INACTIVE_phj4    ((uint8_T)2U)

// Named constants for Chart: '<S308>/Solenoid'
#define MX_Gate_IN_NO_ACTIVE_CHILD_fnr0 ((uint8_T)0U)
#define MX_Gatew_IN_NON_FUNCTIONAL_hp4p ((uint8_T)3U)
#define MX_Gateway_IN_ACTIVE_e31e      ((uint8_T)1U)
#define MX_Gateway_IN_CHECK_ERROR_ON   ((uint8_T)2U)
#define MX_Gateway_IN_ECU_HOLD         ((uint8_T)1U)
#define MX_Gateway_IN_ERROR_oymp       ((uint8_T)1U)
#define MX_Gateway_IN_ERROR_oymps      ((uint8_T)2U)
#define MX_Gateway_IN_FUEL_HOLD        ((uint8_T)2U)
#define MX_Gateway_IN_INACTIVE_nope    ((uint8_T)2U)
#define MX_Gateway_IN_NORMAL_chyf      ((uint8_T)2U)

// Named constants for Chart: '<S309>/Timer'
#define MX_Gate_IN_NO_ACTIVE_CHILD_mh0r ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE_g3bz      ((uint8_T)1U)
#define MX_Gateway_IN_INACTIVE_WAIT    ((uint8_T)3U)
#define MX_Gateway_IN_INACTIVE_c0o4    ((uint8_T)2U)

// Named constants for Chart: '<S310>/GlowPlug'
#define MX_Gate_IN_NO_ACTIVE_CHILD_mnel ((uint8_T)0U)
#define MX_Gatew_IN_NON_FUNCTIONAL_pvlo ((uint8_T)2U)
#define MX_Gateway_IN_AFTERGLOW        ((uint8_T)1U)
#define MX_Gateway_IN_CRANKING         ((uint8_T)1U)
#define MX_Gateway_IN_Countdown        ((uint8_T)1U)
#define MX_Gateway_IN_ECU_ljaf         ((uint8_T)1U)
#define MX_Gateway_IN_GLOW_DURING_CRANK ((uint8_T)2U)
#define MX_Gateway_IN_INACTIVE_lvoc    ((uint8_T)3U)
#define MX_Gateway_IN_NORMAL_jia4      ((uint8_T)3U)
#define MX_Gateway_IN_PREGLOW          ((uint8_T)1U)
#define MX_Gateway_IN_PREGLOW_WAIT     ((uint8_T)2U)
#define MX_Gateway_IN_PREHEAT          ((uint8_T)4U)
#define MX_Gateway_IN_RESET_CRANK      ((uint8_T)2U)
#define MX_Gateway_IN_Stop             ((uint8_T)2U)
#define MX_Gateway_IN_WAIT_STARTUP     ((uint8_T)5U)
#define MX_Gateway_IN_Wait             ((uint8_T)3U)

// Named constants for Chart: '<S454>/Hyd_Bypass'
#define MX_Gate_IN_NO_ACTIVE_CHILD_k5om ((uint8_T)0U)
#define MX_Gateway_IN_Cranking         ((uint8_T)1U)
#define MX_Gateway_IN_Delay_dyin       ((uint8_T)2U)
#define MX_Gateway_IN_Not_Cranking     ((uint8_T)3U)
#define MX_Gateway_IN_Off_chbn         ((uint8_T)1U)
#define MX_Gateway_IN_On_cbgn          ((uint8_T)2U)

// Named constants for Chart: '<S473>/Hyd_Enable'
#define MX_Gate_IN_NO_ACTIVE_CHILD_pdyo ((uint8_T)0U)
#define MX_Gateway_IN_Cranking_c5p0    ((uint8_T)1U)
#define MX_Gateway_IN_Delay_gzfi       ((uint8_T)2U)
#define MX_Gateway_IN_Not_Cranking_llua ((uint8_T)3U)
#define MX_Gateway_IN_Off_cbc5         ((uint8_T)1U)
#define MX_Gateway_IN_On_f50i          ((uint8_T)2U)

// Named constants for Chart: '<S313>/Hydraulic_Xchange'
#define MX_Gate_IN_NO_ACTIVE_CHILD_daqq ((uint8_T)0U)
#define MX_Gateway_IN_Active_lofk      ((uint8_T)1U)
#define MX_Gateway_IN_Functional       ((uint8_T)1U)
#define MX_Gateway_IN_Inactive_j3td    ((uint8_T)2U)
#define MX_Gateway_IN_Nonfunctional    ((uint8_T)2U)

// Named constants for Chart: '<S314>/Lights'
#define MX_Gat_IN_LIGHTS_ACTIVE_RISING1 ((uint8_T)2U)
#define MX_Gat_IN_LIGHTS_ACTIVE_RISING2 ((uint8_T)3U)
#define MX_Gateway_IN_LIGHTS_ACTIVE    ((uint8_T)1U)
#define MX_Gateway_IN_LIGHTS_INACTIVE  ((uint8_T)4U)

// Named constants for Chart: '<S507>/Commands'
#define MX_Gate_IN_NO_ACTIVE_CHILD_ik2b ((uint8_T)0U)
#define MX_Gateway_IN_Active_f4bs      ((uint8_T)1U)
#define MX_Gateway_IN_BaseActive       ((uint8_T)1U)
#define MX_Gateway_IN_Inactive_cx3o    ((uint8_T)2U)
#define MX_Gateway_IN_Neutral_nhy3     ((uint8_T)2U)
#define MX_Gateway_IN_RodActive        ((uint8_T)3U)

// Named constants for Chart: '<S316>/PBValve'
#define MX_Gateway_IN_ACTIVE_ftsh      ((uint8_T)1U)
#define MX_Gateway_IN_INACTIVE_h2aq    ((uint8_T)2U)

// Named constants for Chart: '<S317>/Starter'
#define MX_Gate_IN_NO_ACTIVE_CHILD_fajt ((uint8_T)0U)
#define MX_Gatew_IN_NON_FUNCTIONAL_gcn1 ((uint8_T)3U)
#define MX_Gateway_IN_ACTIVE_bwmt      ((uint8_T)1U)
#define MX_Gateway_IN_AUTOMATED        ((uint8_T)1U)
#define MX_Gateway_IN_AUTOMATED_START  ((uint8_T)2U)
#define MX_Gateway_IN_DEBOUNCE_FOR_AUTO ((uint8_T)3U)
#define MX_Gateway_IN_INACTIVE_h31q    ((uint8_T)2U)
#define MX_Gateway_IN_INACTIVE_h31qw   ((uint8_T)4U)
#define MX_Gateway_IN_MANUAL           ((uint8_T)2U)

// Named constants for Chart: '<S319>/Relay'
#define MX_G_IN_DEBOUNCE_ERROR_ON_CHECK ((uint8_T)2U)
#define MX_Gate_IN_NO_ACTIVE_CHILD_liu3 ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE_ftye      ((uint8_T)1U)
#define MX_Gateway_IN_DELAY_OFF        ((uint8_T)3U)
#define MX_Gateway_IN_INACTIVE_bo51    ((uint8_T)4U)

// Named constants for Chart: '<S579>/TwoSpeed_Control'
#define MX_Gate_IN_High_Range_Available ((uint8_T)1U)
#define MX_Gate_IN_NO_ACTIVE_CHILD_ojcz ((uint8_T)0U)
#define MX_Gatewa_IN_Autoshift_Inactive ((uint8_T)2U)
#define MX_Gateway_IN_Active_pkjk      ((uint8_T)1U)
#define MX_Gateway_IN_AutoShift        ((uint8_T)1U)
#define MX_Gateway_IN_Autoshift_Active ((uint8_T)1U)
#define MX_Gateway_IN_Delay_b1g5       ((uint8_T)1U)
#define MX_Gateway_IN_High             ((uint8_T)1U)
#define MX_Gateway_IN_High_pby2        ((uint8_T)2U)
#define MX_Gateway_IN_Inactive_mv0f    ((uint8_T)2U)
#define MX_Gateway_IN_Low              ((uint8_T)2U)
#define MX_Gateway_IN_Low_Delay        ((uint8_T)2U)
#define MX_Gateway_IN_Low_No_Travel    ((uint8_T)3U)
#define MX_Gateway_IN_Low_Range        ((uint8_T)2U)
#define MX_Gateway_IN_Low_Travel       ((uint8_T)3U)
#define MX_Gateway_IN_Low_Travel_aquv  ((uint8_T)4U)
#define MX_Gateway_IN_NoTravel_High    ((uint8_T)1U)
#define MX_Gateway_IN_NonFunctional    ((uint8_T)3U)
#define MX_Gateway_IN_Normal_h4rf      ((uint8_T)4U)
#define MX_Gateway_IN_Normal_h4rfj     ((uint8_T)1U)
#define MX_Gateway_IN_TrackTensioning  ((uint8_T)5U)
#define MX_Gateway_IN_Track_Tensioning ((uint8_T)2U)
#define MX_Gateway_IN_Travel_Autoshift ((uint8_T)2U)
#define MX_IN_AutoShift_TrackTensioning ((uint8_T)2U)

// Forward declaration for local functions
static uint8_T MX_Gateway_out_state(boolean_T rtu_cmd, boolean_T rtu_fbk,
  rtDW_dout_chk_MX_Gateway *localDW, uint16_T rtp_ERR_OFF_DB_CNT, uint16_T
  rtp_ERR_ON_DB_CNT);

// Forward declaration for local functions
static void MX_Gateway_Depth_Check(void);

// Forward declaration for local functions
static void MX_Gateway_FuelTiming(void);

// Forward declaration for local functions
static void MX_Gateway_PreheatTime(uint16_T temp);
static void MX_Gateway_AfterglowTime(uint16_T temp);
static void MX_Gateway_PreheatWaitTime(uint16_T temp);

// Forward declaration for local functions
static void MX_Gateway_Normal(uint8_T *state_TwoSpeedIcon_czcv, uint8_T
  *FixPtRelationalOperator_n1fs);
static void MX_Gateway_Control(uint8_T *state_TwoSpeedIcon_czcv, const boolean_T
  *Compare_geoy, const uint16_T *DataTypeConversion3, uint8_T
  *FixPtRelationalOperator_n1fs);

// System initialize for atomic system: '<S26>/Aux_Hydraulics'
void MX_Gateway_Aux_Hydraulics_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S303>/Aux_Hydraulics'
  // InitializeConditions for UnitDelay: '<S332>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE = ((uint16_T)0U);

  // InitializeConditions for UnitDelay: '<S340>/Delay Input2'
  MX_Gateway_DWork.DelayInput2_DSTATE = 0;

  // InitializeConditions for UnitDelay: '<S333>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE_abci = ((uint16_T)0U);

  // InitializeConditions for UnitDelay: '<S345>/Delay Input2'
  MX_Gateway_DWork.DelayInput2_DSTATE_gc5y = 0;

  // SystemInitialize for Truth Table: '<S324>/Aux_Control_Logic'
  MX_Gateway_DWork.ACDVarFlow = 0U;

  // SystemInitialize for Atomic SubSystem: '<S321>/hc_pair_control'
  MX__output_pair_ClosedLoop_Init(&MX_Gateway_B.hs_cmd_mvqz,
    &MX_Gateway_B.ls_cmd_jnku, &MX_Gateway_B.state_Output_movq,
    &MX_Gateway_B.hc_pair_control, &MX_Gateway_DWork.hc_pair_control);

  // End of SystemInitialize for SubSystem: '<S321>/hc_pair_control'

  // SystemInitialize for Atomic SubSystem: '<S321>/hc_pair_control1'
  MX__output_pair_ClosedLoop_Init(&MX_Gateway_B.hs_cmd_cifl,
    &MX_Gateway_B.ls_cmd_mxkm, &MX_Gateway_B.state_Output_akdd,
    &MX_Gateway_B.hc_pair_control1, &MX_Gateway_DWork.hc_pair_control1);

  // End of SystemInitialize for SubSystem: '<S321>/hc_pair_control1'

  // End of SystemInitialize for SubSystem: '<S303>/Aux_Hydraulics'
}

// Output and update for atomic system: '<S26>/Aux_Hydraulics'
void MX_Gateway_Aux_Hydraulics(void)
{
  // local block i/o variables
  uint16_T rtb_position_Pot;
  uint16_T rtb_Aux_Table1;
  uint16_T rtb_Aux_Table2;
  uint16_T rtb_Aux_Table3;
  uint16_T rtb_DataTypeConversion1_m3xv;
  boolean_T aVarTruthTableCondition_1;
  boolean_T aVarTruthTableCondition_2;
  boolean_T aVarTruthTableCondition_3;
  boolean_T aVarTruthTableCondition_4;
  boolean_T aVarTruthTableCondition_5;
  boolean_T aVarTruthTableCondition_6;
  boolean_T aVarTruthTableCondition_7;
  boolean_T aVarTruthTableCondition_9;
  boolean_T aVarTruthTableCondition_10;
  boolean_T aVarTruthTableCondition_11;
  boolean_T aVarTruthTableCondition_12;
  boolean_T b;
  uint8_T rtb_Saturation;
  uint8_T rtb_state_Pot;
  uint16_T rtb_Switch_aazc;
  int16_T rtb_Saturation_eckz;
  uint16_T rtb_Switch1;
  uint16_T rtb_icmd_Base;
  int32_T rtb_sampletime;
  int32_T rtb_UkYk1;
  int32_T rtb_deltafalllimit;
  boolean_T rtb_LogicalOperator_cwje;
  uint16_T rtb_Switch_allm;
  uint16_T rtb_Switch_dydk;
  uint32_T qY;
  int32_T rtb_deltafalllimit_tmp;

  // Outputs for Enabled SubSystem: '<S303>/Aux_Hydraulics' incorporates:
  //   EnablePort: '<S321>/Enable'

  // Logic: '<S303>/Logical Operator' incorporates:
  //   Constant: '<S303>/Constant1'
  //   Constant: '<S322>/Constant'
  //   Constant: '<S323>/Constant'
  //   RelationalOperator: '<S322>/Compare'
  //   RelationalOperator: '<S323>/Compare'

  if ((CONSTANT_DATA->AUX_FUNCTION != NON_FUNCTIONAL) && (state_System ==
       SYS_NORMAL)) {
    if (!MX_Gateway_DWork.Aux_Hydraulics_MODE) {
      // InitializeConditions for UnitDelay: '<S332>/Unit Delay'
      MX_Gateway_DWork.UnitDelay_DSTATE = ((uint16_T)0U);

      // InitializeConditions for UnitDelay: '<S340>/Delay Input2'
      MX_Gateway_DWork.DelayInput2_DSTATE = 0;

      // InitializeConditions for UnitDelay: '<S333>/Unit Delay'
      MX_Gateway_DWork.UnitDelay_DSTATE_abci = ((uint16_T)0U);

      // InitializeConditions for UnitDelay: '<S345>/Delay Input2'
      MX_Gateway_DWork.DelayInput2_DSTATE_gc5y = 0;

      // SystemReset for Truth Table: '<S324>/Aux_Control_Logic'
      MX_Gateway_DWork.ACDVarFlow = 0U;

      // SystemReset for Atomic SubSystem: '<S321>/hc_pair_control'
      MX_output_pair_ClosedLoop_Reset(&MX_Gateway_B.hs_cmd_mvqz,
        &MX_Gateway_B.ls_cmd_jnku, &MX_Gateway_B.state_Output_movq,
        &MX_Gateway_B.hc_pair_control, &MX_Gateway_DWork.hc_pair_control);

      // End of SystemReset for SubSystem: '<S321>/hc_pair_control'

      // SystemReset for Atomic SubSystem: '<S321>/hc_pair_control1'
      MX_output_pair_ClosedLoop_Reset(&MX_Gateway_B.hs_cmd_cifl,
        &MX_Gateway_B.ls_cmd_mxkm, &MX_Gateway_B.state_Output_akdd,
        &MX_Gateway_B.hc_pair_control1, &MX_Gateway_DWork.hc_pair_control1);

      // End of SystemReset for SubSystem: '<S321>/hc_pair_control1'
      MX_Gateway_DWork.Aux_Hydraulics_MODE = true;
    }

    // Truth Table: '<S321>/Controls_Select'
    // Truth Table Function 'MX_Gtwy_Control/Outputs/Aux_Hydraulics/Aux_Hydraulics/Controls_Select': '<S327>:1' 
    //  EMEA Controls
    // Condition '#1': '<S327>:1:10'
    aVarTruthTableCondition_1 = (CONSTANT_DATA->AUX_FUNCTION ==
      AUX_EMEA_CONTROLS);

    //  Joysticks Reversed (Kawasaki)
    // Condition '#2': '<S327>:1:14'
    aVarTruthTableCondition_2 = (CONSTANT_DATA->EMEA_CONTROLS_REVERSE ==
      NON_FUNCTIONAL);

    //  Aux1 on right
    // Condition '#3': '<S327>:1:18'
    aVarTruthTableCondition_3 = (mode_RightControl == MODE_RIGHT_AUX1);
    if ((!aVarTruthTableCondition_1) && aVarTruthTableCondition_2 &&
        aVarTruthTableCondition_3) {
      // Decision 'D1': '<S327>:1:20'
      //  Legacy Aux Pot
      // Action '1': '<S327>:1:36'
      rtb_position_Pot = position_AuxPot;

      // Action '1': '<S327>:1:37'
      rtb_state_Pot = state_AuxPot;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_2) &&
               aVarTruthTableCondition_3) {
      // Decision 'D2': '<S327>:1:22'
      //  Right Pot
      // Action '2': '<S327>:1:43'
      rtb_position_Pot = position_RightPot;

      // Action '2': '<S327>:1:44'
      rtb_state_Pot = state_RightPot;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               aVarTruthTableCondition_3) {
      // Decision 'D3': '<S327>:1:24'
      //  Right Pot
      // Action '2': '<S327>:1:43'
      rtb_position_Pot = position_RightPot;

      // Action '2': '<S327>:1:44'
      rtb_state_Pot = state_RightPot;
    } else if (aVarTruthTableCondition_1 && aVarTruthTableCondition_2 &&
               aVarTruthTableCondition_3) {
      // Decision 'D4': '<S327>:1:26'
      //  Right Pot
      // Action '2': '<S327>:1:43'
      rtb_position_Pot = position_RightPot;

      // Action '2': '<S327>:1:44'
      rtb_state_Pot = state_RightPot;
    } else {
      // Decision 'D5': '<S327>:1:28'
      //  Default
      //  Neutral
      // Action '3': '<S327>:1:50'
      rtb_position_Pot = 500U;

      // Action '3': '<S327>:1:51'
      rtb_state_Pot = 8U;
    }

    // End of Truth Table: '<S321>/Controls_Select'

    // Logic: '<S330>/Logical Operator' incorporates:
    //   Constant: '<S330>/Constant4'
    //   Constant: '<S334>/Constant'
    //   DataStoreRead: '<S330>/Data Store Read'
    //   RelationalOperator: '<S334>/Compare'

    aVarTruthTableCondition_1 = !(((int32_T)eeMirror.deluxe_G5 != 0) &&
      (CONSTANT_DATA->AUX_FUNCTION == AUX_EMEA_CONTROLS));

    // Saturate: '<S330>/Saturation'
    if (aux_Flow > ((uint8_T)3U)) {
      rtb_Saturation = ((uint8_T)3U);
    } else if (aux_Flow < ((uint8_T)1U)) {
      rtb_Saturation = ((uint8_T)1U);
    } else {
      rtb_Saturation = aux_Flow;
    }

    // End of Saturate: '<S330>/Saturation'

    // MultiPortSwitch: '<S330>/Multiport Switch' incorporates:
    //   Lookup: '<S330>/Aux_Table1'
    //   Lookup: '<S330>/Aux_Table2'

    switch ((int32_T)rtb_Saturation) {
     case 1:
      // Lookup: '<S330>/Aux_Table1'
      //
      //  About '<S330>/Aux_Table1':
      //  Input0  Data Type:  Integer        U16
      //  Output0 Data Type:  Fixed Point    U16  2^-12
      //  Saturation Mode: Saturate
      //  Lookup Method: Linear_Endpoint
      //
      //  XData is inlined and evenly spaced, so the algorithm only needs
      //  the value of the first element, the last element, and the spacing.
      //  For efficiency, XData is excluded from the generated code.
      //  YData parameter uses the same data type and scaling as Output0

      LookUpEven_U16_U16_SAT( &(rtb_Aux_Table1), (&(MXGTW_AUXHYD1[0])),
        rtb_position_Pot, 20U, 160U, 6U);
      rtb_Switch_aazc = rtb_Aux_Table1;
      break;

     case 2:
      // Lookup: '<S330>/Aux_Table2'
      //
      //  About '<S330>/Aux_Table2':
      //  Input0  Data Type:  Integer        U16
      //  Output0 Data Type:  Fixed Point    U16  2^-12
      //  Saturation Mode: Saturate
      //  Lookup Method: Linear_Endpoint
      //
      //  XData is inlined and evenly spaced, so the algorithm only needs
      //  the value of the first element, the last element, and the spacing.
      //  For efficiency, XData is excluded from the generated code.
      //  YData parameter uses the same data type and scaling as Output0

      LookUpEven_U16_U16_SAT( &(rtb_Aux_Table2), (&(MXGTW_AUXHYD2[0])),
        rtb_position_Pot, 20U, 160U, 6U);
      rtb_Switch_aazc = rtb_Aux_Table2;
      break;

     default:
      // Switch: '<S330>/Switch' incorporates:
      //   Constant: '<S336>/Constant4'
      //   Gain: '<S336>/Gain'
      //   Lookup: '<S330>/Aux_Table3'
      //   Product: '<S336>/Product'
      //   Sum: '<S336>/Sum1'

      if (aVarTruthTableCondition_1) {
        // Lookup: '<S330>/Aux_Table3'
        //
        //  About '<S330>/Aux_Table3':
        //  Input0  Data Type:  Integer        U16
        //  Output0 Data Type:  Fixed Point    U16  2^-12
        //  Saturation Mode: Saturate
        //  Lookup Method: Linear_Endpoint
        //
        //  XData is inlined and evenly spaced, so the algorithm only needs
        //  the value of the first element, the last element, and the spacing.
        //  For efficiency, XData is excluded from the generated code.
        //  YData parameter uses the same data type and scaling as Output0

        LookUpEven_U16_U16_SAT( &(rtb_Aux_Table3), (&(MXGTW_AUXHYD3[0])),
          rtb_position_Pot, 20U, 160U, 6U);
        rtb_Switch_aazc = rtb_Aux_Table3;
      } else {
        // Lookup: '<S336>/Aux_Table3'
        //
        //  About '<S336>/Aux_Table3':
        //  Input0  Data Type:  Integer        U16
        //  Output0 Data Type:  Fixed Point    U16  2^-12
        //  Saturation Mode: Saturate
        //  Lookup Method: Linear_Endpoint
        //
        //  XData is inlined and evenly spaced, so the algorithm only needs
        //  the value of the first element, the last element, and the spacing.
        //  For efficiency, XData is excluded from the generated code.
        //  YData parameter uses the same data type and scaling as Output0

        LookUpEven_U16_U16_SAT( &(rtb_DataTypeConversion1_m3xv),
          (&(MXGTW_AUXHYD3[0])), rtb_position_Pot, 20U, 160U, 6U);

        // Sum: '<S336>/Sum' incorporates:
        //   Constant: '<S336>/Constant4'
        //   DataTypeConversion: '<S336>/Data Type Conversion'

        rtb_Saturation_eckz = (int16_T)(int32_T)((int32_T)((int32_T)(int16_T)
          rtb_DataTypeConversion1_m3xv - (int32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT) >> 1);

        // Saturate: '<S336>/Saturation'
        if ((int32_T)rtb_Saturation_eckz > (int32_T)4096) {
          rtb_Saturation_eckz = 4096;
        } else {
          if ((int32_T)rtb_Saturation_eckz < (int32_T)0) {
            rtb_Saturation_eckz = 0;
          }
        }

        // End of Saturate: '<S336>/Saturation'

        // DataTypeConversion: '<S336>/Data Type Conversion1'
        rtb_DataTypeConversion1_m3xv = (uint16_T)(int32_T)((int32_T)(uint16_T)
          rtb_Saturation_eckz << 1);
        rtb_Switch_aazc = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT << 4) + (uint32_T)(uint16_T)
          (uint32_T)((uint32_T)((uint32_T)rtb_DataTypeConversion1_m3xv *
          (uint32_T)(uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint16_T)41943U)
          * (uint32_T)flow_Aux1Percent) >> 6)) >> 12)) >> 4);
      }

      // End of Switch: '<S330>/Switch'
      break;
    }

    // End of MultiPortSwitch: '<S330>/Multiport Switch'

    // MultiPortSwitch: '<S330>/Multiport Switch1' incorporates:
    //   Constant: '<S330>/Constant'
    //   Constant: '<S330>/Constant1'

    switch ((int32_T)rtb_Saturation) {
     case 1:
      rtb_Switch1 = CONSTANT_DATA->AUX_FULL_ON_AUX1;
      break;

     case 2:
      rtb_Switch1 = CONSTANT_DATA->AUX_FULL_ON_AUX2;
      break;

     default:
      // Switch: '<S330>/Switch1' incorporates:
      //   Constant: '<S330>/Constant2'
      //   Constant: '<S335>/Constant4'
      //   DataTypeConversion: '<S335>/Data Type Conversion1'
      //   Gain: '<S335>/Gain'
      //   Product: '<S335>/Product'
      //   Sum: '<S335>/Sum1'

      if (aVarTruthTableCondition_1) {
        rtb_Switch1 = CONSTANT_DATA->AUX_FULL_ON_AUX3;
      } else {
        // Sum: '<S335>/Sum' incorporates:
        //   Constant: '<S330>/Constant2'
        //   Constant: '<S335>/Constant4'
        //   DataTypeConversion: '<S335>/Data Type Conversion'

        rtb_Saturation_eckz = (int16_T)(int32_T)((int32_T)((int32_T)(int16_T)
          CONSTANT_DATA->AUX_FULL_ON_AUX3 - (int32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT) >> 1);

        // Saturate: '<S335>/Saturation'
        if ((int32_T)rtb_Saturation_eckz > (int32_T)4096) {
          rtb_Saturation_eckz = 4096;
        } else {
          if ((int32_T)rtb_Saturation_eckz < (int32_T)0) {
            rtb_Saturation_eckz = 0;
          }
        }

        // End of Saturate: '<S335>/Saturation'
        rtb_Switch1 = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT << 4) + (uint32_T)(uint16_T)
          (uint32_T)((uint32_T)((uint32_T)(int32_T)(uint16_T)(int32_T)((int32_T)
          (uint16_T)rtb_Saturation_eckz << 1) * (uint32_T)(uint16_T)(uint32_T)
          ((uint32_T)((uint32_T)((uint16_T)41943U) * (uint32_T)flow_Aux1Percent)
           >> 6)) >> 12)) >> 4);
      }

      // End of Switch: '<S330>/Switch1'
      break;
    }

    // End of MultiPortSwitch: '<S330>/Multiport Switch1'

    // S-Function (sfix_bitop): '<S324>/Detent_Front_Mask'
    rtb_Saturation = (uint8_T)(int32_T)((int32_T)state_Detent & (int32_T)
      ((uint8_T)15U));

    // Truth Table: '<S324>/Aux_Control_Logic'
    // Truth Table Function 'MX_Gtwy_Control/Outputs/Aux_Hydraulics/Aux_Hydraulics/Aux_Hyd_Commands_Current_Control/Aux_Control_Logic': '<S331>:1' 
    //  Aux Enabled
    // Condition '#1': '<S331>:1:20'
    aVarTruthTableCondition_1 = (state_AuxEnable == ACTIVE_MODE_ONE);

    //  Aux Pot - Base Active
    // Condition '#2': '<S331>:1:24'
    aVarTruthTableCondition_2 = (rtb_state_Pot == BASE_ACTIVE);

    //  Aux Pot - Rod Active
    // Condition '#3': '<S331>:1:28'
    aVarTruthTableCondition_3 = (rtb_state_Pot == ROD_ACTIVE);

    //  Base Detent
    // Condition '#4': '<S331>:1:32'
    aVarTruthTableCondition_4 = (rtb_Saturation == BASE_DETENT);

    //  Rod Detent
    // Condition '#5': '<S331>:1:36'
    aVarTruthTableCondition_5 = (rtb_Saturation == ROD_DETENT);

    //  ACD Functional
    // Condition '#6': '<S331>:1:40'
    aVarTruthTableCondition_6 = (CONSTANT_DATA->RACD_FUNCTION != NON_FUNCTIONAL);

    //  ACD Active
    // Condition '#7': '<S331>:1:44'
    aVarTruthTableCondition_7 = (cmd_AuxEnable_ACD == ACTIVE);

    //  ACD Base Active
    if (((int32_T)can_ACD_AuxCommand == 1) || ((int32_T)can_ACD_AuxCommand == 5))
    {
      // Condition '#8': '<S331>:1:48'
      b = true;
    } else {
      b = false;
    }

    //  ACD Rod Active
    // Condition '#9': '<S331>:1:52'
    aVarTruthTableCondition_9 = ((int32_T)can_ACD_AuxCommand == 4);

    //  ACD was in variable flow
    // Condition '#10': '<S331>:1:56'
    aVarTruthTableCondition_10 = ((int32_T)MX_Gateway_DWork.ACDVarFlow > 0);

    //  Aux Release Rod
    // Condition '#11': '<S331>:1:60'
    aVarTruthTableCondition_11 = (cmd_AuxRelease == ROD_ACTIVE);

    //  Aux Release Base
    // Condition '#12': '<S331>:1:64'
    aVarTruthTableCondition_12 = (cmd_AuxRelease == BASE_ACTIVE);

    //  Engine Cranking
    // Condition '#13': '<S331>:1:68'
    if (state_Engine == ENGINE_CRANKING) {
      // Decision 'D1': '<S331>:1:70'
      //  Aux Off
      // Action '1': '<S331>:1:100'
      rtb_icmd_Base = 0U;

      // Action '1': '<S331>:1:101'
      rtb_Switch1 = 0U;

      // Action '1': '<S331>:1:102'
      MX_Gateway_B.state_AuxFlow = INACTIVE;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_7) &&
               aVarTruthTableCondition_11 && (!aVarTruthTableCondition_12)) {
      // Decision 'D2': '<S331>:1:72'
      //  Aux Rod Full On
      // Action '2': '<S331>:1:108'
      rtb_icmd_Base = 0U;

      // Action '2': '<S331>:1:109'
      // Action '2': '<S331>:1:110'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_7) && (
                !aVarTruthTableCondition_11) && aVarTruthTableCondition_12) {
      // Decision 'D3': '<S331>:1:74'
      //  Aux Base Full On
      // Action '3': '<S331>:1:116'
      rtb_icmd_Base = rtb_Switch1;

      // Action '3': '<S331>:1:117'
      rtb_Switch1 = 0U;

      // Action '3': '<S331>:1:118'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && (!aVarTruthTableCondition_4) &&
               aVarTruthTableCondition_5 && (!aVarTruthTableCondition_7) &&
               (!aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D4': '<S331>:1:76'
      //  Aux Rod Full On
      // Action '2': '<S331>:1:108'
      rtb_icmd_Base = 0U;

      // Action '2': '<S331>:1:109'
      // Action '2': '<S331>:1:110'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && aVarTruthTableCondition_4 &&
               (!aVarTruthTableCondition_5) && (!aVarTruthTableCondition_7) && (
                !aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D5': '<S331>:1:78'
      //  Aux Base Full On
      // Action '3': '<S331>:1:116'
      rtb_icmd_Base = rtb_Switch1;

      // Action '3': '<S331>:1:117'
      rtb_Switch1 = 0U;

      // Action '3': '<S331>:1:118'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               aVarTruthTableCondition_3 && (!aVarTruthTableCondition_7) &&
               (!aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D6': '<S331>:1:80'
      //  Aux Rod Proportional
      // Action '4': '<S331>:1:124'
      rtb_icmd_Base = 0U;

      // Action '4': '<S331>:1:125'
      rtb_Switch1 = rtb_Switch_aazc;

      // Action '4': '<S331>:1:126'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && aVarTruthTableCondition_2 &&
               (!aVarTruthTableCondition_3) && (!aVarTruthTableCondition_7) && (
                !aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D7': '<S331>:1:82'
      //  Aux Base Proportional
      // Action '5': '<S331>:1:132'
      rtb_icmd_Base = rtb_Switch_aazc;

      // Action '5': '<S331>:1:133'
      rtb_Switch1 = 0U;

      // Action '5': '<S331>:1:134'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_6 && aVarTruthTableCondition_7 && (!b) &&
               (!aVarTruthTableCondition_9) && (!aVarTruthTableCondition_11) &&
               (!aVarTruthTableCondition_12)) {
      // Decision 'D8': '<S331>:1:84'
      //  Reset ACD Variable Flow Flag
      // Action '6': '<S331>:1:140'
      rtb_icmd_Base = 0U;

      // Action '6': '<S331>:1:141'
      rtb_Switch1 = 0U;

      // Action '6': '<S331>:1:142'
      MX_Gateway_DWork.ACDVarFlow = 0U;

      // Action '6': '<S331>:1:143'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && aVarTruthTableCondition_6 &&
               aVarTruthTableCondition_7 && aVarTruthTableCondition_9 &&
               (!aVarTruthTableCondition_10) && (!aVarTruthTableCondition_11) &&
               (!aVarTruthTableCondition_12)) {
      // Decision 'D9': '<S331>:1:86'
      //  Aux Rod Full On
      // Action '2': '<S331>:1:108'
      rtb_icmd_Base = 0U;

      // Action '2': '<S331>:1:109'
      // Action '2': '<S331>:1:110'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && aVarTruthTableCondition_6 &&
               aVarTruthTableCondition_7 && b && (!aVarTruthTableCondition_10) &&
               (!aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D10': '<S331>:1:88'
      //  Aux Base Full On
      // Action '3': '<S331>:1:116'
      rtb_icmd_Base = rtb_Switch1;

      // Action '3': '<S331>:1:117'
      rtb_Switch1 = 0U;

      // Action '3': '<S331>:1:118'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_10 && (!aVarTruthTableCondition_11) &&
               (!aVarTruthTableCondition_12)) {
      // Decision 'D11': '<S331>:1:90'
      //  Inhibit ACD Command
      // Action '7': '<S331>:1:149'
      rtb_icmd_Base = 0U;

      // Action '7': '<S331>:1:150'
      rtb_Switch1 = 0U;

      // Action '7': '<S331>:1:151'
      qY = (uint32_T)((uint32_T)MX_Gateway_DWork.ACDVarFlow - 1U);
      if (qY > (uint32_T)MX_Gateway_DWork.ACDVarFlow) {
        qY = 0U;
      }

      MX_Gateway_DWork.ACDVarFlow = (uint8_T)qY;

      // Action '7': '<S331>:1:152'
      MX_Gateway_B.state_AuxFlow = ACTIVE;
    } else {
      // Decision 'D12': '<S331>:1:92'
      //  Default
      //  Aux Off
      // Action '1': '<S331>:1:100'
      rtb_icmd_Base = 0U;

      // Action '1': '<S331>:1:101'
      rtb_Switch1 = 0U;

      // Action '1': '<S331>:1:102'
      MX_Gateway_B.state_AuxFlow = INACTIVE;
    }

    // End of Truth Table: '<S324>/Aux_Control_Logic'

    // Switch: '<S332>/Switch2' incorporates:
    //   Constant: '<S332>/No Limit - Increasing'
    //   Constant: '<S339>/Lower Limit'
    //   Constant: '<S339>/Upper Limit'
    //   Logic: '<S339>/AND'
    //   RelationalOperator: '<S339>/Lower Test'
    //   RelationalOperator: '<S339>/Upper Test'

    if ((CONSTANT_DATA->AUX_RATE_LIMIT_MIN_ENG_SPD <= flt_EngineSpeed) &&
        (flt_EngineSpeed <= CONSTANT_DATA->AUX_RATE_LIMIT_MAX_ENG_SPD)) {
      // Switch: '<S332>/Switch1' incorporates:
      //   Constant: '<S332>/Constant'
      //   Constant: '<S332>/Constant3'
      //   Constant: '<S338>/Constant'
      //   RelationalOperator: '<S338>/Compare'
      //   UnitDelay: '<S332>/Unit Delay'

      if (MX_Gateway_DWork.UnitDelay_DSTATE >
          CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT) {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_NORMAL_RATE;
      } else {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT_RATE;
      }

      // End of Switch: '<S332>/Switch1'
    } else {
      rtb_UkYk1 = 2048000;
    }

    // End of Switch: '<S332>/Switch2'

    // Product: '<S340>/delta rise limit' incorporates:
    //   SampleTimeMath: '<S340>/sample time'
    //
    //  About '<S340>/sample time':
    //   y = K where K = ( w * Ts )

    rtb_sampletime = mul_s32_hiSR(rtb_UkYk1, 1374389535, 5U);

    // Sum: '<S340>/Difference Inputs1' incorporates:
    //   DataTypeConversion: '<S332>/Data Type Conversion1'
    //   UnitDelay: '<S340>/Delay Input2'

    rtb_UkYk1 = (int32_T)((int32_T)rtb_icmd_Base -
                          MX_Gateway_DWork.DelayInput2_DSTATE);

    // Product: '<S340>/delta fall limit' incorporates:
    //   Constant: '<S332>/No Limit - Decreasing'
    //   Product: '<S345>/delta fall limit'
    //   SampleTimeMath: '<S340>/sample time'
    //
    //  About '<S340>/sample time':
    //   y = K where K = ( w * Ts )

    rtb_deltafalllimit_tmp = mul_s32_hiSR(-2048000, 1374389535, 5U);

    // Switch: '<S341>/Switch2' incorporates:
    //   Product: '<S340>/delta fall limit'
    //   RelationalOperator: '<S341>/LowerRelop1'
    //   RelationalOperator: '<S341>/UpperRelop'
    //   Switch: '<S341>/Switch'

    if (rtb_UkYk1 > rtb_sampletime) {
      rtb_UkYk1 = rtb_sampletime;
    } else {
      if (rtb_UkYk1 < rtb_deltafalllimit_tmp) {
        // Switch: '<S341>/Switch' incorporates:
        //   Product: '<S340>/delta fall limit'

        rtb_UkYk1 = rtb_deltafalllimit_tmp;
      }
    }

    // End of Switch: '<S341>/Switch2'

    // Sum: '<S340>/Difference Inputs2' incorporates:
    //   UnitDelay: '<S340>/Delay Input2'

    rtb_sampletime = (int32_T)(rtb_UkYk1 + MX_Gateway_DWork.DelayInput2_DSTATE);

    // DataTypeConversion: '<S332>/Data Type Conversion2'
    rtb_Switch_aazc = (uint16_T)rtb_sampletime;

    // Switch: '<S332>/Switch' incorporates:
    //   Constant: '<S332>/Constant2'
    //   Constant: '<S337>/Constant'
    //   RelationalOperator: '<S337>/Compare'

    if (CONSTANT_DATA->AUX_RATE_LIMIT_FUNCTION == NON_FUNCTIONAL) {
      rtb_Switch_allm = rtb_icmd_Base;
    } else {
      rtb_Switch_allm = rtb_Switch_aazc;
    }

    // End of Switch: '<S332>/Switch'

    // Switch: '<S333>/Switch2' incorporates:
    //   Constant: '<S333>/No Limit - Increasing'
    //   Constant: '<S344>/Lower Limit'
    //   Constant: '<S344>/Upper Limit'
    //   Logic: '<S344>/AND'
    //   RelationalOperator: '<S344>/Lower Test'
    //   RelationalOperator: '<S344>/Upper Test'

    if ((CONSTANT_DATA->AUX_RATE_LIMIT_MIN_ENG_SPD <= flt_EngineSpeed) &&
        (flt_EngineSpeed <= CONSTANT_DATA->AUX_RATE_LIMIT_MAX_ENG_SPD)) {
      // Switch: '<S333>/Switch1' incorporates:
      //   Constant: '<S333>/Constant'
      //   Constant: '<S333>/Constant3'
      //   Constant: '<S343>/Constant'
      //   RelationalOperator: '<S343>/Compare'
      //   UnitDelay: '<S333>/Unit Delay'

      if (MX_Gateway_DWork.UnitDelay_DSTATE_abci >
          CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT) {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_NORMAL_RATE;
      } else {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT_RATE;
      }

      // End of Switch: '<S333>/Switch1'
    } else {
      rtb_UkYk1 = 2048000;
    }

    // End of Switch: '<S333>/Switch2'

    // Product: '<S345>/delta rise limit' incorporates:
    //   SampleTimeMath: '<S345>/sample time'
    //
    //  About '<S345>/sample time':
    //   y = K where K = ( w * Ts )

    rtb_UkYk1 = mul_s32_hiSR(rtb_UkYk1, 1374389535, 5U);

    // Sum: '<S345>/Difference Inputs1' incorporates:
    //   DataTypeConversion: '<S333>/Data Type Conversion1'
    //   UnitDelay: '<S345>/Delay Input2'

    rtb_deltafalllimit = (int32_T)((int32_T)rtb_Switch1 -
      MX_Gateway_DWork.DelayInput2_DSTATE_gc5y);

    // Switch: '<S346>/Switch2' incorporates:
    //   RelationalOperator: '<S346>/LowerRelop1'
    //   RelationalOperator: '<S346>/UpperRelop'
    //   Switch: '<S346>/Switch'

    if (rtb_deltafalllimit > rtb_UkYk1) {
      rtb_deltafalllimit = rtb_UkYk1;
    } else {
      if (rtb_deltafalllimit < rtb_deltafalllimit_tmp) {
        // Switch: '<S346>/Switch'
        rtb_deltafalllimit = rtb_deltafalllimit_tmp;
      }
    }

    // End of Switch: '<S346>/Switch2'

    // Sum: '<S345>/Difference Inputs2' incorporates:
    //   UnitDelay: '<S345>/Delay Input2'

    rtb_UkYk1 = (int32_T)(rtb_deltafalllimit +
                          MX_Gateway_DWork.DelayInput2_DSTATE_gc5y);

    // DataTypeConversion: '<S333>/Data Type Conversion2'
    rtb_icmd_Base = (uint16_T)rtb_UkYk1;

    // Switch: '<S333>/Switch' incorporates:
    //   Constant: '<S333>/Constant2'
    //   Constant: '<S342>/Constant'
    //   RelationalOperator: '<S342>/Compare'

    if (CONSTANT_DATA->AUX_RATE_LIMIT_FUNCTION == NON_FUNCTIONAL) {
      rtb_Switch_dydk = rtb_Switch1;
    } else {
      rtb_Switch_dydk = rtb_icmd_Base;
    }

    // End of Switch: '<S333>/Switch'

    // Logic: '<S321>/Logical Operator' incorporates:
    //   Constant: '<S325>/Constant'
    //   Constant: '<S326>/Constant'
    //   RelationalOperator: '<S325>/Compare'
    //   RelationalOperator: '<S326>/Compare'

    rtb_LogicalOperator_cwje = ((cmd_AuxRelease == INACTIVE) && (state_AuxEnable
      == INACTIVE));

    // Outputs for Atomic SubSystem: '<S321>/hc_pair_control'
    MX_Gatew_output_pair_ClosedLoop(rtb_Switch_allm, rtb_LogicalOperator_cwje,
      afbk_AuxBase, ifbk_AuxBase, MX_Gateway_B.RateTransition2_ad3t,
      state_Engine, MX_Gateway_B.RateTransition3_cdpa, ain_PrecisionReference,
      &MX_Gateway_B.hs_cmd_mvqz, &MX_Gateway_B.ls_cmd_jnku,
      &MX_Gateway_B.error_nvpj, &calc_ifbk_AuxBase,
      &MX_Gateway_B.state_Output_movq, &MX_Gateway_B.hc_pair_control,
      &MX_Gateway_DWork.hc_pair_control,
      CONSTANT_DATA->AUX_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->AUX_KP,
      CONSTANT_DATA->AUX_KI, CONSTANT_DATA->AUX_OVERCURRENT,
      CONSTANT_DATA->AUX_NON_ZERO_DUTY, CONSTANT_DATA->AUX_NON_ZERO_CURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_BATTERY, NON_FUNCTIONAL,
      CONSTANT_DATA->AUX_AFBK_GAIN, CONSTANT_DATA->AUX_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S321>/hc_pair_control'

    // SignalConversion: '<S321>/OutportBufferForerrorCC_AuxBase'
    errorCC_AuxBase = MX_Gateway_B.error_nvpj;

    // Outputs for Atomic SubSystem: '<S321>/hc_pair_control1'
    MX_Gatew_output_pair_ClosedLoop(rtb_Switch_dydk, rtb_LogicalOperator_cwje,
      afbk_AuxRod, ifbk_AuxRod, MX_Gateway_B.RateTransition2_ad3t, state_Engine,
      MX_Gateway_B.RateTransition3_cdpa, ain_PrecisionReference,
      &MX_Gateway_B.hs_cmd_cifl, &MX_Gateway_B.ls_cmd_mxkm,
      &MX_Gateway_B.error_lgr1, &calc_ifbk_AuxRod,
      &MX_Gateway_B.state_Output_akdd, &MX_Gateway_B.hc_pair_control1,
      &MX_Gateway_DWork.hc_pair_control1,
      CONSTANT_DATA->AUX_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->AUX_KP,
      CONSTANT_DATA->AUX_KI, CONSTANT_DATA->AUX_OVERCURRENT,
      CONSTANT_DATA->AUX_NON_ZERO_DUTY, CONSTANT_DATA->AUX_NON_ZERO_CURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_BATTERY, NON_FUNCTIONAL,
      CONSTANT_DATA->AUX_AFBK_GAIN, CONSTANT_DATA->AUX_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S321>/hc_pair_control1'

    // SignalConversion: '<S321>/OutportBufferForerrorCC_AuxRod'
    errorCC_AuxRod = MX_Gateway_B.error_lgr1;

    // SignalConversion: '<S321>/OutportBufferForhs_AuxBase'
    hs_AuxBase = MX_Gateway_B.hs_cmd_mvqz;

    // SignalConversion: '<S321>/OutportBufferForhs_AuxRod'
    hs_AuxRod = MX_Gateway_B.hs_cmd_cifl;

    // SignalConversion: '<S321>/OutportBufferForls_AuxBase'
    ls_AuxBase = MX_Gateway_B.ls_cmd_jnku;

    // SignalConversion: '<S321>/OutportBufferForls_AuxRod'
    ls_AuxRod = MX_Gateway_B.ls_cmd_mxkm;

    // SignalConversion: '<S321>/OutportBufferForstate_AuxBase'
    state_AuxBase = MX_Gateway_B.state_Output_movq;

    // SignalConversion: '<S321>/OutportBufferForstate_AuxRod'
    state_AuxRod = MX_Gateway_B.state_Output_akdd;

    // Update for UnitDelay: '<S332>/Unit Delay'
    MX_Gateway_DWork.UnitDelay_DSTATE = rtb_Switch_aazc;

    // Update for UnitDelay: '<S340>/Delay Input2'
    MX_Gateway_DWork.DelayInput2_DSTATE = rtb_sampletime;

    // Update for UnitDelay: '<S333>/Unit Delay'
    MX_Gateway_DWork.UnitDelay_DSTATE_abci = rtb_icmd_Base;

    // Update for UnitDelay: '<S345>/Delay Input2'
    MX_Gateway_DWork.DelayInput2_DSTATE_gc5y = rtb_UkYk1;
  } else {
    if (MX_Gateway_DWork.Aux_Hydraulics_MODE) {
      // Disable for Atomic SubSystem: '<S321>/hc_pair_control'
      output_pair_ClosedLoop_Disable(&MX_Gateway_B.error_nvpj,
        &MX_Gateway_B.hc_pair_control, &MX_Gateway_DWork.hc_pair_control);

      // End of Disable for SubSystem: '<S321>/hc_pair_control'

      // Disable for Atomic SubSystem: '<S321>/hc_pair_control1'
      output_pair_ClosedLoop_Disable(&MX_Gateway_B.error_lgr1,
        &MX_Gateway_B.hc_pair_control1, &MX_Gateway_DWork.hc_pair_control1);

      // End of Disable for SubSystem: '<S321>/hc_pair_control1'

      // Disable for Outport: '<S321>/hs_AuxBase'
      hs_AuxBase = ((uint16_T)0U);

      // Disable for Outport: '<S321>/ls_AuxBase'
      ls_AuxBase = false;

      // Disable for Outport: '<S321>/errorCC_AuxBase'
      errorCC_AuxBase = 0;

      // Disable for Outport: '<S321>/calc_ifbk_AuxBase'
      calc_ifbk_AuxBase = ((uint16_T)0U);

      // Disable for Outport: '<S321>/state_AuxBase'
      state_AuxBase = ((uint8_T)0U);

      // Disable for Outport: '<S321>/hs_AuxRod'
      hs_AuxRod = ((uint16_T)0U);

      // Disable for Outport: '<S321>/ls_AuxRod'
      ls_AuxRod = false;

      // Disable for Outport: '<S321>/errorCC_AuxRod'
      errorCC_AuxRod = 0;

      // Disable for Outport: '<S321>/calc_ifbk_AuxRod'
      calc_ifbk_AuxRod = ((uint16_T)0U);

      // Disable for Outport: '<S321>/state_AuxFlow'
      MX_Gateway_B.state_AuxFlow = ((uint8_T)0U);
      MX_Gateway_DWork.Aux_Hydraulics_MODE = false;
    }
  }

  // End of Logic: '<S303>/Logical Operator'
  // End of Outputs for SubSystem: '<S303>/Aux_Hydraulics'
}

// Function for Chart: '<S304>/Buzzer'
static void MX_Gateway_Depth_Check(void)
{
  boolean_T guard1 = false;
  boolean_T guard2 = false;

  // During 'Depth_Check': '<S381>:98'
  guard1 = false;
  guard2 = false;
  if (((int32_T)((int32_T)state_DepthBeep & 0x80) != 0x80) || (state_DepthBeep ==
       BEEP_NONE) || (state_System != SYS_NORMAL)) {
    // Transition: '<S381>:100'
    guard1 = true;
  } else if ((state_Buzzer != BEEP_NONE) && (state_Buzzer != NO_BEEP) &&
             (state_System == SYS_NORMAL)) {
    // Transition: '<S381>:125'
    if (state_Buzzer == CONTINUOUS_BEEP) {
      // Transition: '<S381>:56'
      MX_Gateway_DWork.Beeps = 1U;

      // Exit Internal 'Depth_Check': '<S381>:98'
      if (MX_Gateway_DWork.bitsForTID1.is_Depth_Check ==
          MX_Gateway_IN_Grade_Zone) {
        // Exit 'Grade_Zone': '<S381>:107'
        dout_Buzzer = ((int32_T)INACTIVE != 0);
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
      } else {
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

        // Exit Internal 'Below_Grade_Zone': '<S381>:108'
        MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

        // Exit Internal 'Warning_Zone': '<S381>:101'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
      }

      MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_Beep;
      MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_On_lc3ft;

      // Entry 'On': '<S381>:55'
      dout_Buzzer = ((int32_T)ACTIVE != 0);
    } else {
      // Transition: '<S381>:69'
      if (state_Buzzer == SINGLE_SHORT_BEEP) {
        // Transition: '<S381>:12'
        MX_Gateway_DWork.Beeps = 1U;

        // Exit Internal 'Depth_Check': '<S381>:98'
        if (MX_Gateway_DWork.bitsForTID1.is_Depth_Check ==
            MX_Gateway_IN_Grade_Zone) {
          // Exit 'Grade_Zone': '<S381>:107'
          dout_Buzzer = ((int32_T)INACTIVE != 0);
          MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
            MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        } else {
          MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
            MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

          // Exit Internal 'Below_Grade_Zone': '<S381>:108'
          MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
            MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

          // Exit Internal 'Warning_Zone': '<S381>:101'
          MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
            MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        }

        MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_Beep;
        MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Single_On;
        MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry 'Single_On': '<S381>:136'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else {
        // Transition: '<S381>:70'
        if (state_Buzzer == DOUBLE_SHORT_BEEP) {
          // Transition: '<S381>:13'
          MX_Gateway_DWork.Beeps = 2U;
          guard2 = true;
        } else {
          // Transition: '<S381>:73'
          if (state_Buzzer == TRIPLE_SHORT_BEEP) {
            // Transition: '<S381>:18'
            MX_Gateway_DWork.Beeps = 3U;
            guard2 = true;
          } else {
            // Transition: '<S381>:95'
            if (state_Buzzer == QUAD_SHORT_BEEP) {
              // Transition: '<S381>:96'
              MX_Gateway_DWork.Beeps = 4U;
              guard2 = true;
            } else {
              // Transition: '<S381>:75'
              if (state_Buzzer == SINGLE_MEDIUM_BEEP) {
                // Transition: '<S381>:9'
                MX_Gateway_DWork.Beeps = 1U;

                // Exit Internal 'Depth_Check': '<S381>:98'
                if (MX_Gateway_DWork.bitsForTID1.is_Depth_Check ==
                    MX_Gateway_IN_Grade_Zone) {
                  // Exit 'Grade_Zone': '<S381>:107'
                  dout_Buzzer = ((int32_T)INACTIVE != 0);
                  MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
                    MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
                } else {
                  MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
                    MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

                  // Exit Internal 'Below_Grade_Zone': '<S381>:108'
                  MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
                    MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

                  // Exit Internal 'Warning_Zone': '<S381>:101'
                  MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
                    MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
                }

                MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
                  MX_Gateway_IN_Beep;
                MX_Gateway_DWork.bitsForTID1.is_Beep =
                  MX_Gateway_IN_One_Beep_Medium;
                MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

                // Entry 'One_Beep_Medium': '<S381>:3'
                dout_Buzzer = ((int32_T)ACTIVE != 0);
              } else {
                // Transition: '<S381>:90'
                if (state_Buzzer == SINGLE_LONG_BEEP) {
                  // Transition: '<S381>:89'
                  MX_Gateway_DWork.Beeps = 1U;

                  // Exit Internal 'Depth_Check': '<S381>:98'
                  if (MX_Gateway_DWork.bitsForTID1.is_Depth_Check ==
                      MX_Gateway_IN_Grade_Zone) {
                    // Exit 'Grade_Zone': '<S381>:107'
                    dout_Buzzer = ((int32_T)INACTIVE != 0);
                    MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
                      MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
                  } else {
                    MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
                      MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

                    // Exit Internal 'Below_Grade_Zone': '<S381>:108'
                    MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
                      MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

                    // Exit Internal 'Warning_Zone': '<S381>:101'
                    MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
                      MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
                  }

                  MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
                    MX_Gateway_IN_Beep;
                  MX_Gateway_DWork.bitsForTID1.is_Beep =
                    MX_Gateway_IN_One_Beep_Long;
                  MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

                  // Entry 'One_Beep_Long': '<S381>:88'
                  dout_Buzzer = ((int32_T)ACTIVE != 0);
                } else {
                  // Transition: '<S381>:78'
                  guard1 = true;
                }
              }
            }
          }
        }
      }
    }
  } else {
    switch (MX_Gateway_DWork.bitsForTID1.is_Depth_Check) {
     case MX_Gateway_IN_Below_Grade_Zone:
      // During 'Below_Grade_Zone': '<S381>:108'
      if (state_DepthBeep == DC_WARNING_BEEP) {
        // Transition: '<S381>:121'
        // Exit Internal 'Below_Grade_Zone': '<S381>:108'
        MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check = MX_Gateway_IN_Warning_Zone;
        MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry Internal 'Warning_Zone': '<S381>:101'
        // Transition: '<S381>:102'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone = MX_Gateway_IN_On_lc3f;
        MX_Gateway_DWork.temporalCounter_i2_b2ny = 0U;

        // Entry 'On': '<S381>:104'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (state_DepthBeep == DC_GRADE_BEEP) {
        // Transition: '<S381>:119'
        // Exit Internal 'Below_Grade_Zone': '<S381>:108'
        MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check = MX_Gateway_IN_Grade_Zone;

        // Entry 'Grade_Zone': '<S381>:107'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone ==
                 MX_Gateway_IN_Off_fwwp) {
        // During 'Off': '<S381>:113'
        if (MX_Gateway_DWork.temporalCounter_i1_omi3 >=
            CONSTANT_DATA->CHIRP_OFF_LENGTH) {
          // Transition: '<S381>:110'
          MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
            MX_Gateway_IN_On_lc3f;
          MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry 'On': '<S381>:112'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        }
      } else {
        // During 'On': '<S381>:112'
        if (MX_Gateway_DWork.temporalCounter_i1_omi3 >=
            CONSTANT_DATA->CHIRP_ON_LENGTH) {
          // Transition: '<S381>:111'
          MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
            MX_Gateway_IN_Off_fwwp;
          MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry 'Off': '<S381>:113'
          dout_Buzzer = ((int32_T)INACTIVE != 0);
        }
      }
      break;

     case MX_Gateway_IN_Grade_Zone:
      // During 'Grade_Zone': '<S381>:107'
      if (state_DepthBeep == DC_WARNING_BEEP) {
        // Transition: '<S381>:117'
        // Exit 'Grade_Zone': '<S381>:107'
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check = MX_Gateway_IN_Warning_Zone;
        MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry Internal 'Warning_Zone': '<S381>:101'
        // Transition: '<S381>:102'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone = MX_Gateway_IN_On_lc3f;
        MX_Gateway_DWork.temporalCounter_i2_b2ny = 0U;

        // Entry 'On': '<S381>:104'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else {
        if (state_DepthBeep == DC_BELOW_GRADE_BEEP) {
          // Transition: '<S381>:118'
          // Exit 'Grade_Zone': '<S381>:107'
          MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
            MX_Gateway_IN_Below_Grade_Zone;

          // Entry Internal 'Below_Grade_Zone': '<S381>:108'
          // Transition: '<S381>:109'
          MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
            MX_Gateway_IN_On_lc3f;
          MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry 'On': '<S381>:112'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        }
      }
      break;

     default:
      // During 'Warning_Zone': '<S381>:101'
      if (MX_Gateway_DWork.temporalCounter_i1_omi3 >= delay_DepthBeep) {
        // Transition: '<S381>:106'
        // Exit Internal 'Warning_Zone': '<S381>:101'
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check = MX_Gateway_IN_Warning_Zone;
        MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry Internal 'Warning_Zone': '<S381>:101'
        // Transition: '<S381>:102'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone = MX_Gateway_IN_On_lc3f;
        MX_Gateway_DWork.temporalCounter_i2_b2ny = 0U;

        // Entry 'On': '<S381>:104'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (state_DepthBeep == DC_GRADE_BEEP) {
        // Transition: '<S381>:115'
        // Exit Internal 'Warning_Zone': '<S381>:101'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check = MX_Gateway_IN_Grade_Zone;

        // Entry 'Grade_Zone': '<S381>:107'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (state_DepthBeep == DC_BELOW_GRADE_BEEP) {
        // Transition: '<S381>:116'
        // Exit Internal 'Warning_Zone': '<S381>:101'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
          MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
          MX_Gateway_IN_Below_Grade_Zone;

        // Entry Internal 'Below_Grade_Zone': '<S381>:108'
        // Transition: '<S381>:109'
        MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone = MX_Gateway_IN_On_lc3f;
        MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry 'On': '<S381>:112'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if ((MX_Gateway_DWork.bitsForTID1.is_Warning_Zone ==
                  MX_Gateway_IN_Off_fwwp) ||
                 (!(MX_Gateway_DWork.temporalCounter_i2_b2ny >=
                    CONSTANT_DATA->WARNING_BEEP_LENGTH))) {
        // During 'Off': '<S381>:105'
      } else {
        // During 'On': '<S381>:104'
        // Transition: '<S381>:103'
        MX_Gateway_DWork.bitsForTID1.is_Warning_Zone = MX_Gateway_IN_Off_fwwp;

        // Entry 'Off': '<S381>:105'
        dout_Buzzer = ((int32_T)INACTIVE != 0);
      }
      break;
    }
  }

  if (guard2) {
    // Exit Internal 'Depth_Check': '<S381>:98'
    if (MX_Gateway_DWork.bitsForTID1.is_Depth_Check == MX_Gateway_IN_Grade_Zone)
    {
      // Exit 'Grade_Zone': '<S381>:107'
      dout_Buzzer = ((int32_T)INACTIVE != 0);
      MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
    } else {
      MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Below_Grade_Zone': '<S381>:108'
      MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Warning_Zone': '<S381>:101'
      MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
    }

    MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_Beep;
    MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Multiple_On;
    MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

    // Entry 'Multiple_On': '<S381>:4'
    dout_Buzzer = ((int32_T)ACTIVE != 0);
  }

  if (guard1) {
    // Exit Internal 'Depth_Check': '<S381>:98'
    if (MX_Gateway_DWork.bitsForTID1.is_Depth_Check == MX_Gateway_IN_Grade_Zone)
    {
      // Exit 'Grade_Zone': '<S381>:107'
      dout_Buzzer = ((int32_T)INACTIVE != 0);
      MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
    } else {
      MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Below_Grade_Zone': '<S381>:108'
      MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Warning_Zone': '<S381>:101'
      MX_Gateway_DWork.bitsForTID1.is_Warning_Zone =
        MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
    }

    MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_No_Beep;

    // Entry 'No_Beep': '<S381>:1'
    dout_Buzzer = ((int32_T)INACTIVE != 0);
    state_Buzzer = NO_BEEP;
    MX_Gateway_DWork.Beeps = 0U;
  }
}

// System initialize for atomic system: '<S26>/Buzzer'
void MX_Gateway_Buzzer_Init(void)
{
  // SystemInitialize for Chart: '<S304>/Buzzer'
  MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gateway_DWork.bitsForTID1.is_Depth_Check = MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gateway_DWork.bitsForTID1.is_Below_Grade_Zone =
    MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gateway_DWork.bitsForTID1.is_Warning_Zone = MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;
  MX_Gateway_DWork.temporalCounter_i2_b2ny = 0U;
  MX_Gateway_DWork.bitsForTID1.is_active_c65_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gateway_DWork.Beeps = 0U;
  dout_Buzzer = false;
}

// Output and update for atomic system: '<S26>/Buzzer'
void MX_Gateway_Buzzer(void)
{
  boolean_T guard1 = false;

  // Chart: '<S304>/Buzzer'
  // Gateway: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
  if ((uint32_T)MX_Gateway_DWork.temporalCounter_i1_omi3 < 65535U) {
    MX_Gateway_DWork.temporalCounter_i1_omi3 = (uint16_T)(int32_T)((int32_T)
      MX_Gateway_DWork.temporalCounter_i1_omi3 + 1);
  }

  if ((uint32_T)MX_Gateway_DWork.temporalCounter_i2_b2ny < 255U) {
    MX_Gateway_DWork.temporalCounter_i2_b2ny = (uint8_T)(int32_T)((int32_T)
      MX_Gateway_DWork.temporalCounter_i2_b2ny + 1);
  }

  // During: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
  if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c65_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
    MX_Gateway_DWork.bitsForTID1.is_active_c65_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
    // Transition: '<S381>:83'
    MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_No_Beep;

    // Entry 'No_Beep': '<S381>:1'
    dout_Buzzer = ((int32_T)INACTIVE != 0);
    state_Buzzer = NO_BEEP;
    MX_Gateway_DWork.Beeps = 0U;
  } else {
    guard1 = false;
    switch (MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway) {
     case MX_Gateway_IN_Beep:
      // During 'Beep': '<S381>:71'
      if ((state_Buzzer == NO_BEEP) || (!((int32_T)MX_Gateway_DWork.Beeps != 0))
          || (state_System != SYS_NORMAL)) {
        // Transition: '<S381>:57'
        // Exit Internal 'Beep': '<S381>:71'
        MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gate_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_No_Beep;

        // Entry 'No_Beep': '<S381>:1'
        dout_Buzzer = ((int32_T)INACTIVE != 0);
        state_Buzzer = NO_BEEP;
        MX_Gateway_DWork.Beeps = 0U;
      } else {
        switch (MX_Gateway_DWork.bitsForTID1.is_Beep) {
         case MX_Gateway_IN_Brief_Off:
          // During 'Brief_Off': '<S381>:58'
          if ((int32_T)MX_Gateway_DWork.temporalCounter_i1_omi3 >= 10) {
            // Transition: '<S381>:59'
            MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Multiple_On;
            MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Multiple_On': '<S381>:4'
            dout_Buzzer = ((int32_T)ACTIVE != 0);
          }
          break;

         case MX_Gateway_IN_Multiple_Off:
          // During 'Multiple_Off': '<S381>:5'
          if ((int32_T)MX_Gateway_DWork.temporalCounter_i1_omi3 >= 20) {
            // Transition: '<S381>:16'
            MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Multiple_On;
            MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Multiple_On': '<S381>:4'
            dout_Buzzer = ((int32_T)ACTIVE != 0);
          }
          break;

         case MX_Gateway_IN_Multiple_On:
          // During 'Multiple_On': '<S381>:4'
          if ((int32_T)MX_Gateway_DWork.temporalCounter_i1_omi3 >= 10) {
            // Transition: '<S381>:15'
            MX_Gateway_DWork.Beeps = (uint8_T)(int32_T)((int32_T)
              MX_Gateway_DWork.Beeps - 1);
            MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Multiple_Off;
            MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Multiple_Off': '<S381>:5'
            dout_Buzzer = ((int32_T)INACTIVE != 0);
          }
          break;

         case MX_Gateway_IN_On_lc3ft:
          // During 'On': '<S381>:55'
          break;

         case MX_Gateway_IN_One_Beep_Long:
          // During 'One_Beep_Long': '<S381>:88'
          if (MX_Gateway_DWork.temporalCounter_i1_omi3 >=
              MX_Gateway_FIFTEEN_SECONDS) {
            MX_Gateway_DWork.Beeps = 0U;
          }
          break;

         case MX_Gateway_IN_One_Beep_Medium:
          // During 'One_Beep_Medium': '<S381>:3'
          if ((state_Buzzer == TRIPLE_SHORT_BEEP) && ((int32_T)
               MX_Gateway_DWork.temporalCounter_i1_omi3 >= 50)) {
            // Transition: '<S381>:27'
            MX_Gateway_DWork.Beeps = 3U;
            MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Brief_Off;
            MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Brief_Off': '<S381>:58'
            dout_Buzzer = ((int32_T)INACTIVE != 0);
          } else {
            if (MX_Gateway_DWork.temporalCounter_i1_omi3 >=
                MX_Gateway_ONE_SECOND_ezbk) {
              MX_Gateway_DWork.Beeps = 0U;
            }
          }
          break;

         case MX_Gateway_IN_Single_Off:
          // During 'Single_Off': '<S381>:137'
          break;

         default:
          // During 'Single_On': '<S381>:136'
          if ((int32_T)MX_Gateway_DWork.temporalCounter_i1_omi3 >= 10) {
            // Transition: '<S381>:138'
            MX_Gateway_DWork.Beeps = (uint8_T)(int32_T)((int32_T)
              MX_Gateway_DWork.Beeps - 1);
            MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Single_Off;

            // Entry 'Single_Off': '<S381>:137'
            dout_Buzzer = ((int32_T)INACTIVE != 0);
          } else {
            if (state_Buzzer == TRIPLE_SHORT_BEEP) {
              // Transition: '<S381>:139'
              MX_Gateway_DWork.Beeps = 3U;
              MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Multiple_On;
              MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

              // Entry 'Multiple_On': '<S381>:4'
              dout_Buzzer = ((int32_T)ACTIVE != 0);
            }
          }
          break;
        }
      }
      break;

     case MX_Gateway_IN_Depth_Check:
      MX_Gateway_Depth_Check();
      break;

     default:
      // During 'No_Beep': '<S381>:1'
      if ((state_Buzzer != BEEP_NONE) && (state_Buzzer != NO_BEEP) &&
          (state_System == SYS_NORMAL)) {
        // Transition: '<S381>:66'
        if (state_Buzzer == CONTINUOUS_BEEP) {
          // Transition: '<S381>:56'
          MX_Gateway_DWork.Beeps = 1U;
          MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_Beep;
          MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_On_lc3ft;

          // Entry 'On': '<S381>:55'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        } else {
          // Transition: '<S381>:69'
          if (state_Buzzer == SINGLE_SHORT_BEEP) {
            // Transition: '<S381>:12'
            MX_Gateway_DWork.Beeps = 1U;
            MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_Beep;
            MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Single_On;
            MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Single_On': '<S381>:136'
            dout_Buzzer = ((int32_T)ACTIVE != 0);
          } else {
            // Transition: '<S381>:70'
            if (state_Buzzer == DOUBLE_SHORT_BEEP) {
              // Transition: '<S381>:13'
              MX_Gateway_DWork.Beeps = 2U;
              guard1 = true;
            } else {
              // Transition: '<S381>:73'
              if (state_Buzzer == TRIPLE_SHORT_BEEP) {
                // Transition: '<S381>:18'
                MX_Gateway_DWork.Beeps = 3U;
                guard1 = true;
              } else {
                // Transition: '<S381>:95'
                if (state_Buzzer == QUAD_SHORT_BEEP) {
                  // Transition: '<S381>:96'
                  MX_Gateway_DWork.Beeps = 4U;
                  guard1 = true;
                } else {
                  // Transition: '<S381>:75'
                  if (state_Buzzer == SINGLE_MEDIUM_BEEP) {
                    // Transition: '<S381>:9'
                    MX_Gateway_DWork.Beeps = 1U;
                    MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
                      MX_Gateway_IN_Beep;
                    MX_Gateway_DWork.bitsForTID1.is_Beep =
                      MX_Gateway_IN_One_Beep_Medium;
                    MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

                    // Entry 'One_Beep_Medium': '<S381>:3'
                    dout_Buzzer = ((int32_T)ACTIVE != 0);
                  } else {
                    // Transition: '<S381>:90'
                    if (state_Buzzer == SINGLE_LONG_BEEP) {
                      // Transition: '<S381>:89'
                      MX_Gateway_DWork.Beeps = 1U;
                      MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
                        MX_Gateway_IN_Beep;
                      MX_Gateway_DWork.bitsForTID1.is_Beep =
                        MX_Gateway_IN_One_Beep_Long;
                      MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

                      // Entry 'One_Beep_Long': '<S381>:88'
                      dout_Buzzer = ((int32_T)ACTIVE != 0);
                    } else {
                      // Transition: '<S381>:78'
                      MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
                        MX_Gateway_IN_No_Beep;

                      // Entry 'No_Beep': '<S381>:1'
                      dout_Buzzer = ((int32_T)INACTIVE != 0);
                      state_Buzzer = NO_BEEP;
                      MX_Gateway_DWork.Beeps = 0U;
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if ((CONSTANT_DATA->DEPTH_CHECK_FUNCTION != NON_FUNCTIONAL) && ((int32_T)
             ((int32_T)state_DepthBeep & 0x80) == 0x80) && (state_DepthBeep !=
             BEEP_NONE) && (state_System == SYS_NORMAL)) {
          // Transition: '<S381>:99'
          MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway =
            MX_Gateway_IN_Depth_Check;

          // Entry Internal 'Depth_Check': '<S381>:98'
          // Transition: '<S381>:114'
          MX_Gateway_DWork.bitsForTID1.is_Depth_Check =
            MX_Gateway_IN_Warning_Zone;
          MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry Internal 'Warning_Zone': '<S381>:101'
          // Transition: '<S381>:102'
          MX_Gateway_DWork.bitsForTID1.is_Warning_Zone = MX_Gateway_IN_On_lc3f;
          MX_Gateway_DWork.temporalCounter_i2_b2ny = 0U;

          // Entry 'On': '<S381>:104'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        }
      }
      break;
    }

    if (guard1) {
      MX_Gateway_DWork.bitsForTID1.is_c65_MX_Gateway = MX_Gateway_IN_Beep;
      MX_Gateway_DWork.bitsForTID1.is_Beep = MX_Gateway_IN_Multiple_On;
      MX_Gateway_DWork.temporalCounter_i1_omi3 = 0U;

      // Entry 'Multiple_On': '<S381>:4'
      dout_Buzzer = ((int32_T)ACTIVE != 0);
    }
  }

  // End of Chart: '<S304>/Buzzer'
}

// System initialize for atomic system: '<S26>/Diverter'
void MX_Gateway_Diverter_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S305>/Diverter'
  // InitializeConditions for UnitDelay: '<S386>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE_igsh = ((uint8_T)0U);

  // SystemInitialize for Chart: '<S386>/Diverter'
  MX_Gateway_DWork.bitsForTID1.is_EMEA_CONTROLS_lam2 =
    MX_Gate_IN_NO_ACTIVE_CHILD_fi0h;
  MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
    MX_Gate_IN_NO_ACTIVE_CHILD_fi0h;
  MX_Gateway_DWork.temporalCounter_i1_lihp = 0U;
  MX_Gateway_DWork.bitsForTID1.is_active_c61_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c61_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_fi0h;
  MX_Gateway_DWork.bitsForTID1.switch_hold = false;
  MX_Gateway_B.cmd_Diverter_hj33 = false;

  // SystemInitialize for Atomic SubSystem: '<S386>/output_pair_open_loop'
  MX_Ga_output_pair_OpenLoop_Init(&MX_Gateway_B.hs_cmd_evjd,
    &MX_Gateway_B.ls_cmd_obnv, &MX_Gateway_B.state_Output_h0ge,
    &MX_Gateway_B.output_pair_open_loop, &MX_Gateway_DWork.output_pair_open_loop);

  // End of SystemInitialize for SubSystem: '<S386>/output_pair_open_loop'

  // End of SystemInitialize for SubSystem: '<S305>/Diverter'
}

// Output and update for atomic system: '<S26>/Diverter'
void MX_Gateway_Diverter(void)
{
  boolean_T rtb_Compare_cedi;

  // Outputs for Enabled SubSystem: '<S305>/Diverter' incorporates:
  //   EnablePort: '<S386>/Enable'

  // Logic: '<S305>/Logical Operator' incorporates:
  //   Constant: '<S305>/Constant'
  //   Constant: '<S305>/Constant1'
  //   Constant: '<S305>/Constant2'
  //   Constant: '<S382>/Constant'
  //   Constant: '<S383>/Constant'
  //   Constant: '<S384>/Constant'
  //   Constant: '<S385>/Constant'
  //   Logic: '<S305>/Logical Operator1'
  //   RelationalOperator: '<S382>/Compare'
  //   RelationalOperator: '<S383>/Compare'
  //   RelationalOperator: '<S384>/Compare'
  //   RelationalOperator: '<S385>/Compare'

  if ((state_System == SYS_NORMAL) && ((CONSTANT_DATA->SECOND_AUX_FUNCTION !=
        NON_FUNCTIONAL) || (CONSTANT_DATA->EMEA_CONTROLS_OPTION_A !=
        NON_FUNCTIONAL) || (CONSTANT_DATA->EMEA_CONTROLS_OPTION_C !=
        NON_FUNCTIONAL))) {
    if (!MX_Gateway_DWork.Diverter_MODE) {
      // InitializeConditions for UnitDelay: '<S386>/Unit Delay'
      MX_Gateway_DWork.UnitDelay_DSTATE_igsh = ((uint8_T)0U);

      // SystemReset for Chart: '<S386>/Diverter'
      MX_Gateway_DWork.bitsForTID1.is_EMEA_CONTROLS_lam2 =
        MX_Gate_IN_NO_ACTIVE_CHILD_fi0h;
      MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
        MX_Gate_IN_NO_ACTIVE_CHILD_fi0h;
      MX_Gateway_DWork.temporalCounter_i1_lihp = 0U;
      MX_Gateway_DWork.bitsForTID1.is_active_c61_MX_Gateway = 0U;
      MX_Gateway_DWork.bitsForTID1.is_c61_MX_Gateway =
        MX_Gate_IN_NO_ACTIVE_CHILD_fi0h;
      MX_Gateway_DWork.bitsForTID1.switch_hold = false;
      MX_Gateway_B.cmd_Diverter_hj33 = false;

      // SystemReset for Atomic SubSystem: '<S386>/output_pair_open_loop'
      MX_G_output_pair_OpenLoop_Reset(&MX_Gateway_B.hs_cmd_evjd,
        &MX_Gateway_B.ls_cmd_obnv, &MX_Gateway_B.state_Output_h0ge,
        &MX_Gateway_B.output_pair_open_loop,
        &MX_Gateway_DWork.output_pair_open_loop);

      // End of SystemReset for SubSystem: '<S386>/output_pair_open_loop'
      MX_Gateway_DWork.Diverter_MODE = true;
    }

    // RelationalOperator: '<S387>/Compare' incorporates:
    //   Constant: '<S387>/Constant'

    rtb_Compare_cedi = (state_Console != ACTIVE);

    // Chart: '<S386>/Diverter' incorporates:
    //   UnitDelay: '<S386>/Unit Delay'

    // Gateway: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
    if ((uint32_T)MX_Gateway_DWork.temporalCounter_i1_lihp < 65535U) {
      MX_Gateway_DWork.temporalCounter_i1_lihp = (uint16_T)(int32_T)((int32_T)
        MX_Gateway_DWork.temporalCounter_i1_lihp + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
    if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c61_MX_Gateway == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
      MX_Gateway_DWork.bitsForTID1.is_active_c61_MX_Gateway = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
      // Transition: '<S388>:121'
      MX_Gateway_DWork.bitsForTID1.is_c61_MX_Gateway =
        MX_Gatew_IN_NON_FUNCTIONAL_menq;

      // Entry 'NON_FUNCTIONAL': '<S388>:117'
      MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
    } else {
      switch (MX_Gateway_DWork.bitsForTID1.is_c61_MX_Gateway) {
       case MX_Gateway_IN_EMEA_CONTROLS:
        // During 'EMEA_CONTROLS': '<S388>:100'
        if (MX_Gateway_DWork.bitsForTID1.is_EMEA_CONTROLS_lam2 ==
            MX_Gateway_IN_ACTIVE_azwi) {
          // During 'ACTIVE': '<S388>:123'
          if ((mode_LeftControl != MODE_LEFT_AUX2) ||
              (MX_Gateway_DWork.UnitDelay_DSTATE_igsh != ACTIVE)) {
            // Transition: '<S388>:125'
            MX_Gateway_DWork.bitsForTID1.is_EMEA_CONTROLS_lam2 =
              MX_Gateway_IN_INACTIVE_cstq;

            // Entry 'INACTIVE': '<S388>:112'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          }
        } else {
          // During 'INACTIVE': '<S388>:112'
          if ((mode_LeftControl == MODE_LEFT_AUX2) &&
              (MX_Gateway_DWork.UnitDelay_DSTATE_igsh == INACTIVE)) {
            // Transition: '<S388>:124'
            MX_Gateway_DWork.bitsForTID1.is_EMEA_CONTROLS_lam2 =
              MX_Gateway_IN_ACTIVE_azwi;

            // Entry 'ACTIVE': '<S388>:123'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
          }
        }
        break;

       case MX_Gatew_IN_NON_FUNCTIONAL_menq:
        // During 'NON_FUNCTIONAL': '<S388>:117'
        if ((CONSTANT_DATA->EMEA_CONTROLS_OPTION_A != NON_FUNCTIONAL) ||
            (CONSTANT_DATA->EMEA_CONTROLS_OPTION_C != NON_FUNCTIONAL)) {
          // Transition: '<S388>:120'
          MX_Gateway_DWork.bitsForTID1.is_c61_MX_Gateway =
            MX_Gateway_IN_EMEA_CONTROLS;

          // Entry Internal 'EMEA_CONTROLS': '<S388>:100'
          // Transition: '<S388>:101'
          MX_Gateway_DWork.bitsForTID1.is_EMEA_CONTROLS_lam2 =
            MX_Gateway_IN_INACTIVE_cstq;

          // Entry 'INACTIVE': '<S388>:112'
          MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
        } else {
          if (CONSTANT_DATA->SECOND_AUX_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S388>:122'
            MX_Gateway_DWork.bitsForTID1.is_c61_MX_Gateway =
              MX_Gateway_IN_SECOND_AUX_NA;

            // Entry Internal 'SECOND_AUX_NA': '<S388>:99'
            // Transition: '<S388>:78'
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_InactiveCheck;

            // Entry 'InactiveCheck': '<S388>:88'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          }
        }
        break;

       default:
        // During 'SECOND_AUX_NA': '<S388>:99'
        switch (MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA) {
         case MX_Gateway_IN_Active_hlsv:
          // During 'Active': '<S388>:80'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S388>:95'
            MX_Gateway_DWork.bitsForTID1.switch_hold = ((int32_T)INACTIVE != 0);
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_Active_hlsv;

            // Entry 'Active': '<S388>:80'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
          } else if ((din_SecondAuxSw == (int32_T)ACTIVE) &&
                     (MX_Gateway_DWork.bitsForTID1.switch_hold == (int32_T)
                      INACTIVE)) {
            // Transition: '<S388>:85'
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_DebounceInactive;
            MX_Gateway_DWork.temporalCounter_i1_lihp = 0U;
          } else {
            if ((MX_Gateway_DWork.UnitDelay_DSTATE_igsh != ACTIVE) &&
                (MX_Gateway_DWork.UnitDelay_DSTATE_igsh != INACTIVE)) {
              // Transition: '<S388>:92'
              MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
                MX_Gateway_IN_Inactive_lhek;

              // Entry 'Inactive': '<S388>:77'
              MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
            }
          }
          break;

         case MX_Gateway_IN_DebounceActive:
          // During 'DebounceActive': '<S388>:79'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S388>:82'
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_Inactive_lhek;

            // Entry 'Inactive': '<S388>:77'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          } else {
            if (MX_Gateway_DWork.temporalCounter_i1_lihp >=
                CONSTANT_DATA->SECOND_AUX_SWITCH_DEBOUNCE) {
              // Transition: '<S388>:83'
              state_Buzzer = SINGLE_SHORT_BEEP;
              MX_Gateway_DWork.bitsForTID1.switch_hold = ((int32_T)ACTIVE != 0);
              MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
                MX_Gateway_IN_Active_hlsv;

              // Entry 'Active': '<S388>:80'
              MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
            }
          }
          break;

         case MX_Gateway_IN_DebounceInactive:
          // During 'DebounceInactive': '<S388>:84'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S388>:86'
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_Active_hlsv;

            // Entry 'Active': '<S388>:80'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
          } else {
            if (MX_Gateway_DWork.temporalCounter_i1_lihp >=
                CONSTANT_DATA->SECOND_AUX_SWITCH_DEBOUNCE) {
              // Transition: '<S388>:87'
              state_Buzzer = SINGLE_SHORT_BEEP;
              MX_Gateway_DWork.bitsForTID1.switch_hold = ((int32_T)ACTIVE != 0);
              MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
                MX_Gateway_IN_Inactive_lhek;

              // Entry 'Inactive': '<S388>:77'
              MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
            }
          }
          break;

         case MX_Gateway_IN_Inactive_lhek:
          // During 'Inactive': '<S388>:77'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S388>:96'
            MX_Gateway_DWork.bitsForTID1.switch_hold = ((int32_T)INACTIVE != 0);
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_Inactive_lhek;

            // Entry 'Inactive': '<S388>:77'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          } else {
            if ((din_SecondAuxSw == (int32_T)ACTIVE) &&
                (MX_Gateway_DWork.UnitDelay_DSTATE_igsh == INACTIVE) &&
                (MX_Gateway_DWork.bitsForTID1.switch_hold == (int32_T)INACTIVE))
            {
              // Transition: '<S388>:81'
              MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
                MX_Gateway_IN_DebounceActive;
              MX_Gateway_DWork.temporalCounter_i1_lihp = 0U;
            }
          }
          break;

         default:
          // During 'InactiveCheck': '<S388>:88'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S388>:89'
            MX_Gateway_DWork.bitsForTID1.is_SECOND_AUX_NA =
              MX_Gateway_IN_Inactive_lhek;

            // Entry 'Inactive': '<S388>:77'
            MX_Gateway_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          }
          break;
        }
        break;
      }
    }

    // End of Chart: '<S386>/Diverter'

    // SignalConversion: '<S386>/OutportBufferForcmd_Diverter'
    cmd_Diverter = MX_Gateway_B.cmd_Diverter_hj33;

    // Outputs for Atomic SubSystem: '<S386>/output_pair_open_loop'
    MX_Gateway_output_pair_OpenLoop(MX_Gateway_B.cmd_Diverter_hj33,
      rtb_Compare_cedi, state_Engine, afbk_Diverter, ifbk_Diverter,
      MX_Gateway_B.RateTransition46, MX_Gateway_B.RateTransition45,
      ain_PrecisionReference, &MX_Gateway_B.hs_cmd_evjd,
      &MX_Gateway_B.ls_cmd_obnv, &MX_Gateway_B.state_Output_h0ge,
      &MX_Gateway_B.output_pair_open_loop,
      &MX_Gateway_DWork.output_pair_open_loop,
      CONSTANT_DATA->SECOND_AUX_MAX_VOLTS,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->SECOND_AUX_OVERCURRENT,
      CONSTANT_DATA->SECOND_AUX_NON_ZERO_DUTY,
      CONSTANT_DATA->SECOND_AUX_NON_ZERO_CURRENT,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->SECOND_AUX_FEEDBACK_FUNCTION,
      CONSTANT_DATA->SECOND_AUX_AFBK_GAIN, CONSTANT_DATA->SECOND_AUX_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S386>/output_pair_open_loop'

    // SignalConversion: '<S386>/OutportBufferForhs_Diverter'
    hs_Diverter = MX_Gateway_B.hs_cmd_evjd;

    // SignalConversion: '<S386>/OutportBufferForls_Diverter'
    ls_Diverter = MX_Gateway_B.ls_cmd_obnv;

    // SignalConversion: '<S386>/OutportBufferForstate_Diverter'
    state_Diverter = MX_Gateway_B.state_Output_h0ge;

    // Update for UnitDelay: '<S386>/Unit Delay'
    MX_Gateway_DWork.UnitDelay_DSTATE_igsh = MX_Gateway_B.state_Output_h0ge;
  } else {
    if (MX_Gateway_DWork.Diverter_MODE) {
      // Disable for Outport: '<S386>/state_Diverter'
      state_Diverter = ((uint8_T)0U);

      // Disable for Outport: '<S386>/hs_Diverter'
      hs_Diverter = ((uint16_T)0U);

      // Disable for Outport: '<S386>/ls_Diverter'
      ls_Diverter = false;

      // Disable for Outport: '<S386>/cmd_Diverter'
      cmd_Diverter = false;
      MX_Gateway_DWork.Diverter_MODE = false;
    }
  }

  // End of Logic: '<S305>/Logical Operator'
  // End of Outputs for SubSystem: '<S305>/Diverter'
}

// System initialize for atomic system: '<S26>/Dump_Valve'
void MX_Gateway_Dump_Valve_Init(void)
{
  uint16_T rtb_icmd_DumpValve;

  // SystemInitialize for Enabled SubSystem: '<S306>/Dump_Valve'
  // SystemInitialize for Chart: '<S406>/Dump_Valve'
  MX_Gateway_DWork.bitsForTID1.is_active_c10_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c10_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_lqez;
  rtb_icmd_DumpValve = 0U;

  // SystemInitialize for Atomic SubSystem: '<S406>/hc_pair_control'
  MX__output_pair_ClosedLoop_Init(&MX_Gateway_B.hs_cmd_cnig,
    &MX_Gateway_B.ls_cmd_fvfb, &MX_Gateway_B.state_Output_au4i,
    &MX_Gateway_B.hc_pair_control_mjt1, &MX_Gateway_DWork.hc_pair_control_mjt1);

  // End of SystemInitialize for SubSystem: '<S406>/hc_pair_control'

  // End of SystemInitialize for SubSystem: '<S306>/Dump_Valve'
}

// Output and update for atomic system: '<S26>/Dump_Valve'
void MX_Gateway_Dump_Valve(void)
{
  uint16_T rtb_icmd_DumpValve;
  boolean_T rtb_Compare_phgj;

  // Outputs for Enabled SubSystem: '<S306>/Dump_Valve' incorporates:
  //   EnablePort: '<S406>/Enable'

  // Logic: '<S306>/Logical Operator' incorporates:
  //   Constant: '<S306>/Constant'
  //   Constant: '<S404>/Constant'
  //   Constant: '<S405>/Constant'
  //   RelationalOperator: '<S404>/Compare'
  //   RelationalOperator: '<S405>/Compare'

  if ((state_System == SYS_NORMAL) && (CONSTANT_DATA->DUMP_VALVE_FUNCTION !=
       NON_FUNCTIONAL)) {
    if (!MX_Gateway_DWork.Dump_Valve_MODE) {
      // SystemReset for Chart: '<S406>/Dump_Valve'
      MX_Gateway_DWork.bitsForTID1.is_active_c10_MX_Gateway = 0U;
      MX_Gateway_DWork.bitsForTID1.is_c10_MX_Gateway =
        MX_Gate_IN_NO_ACTIVE_CHILD_lqez;
      rtb_icmd_DumpValve = 0U;

      // SystemReset for Atomic SubSystem: '<S406>/hc_pair_control'
      MX_output_pair_ClosedLoop_Reset(&MX_Gateway_B.hs_cmd_cnig,
        &MX_Gateway_B.ls_cmd_fvfb, &MX_Gateway_B.state_Output_au4i,
        &MX_Gateway_B.hc_pair_control_mjt1,
        &MX_Gateway_DWork.hc_pair_control_mjt1);

      // End of SystemReset for SubSystem: '<S406>/hc_pair_control'
      MX_Gateway_DWork.Dump_Valve_MODE = true;
    }

    // RelationalOperator: '<S407>/Compare' incorporates:
    //   Constant: '<S407>/Constant'

    rtb_Compare_phgj = (aux_Flow != ((uint8_T)2U));

    // Chart: '<S406>/Dump_Valve'
    // Gateway: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve
    // During: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve
    if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c10_MX_Gateway == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve
      MX_Gateway_DWork.bitsForTID1.is_active_c10_MX_Gateway = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve 
      // Transition: '<S408>:21'
      MX_Gateway_DWork.bitsForTID1.is_c10_MX_Gateway = MX_Gateway_IN_Off_fwuc;

      // Entry 'Off': '<S408>:2'
      rtb_icmd_DumpValve = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
    } else if (MX_Gateway_DWork.bitsForTID1.is_c10_MX_Gateway ==
               MX_Gateway_IN_Off_fwuc) {
      rtb_icmd_DumpValve = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);

      // During 'Off': '<S408>:2'
      if (aux_Flow == AUX_FLOW_MEDIUM) {
        // Transition: '<S408>:20'
        MX_Gateway_DWork.bitsForTID1.is_c10_MX_Gateway = MX_Gateway_IN_On_m33g;

        // Entry 'On': '<S408>:9'
        rtb_icmd_DumpValve = CONSTANT_DATA->DUMP_VALVE_ON_CURRENT;
      }
    } else {
      rtb_icmd_DumpValve = CONSTANT_DATA->DUMP_VALVE_ON_CURRENT;

      // During 'On': '<S408>:9'
      if (aux_Flow != AUX_FLOW_MEDIUM) {
        // Transition: '<S408>:18'
        MX_Gateway_DWork.bitsForTID1.is_c10_MX_Gateway = MX_Gateway_IN_Off_fwuc;

        // Entry 'Off': '<S408>:2'
        rtb_icmd_DumpValve = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
      }
    }

    // End of Chart: '<S406>/Dump_Valve'

    // Outputs for Atomic SubSystem: '<S406>/hc_pair_control'
    MX_Gatew_output_pair_ClosedLoop(rtb_icmd_DumpValve, rtb_Compare_phgj,
      afbk_DumpValve, ifbk_DumpValve, MX_Gateway_B.RateTransition31_aank,
      state_Engine, MX_Gateway_B.RateTransition28_o4gy, ain_PrecisionReference,
      &MX_Gateway_B.hs_cmd_cnig, &MX_Gateway_B.ls_cmd_fvfb,
      &MX_Gateway_B.error_cybc, &calc_ifbk_DumpValve,
      &MX_Gateway_B.state_Output_au4i, &MX_Gateway_B.hc_pair_control_mjt1,
      &MX_Gateway_DWork.hc_pair_control_mjt1,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->DUMP_VALVE_KP, CONSTANT_DATA->DUMP_VALVE_KI,
      CONSTANT_DATA->DUMP_VALVE_OVERCURRENT,
      CONSTANT_DATA->DUMP_VALVE_NON_ZERO_DUTY,
      CONSTANT_DATA->DUMP_VALVE_NON_ZERO_CURRENT,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_SHORT_TO_BATTERY, NON_FUNCTIONAL,
      CONSTANT_DATA->DUMP_VALVE_AFBK_GAIN, CONSTANT_DATA->DUMP_VALVE_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S406>/hc_pair_control'

    // SignalConversion: '<S406>/OutportBufferForerrorCC_DumpValve'
    errorCC_DumpValve = MX_Gateway_B.error_cybc;

    // SignalConversion: '<S406>/OutportBufferForhs_DumpValve'
    hs_DumpValve = MX_Gateway_B.hs_cmd_cnig;

    // SignalConversion: '<S406>/OutportBufferForls_DumpValve'
    ls_DumpValve = MX_Gateway_B.ls_cmd_fvfb;

    // SignalConversion: '<S406>/OutportBufferForstate_DumpValve'
    state_DumpValve = MX_Gateway_B.state_Output_au4i;
  } else {
    if (MX_Gateway_DWork.Dump_Valve_MODE) {
      // Disable for Atomic SubSystem: '<S406>/hc_pair_control'
      output_pair_ClosedLoop_Disable(&MX_Gateway_B.error_cybc,
        &MX_Gateway_B.hc_pair_control_mjt1,
        &MX_Gateway_DWork.hc_pair_control_mjt1);

      // End of Disable for SubSystem: '<S406>/hc_pair_control'

      // Disable for Outport: '<S406>/state_DumpValve'
      state_DumpValve = ((uint8_T)0U);

      // Disable for Outport: '<S406>/hs_DumpValve'
      hs_DumpValve = ((uint16_T)0U);

      // Disable for Outport: '<S406>/ls_DumpValve'
      ls_DumpValve = false;

      // Disable for Outport: '<S406>/errorCC_DumpValve'
      errorCC_DumpValve = 0;

      // Disable for Outport: '<S406>/calc_ifbk_DumpValve'
      calc_ifbk_DumpValve = ((uint16_T)0U);
      MX_Gateway_DWork.Dump_Valve_MODE = false;
    }
  }

  // End of Logic: '<S306>/Logical Operator'
  // End of Outputs for SubSystem: '<S306>/Dump_Valve'
}

// Function for Chart: '<S427>/RelaySolenoid'
static void MX_Gateway_FuelTiming(void)
{
  // Graphical Function 'FuelTiming': '<S431>:4'
  // Transition: '<S431>:5'
  if ((MX_Gateway_B.time_Pull != UNLIMITED) &&
      ((CONSTANT_DATA->FUEL_PRIMARY_ON_SECONDARY_FAILURE == NON_FUNCTIONAL) ||
       (error_FuelSec == NORMAL))) {
    // Transition: '<S431>:6'
    // Transition: '<S431>:8'
    MX_Gateway_DWork.outputTimer = (uint16_T)(int32_T)((int32_T)
      MX_Gateway_DWork.outputTimer + 1);

    // Transition: '<S431>:9'
  } else {
    // Transition: '<S431>:7'
  }
}

// System initialize for atomic system: '<S307>/Fuel_Primary_Relay'
void MX_Gate_Fuel_Primary_Relay_Init(void)
{
  // SystemInitialize for Chart: '<S427>/RelaySolenoid'
  MX_Gateway_DWork.bitsForTID1.is_active_c62_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_ei1u;
  MX_Gateway_DWork.outputTimer = 0U;
  dout_FuelPri = false;

  // SystemInitialize for Enabled SubSystem: '<S427>/relay_oc'
  MX_Gateway_relay_oc_Init(&state_FuelPriOutput, &state_FuelPriRelay,
    &MX_Gateway_B.relay_oc, &MX_Gateway_DWork.relay_oc);

  // End of SystemInitialize for SubSystem: '<S427>/relay_oc'
}

// Output and update for atomic system: '<S307>/Fuel_Primary_Relay'
void MX_Gateway_Fuel_Primary_Relay(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;

  // SignalConversion: '<S427>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S427>/FunctionState'
  //   Constant: '<S429>/Constant'
  //   Constant: '<S430>/Constant'
  //   Logic: '<S427>/Logical Operator'
  //   RelationalOperator: '<S429>/Compare'
  //   RelationalOperator: '<S430>/Compare'

  rtb_HiddenBuf_InsertedFor_relay =
    ((CONSTANT_DATA->FUEL_PRIMARY_FEEDBACK_FUNCTION != NON_FUNCTIONAL) &&
     (MX_Gateway_B.RateTransition34_jbuw != OORL));

  // Lookup: '<S427>/PullTime1'
  //
  //  About '<S427>/PullTime1':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Round Mode: Nearest
  //  Lookup Method: Nearest
  //
  //  XData is inlined and evenly spaced, so the algorithm only needs
  //  the value of the first element, the last element, and the spacing.
  //  For efficiency, XData is excluded from the generated code.
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;

    // Find the location of current input value in the data table.
    //
    //  Based on the data type of the input, it is impossible for the
    //  search value to be less than the smallest point in the table.

    if (MX_Gateway_B.RateTransition40 >= 336U ) {
      // Greater than or equal to the largest point in the table.
      iLeft = 42U;
    } else {
      // The table is inlined with even spacing 2^3.
      //  The index is found by a 3 bit shift right.
      iLeft = (uint32_T)( MX_Gateway_B.RateTransition40 ) >> 3;

      // Adjust the index, if necessary, so that it always
      //  gives the data point nearest the current input value.
      //  It is necessary to round up iff the last bit shifted
      //  off was a one.

      iLeft += ((uint32_T)(( MX_Gateway_B.RateTransition40 ) & (0x00000004U) ))
        != 0U;
    }

    MX_Gateway_B.time_Pull = MXGTW_FUEL_PULL_TIME[iLeft];
  }

  // Chart: '<S427>/RelaySolenoid' incorporates:
  //   UnitDelay: '<S427>/Unit Delay1'
  //   UnitDelay: '<S427>/Unit Delay2'

  // Gateway: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
  // During: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
  if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c62_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
    MX_Gateway_DWork.bitsForTID1.is_active_c62_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
    // Transition: '<S431>:10'
    MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway = MX_Gateway_IN_INACTIVE_atau;

    // Entry 'INACTIVE': '<S431>:1'
    dout_FuelPri = ((int32_T)INACTIVE != 0);
  } else {
    switch (MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway) {
     case MX_Gateway_IN_ACTIVE_nevi:
      // During 'ACTIVE': '<S431>:2'
      if ((MX_Gateway_DWork.outputTimer >= MX_Gateway_B.time_Pull) ||
          (!((state_FuelPriOutput == NORMAL) || (state_FuelPriOutput == FAILURE)))
          || (state_FuelPriRelay != NORMAL)) {
        // Transition: '<S431>:14'
        MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway =
          MX_Gateway_IN_INACTIVE_OFF;

        // Entry 'INACTIVE_OFF': '<S431>:3'
        dout_FuelPri = ((int32_T)INACTIVE != 0);
      } else if (state_Engine == ENGINE_NOT_RUNNING) {
        // Transition: '<S431>:15'
        MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway =
          MX_Gateway_IN_INACTIVE_atau;

        // Entry 'INACTIVE': '<S431>:1'
        dout_FuelPri = ((int32_T)INACTIVE != 0);
      } else {
        MX_Gateway_FuelTiming();
      }
      break;

     case MX_Gateway_IN_INACTIVE_atau:
      // During 'INACTIVE': '<S431>:1'
      if ((CONSTANT_DATA->FUEL_PRIMARY_FUNCTION != NON_FUNCTIONAL) &&
          (MX_Gateway_B.RateTransition41_mpbl == INACTIVE) && (state_Engine ==
           ENGINE_CRANKING) && ((state_FuelPriOutput == NORMAL) ||
           (state_FuelPriOutput == FAILURE)) && (state_FuelPriRelay == NORMAL))
      {
        // Transition: '<S431>:13'
        MX_Gateway_DWork.outputTimer = 0U;
        MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway =
          MX_Gateway_IN_ACTIVE_nevi;

        // Entry 'ACTIVE': '<S431>:2'
        dout_FuelPri = ((int32_T)ACTIVE != 0);
      }
      break;

     default:
      // During 'INACTIVE_OFF': '<S431>:3'
      if (state_Engine == ENGINE_NOT_RUNNING) {
        // Transition: '<S431>:11'
        MX_Gateway_DWork.bitsForTID1.is_c62_MX_Gateway =
          MX_Gateway_IN_INACTIVE_atau;

        // Entry 'INACTIVE': '<S431>:1'
        dout_FuelPri = ((int32_T)INACTIVE != 0);
      }
      break;
    }
  }

  // End of Chart: '<S427>/RelaySolenoid'

  // Outputs for Enabled SubSystem: '<S427>/relay_oc'
  MX_Gateway_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_FuelPri,
                      dfbk_FuelPriOutput, din_FuelPriRelay, &state_FuelPriOutput,
                      &state_FuelPriRelay, &MX_Gateway_B.relay_oc,
                      &MX_Gateway_DWork.relay_oc,
                      CONSTANT_DATA->FUEL_PRIMARY_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->FUEL_PRIMARY_DEBOUNCE_ERROR_ON,
                      CONSTANT_DATA->FUEL_PRIMARY_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S427>/relay_oc'
}

// Function for Chart: '<S437>/Fault monitor'
static uint8_T MX_Gateway_out_state(boolean_T rtu_cmd, boolean_T rtu_fbk,
  rtDW_dout_chk_MX_Gateway *localDW, uint16_T rtp_ERR_OFF_DB_CNT, uint16_T
  rtp_ERR_ON_DB_CNT)
{
  uint8_T y;

  // Outputs for Enabled SubSystem: '<S428>/dout_chk' incorporates:
  //   EnablePort: '<S437>/Enable'

  // Chart: '<S437>/Fault monitor'
  // Truth Table Function 'out_state': '<S438>:5'
  // Condition '#1': '<S438>:104'
  //  command, off feedback, on
  // Condition '#2': '<S438>:106'
  //  command, on feedback, off
  if ((!rtu_cmd) && rtu_fbk) {
    // Decision 'D1': '<S438>:108'
    // Action '1': '<S438>:110'
    //  'E_on':Error On
    y = 2U;
    localDW->db_limit = rtp_ERR_ON_DB_CNT;
  } else if (rtu_cmd && (!rtu_fbk)) {
    // Decision 'D2': '<S438>:114'
    // Action '2': '<S438>:116'
    //  'E_off':Error Off
    y = 3U;
    localDW->db_limit = rtp_ERR_OFF_DB_CNT;
  } else {
    // Decision 'D3': '<S438>:120'
    //  Default
    // Action '3': '<S438>:122'
    //  'ok':default
    y = 8U;
  }

  // End of Chart: '<S437>/Fault monitor'
  // End of Outputs for SubSystem: '<S428>/dout_chk'
  return y;
}

//
//  System initialize for enable system:
//     '<S428>/dout_chk'
//     '<S313>/dout_chk'
//     '<S314>/dout_chk'
//     '<S316>/dout_chk'

void MX_Gateway_dout_chk_Init(uint8_T *rty_state, rtB_dout_chk_MX_Gateway
  *localB, rtDW_dout_chk_MX_Gateway *localDW)
{
  // SystemInitialize for Chart: '<S437>/Fault monitor'
  localDW->bitsForTID1.is_diagnostics = MX_Gate_IN_NO_ACTIVE_CHILD_c5m3;
  localDW->bitsForTID1.is_active_c60_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_state = 0U;
  localDW->db_limit = 20U;
  localB->state = 0U;

  // SystemInitialize for Outport: '<S437>/state'
  *rty_state = ((uint8_T)8U);
}

//
//  System reset for enable system:
//     '<S428>/dout_chk'
//     '<S313>/dout_chk'
//     '<S314>/dout_chk'
//     '<S316>/dout_chk'

void MX_Gateway_dout_chk_Reset(rtB_dout_chk_MX_Gateway *localB,
  rtDW_dout_chk_MX_Gateway *localDW)
{
  // SystemReset for Chart: '<S437>/Fault monitor'
  localDW->bitsForTID1.is_diagnostics = MX_Gate_IN_NO_ACTIVE_CHILD_c5m3;
  localDW->bitsForTID1.is_active_c60_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_state = 0U;
  localDW->db_limit = 20U;
  localB->state = 0U;
}

//
//  Disable for enable system:
//     '<S428>/dout_chk'
//     '<S313>/dout_chk'
//     '<S314>/dout_chk'
//     '<S316>/dout_chk'

void MX_Gateway_dout_chk_Disable(uint8_T *rty_state, rtDW_dout_chk_MX_Gateway
  *localDW)
{
  // Outputs for Enabled SubSystem: '<S428>/dout_chk' incorporates:
  //   EnablePort: '<S437>/Enable'

  // Disable for Outport: '<S437>/state'
  *rty_state = ((uint8_T)8U);

  // End of Outputs for SubSystem: '<S428>/dout_chk'
  localDW->dout_chk_MODE = false;
}

//
//  Output and update for enable system:
//     '<S428>/dout_chk'
//     '<S313>/dout_chk'
//     '<S314>/dout_chk'
//     '<S316>/dout_chk'

void MX_Gateway_dout_chk(boolean_T rtu_Enable, boolean_T rtu_cmd, boolean_T
  rtu_fbk, uint8_T *rty_state, rtB_dout_chk_MX_Gateway *localB,
  rtDW_dout_chk_MX_Gateway *localDW, uint16_T rtp_ERR_OFF_DB_CNT, uint16_T
  rtp_ERR_ON_DB_CNT)
{
  uint8_T os;

  // Outputs for Enabled SubSystem: '<S428>/dout_chk' incorporates:
  //   EnablePort: '<S437>/Enable'

  if (rtu_Enable) {
    if (!localDW->dout_chk_MODE) {
      MX_Gateway_dout_chk_Reset(localB, localDW);
      localDW->dout_chk_MODE = true;
    }

    // Chart: '<S437>/Fault monitor'
    // Gateway: dout_chk/Fault monitor
    // During: dout_chk/Fault monitor
    if ((uint32_T)localDW->bitsForTID1.is_active_c60_MX_Library == 0U) {
      // Entry: dout_chk/Fault monitor
      localDW->bitsForTID1.is_active_c60_MX_Library = 1U;

      // Entry Internal: dout_chk/Fault monitor
      // Entry 'diagnostics': '<S438>:4'
      localDW->db_cnt = 0U;
      localDW->db_state = 0U;
      localDW->db_limit = 20U;

      // Entry Internal 'diagnostics': '<S438>:4'
      // Transition: '<S438>:6'
      localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_Ok;

      // Entry 'Ok': '<S438>:1'
      localB->state = 8U;
    } else {
      // During 'diagnostics': '<S438>:4'
      os = MX_Gateway_out_state(rtu_cmd, rtu_fbk, localDW, rtp_ERR_OFF_DB_CNT,
        rtp_ERR_ON_DB_CNT);
      switch (localDW->bitsForTID1.is_diagnostics) {
       case MX_Gateway_IN_Ok:
        // During 'Ok': '<S438>:1'
        if ((int32_T)os != 8) {
          // Transition: '<S438>:10'
          localDW->db_state = os;
          localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_debounce_cuwh;
        }
        break;

       case MX_Gateway_IN_debounce_cuwh:
        // During 'debounce': '<S438>:3'
        if ((int32_T)localDW->db_cnt == 0) {
          // Transition: '<S438>:9'
          localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_Ok;

          // Entry 'Ok': '<S438>:1'
          localB->state = 8U;
        } else if (localDW->db_cnt >= localDW->db_limit) {
          // Transition: '<S438>:7'
          localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_error_knwh;

          // Entry 'error': '<S438>:2'
          localB->state = os;
        } else {
          // Transition: '<S438>:8'
          if (localDW->db_state == os) {
            // Transition: '<S438>:12'
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_debounce_cuwh;
          } else {
            // Transition: '<S438>:13'
            if ((int32_T)os == 8) {
              // Transition: '<S438>:14'
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt - 1);
              localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_debounce_cuwh;
            } else {
              // Transition: '<S438>:11'
              localDW->db_cnt = 1U;
              localDW->db_state = os;
              localDW->bitsForTID1.is_diagnostics = MX_Gateway_IN_debounce_cuwh;
            }
          }
        }
        break;

       default:
        // During 'error': '<S438>:2'
        break;
      }
    }

    // End of Chart: '<S437>/Fault monitor'

    // SignalConversion: '<S437>/OutportBufferForstate'
    *rty_state = localB->state;
  } else {
    if (localDW->dout_chk_MODE) {
      MX_Gateway_dout_chk_Disable(rty_state, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S428>/dout_chk'
}

// System initialize for atomic system: '<S307>/HVAC_Relay'
void MX_Gateway_HVAC_Relay_Init(void)
{
  // SystemInitialize for Chart: '<S428>/RelaySolenoid'
  MX_Gateway_DWork.bitsForTID1.is_active_c36_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_aog3;
  MX_Gateway_DWork.debounceCount_foat = 0U;
  dout_HVACOutput = false;

  // SystemInitialize for Enabled SubSystem: '<S428>/dout_chk'
  MX_Gateway_dout_chk_Init(&state_HVACOutput, &MX_Gateway_B.dout_chk,
    &MX_Gateway_DWork.dout_chk);

  // End of SystemInitialize for SubSystem: '<S428>/dout_chk'
}

// Output and update for atomic system: '<S307>/HVAC_Relay'
void MX_Gateway_HVAC_Relay(void)
{
  boolean_T rtb_LogicalOperator1_i4tt;

  // Logic: '<S428>/Logical Operator1' incorporates:
  //   Constant: '<S428>/FunctionState1'
  //   Constant: '<S434>/Constant'
  //   Constant: '<S435>/Constant'
  //   RelationalOperator: '<S434>/Compare'
  //   RelationalOperator: '<S435>/Compare'

  rtb_LogicalOperator1_i4tt = ((CONSTANT_DATA->HVAC_RELAY_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (MX_Gateway_B.RateTransition34_jbuw != OORL));

  // Chart: '<S428>/RelaySolenoid' incorporates:
  //   UnitDelay: '<S428>/Unit Delay3'

  // Gateway: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid
  // During: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid
  if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c36_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid
    MX_Gateway_DWork.bitsForTID1.is_active_c36_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid 
    // Transition: '<S436>:10'
    MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway =
      MX_Ga_IN_STARTUP_ERROR_ON_CHECK;

    // Entry 'STARTUP_ERROR_ON_CHECK': '<S436>:59'
    dout_HVACOutput = ((int32_T)INACTIVE != 0);
    MX_Gateway_DWork.debounceCount_foat = 0U;
  } else {
    switch (MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway) {
     case MX_Gateway_IN_ACTIVE_gz5o:
      // During 'ACTIVE': '<S436>:2'
      if ((state_Engine == ENGINE_CRANKING) || (state_HVACOutput != NORMAL) ||
          (state_System != SYS_NORMAL)) {
        // Transition: '<S436>:15'
        MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway =
          MX_Gateway_IN_INACTIVE_phj4;

        // Entry 'INACTIVE': '<S436>:1'
        dout_HVACOutput = ((int32_T)INACTIVE != 0);
      }
      break;

     case MX_Gateway_IN_INACTIVE_phj4:
      // During 'INACTIVE': '<S436>:1'
      if ((CONSTANT_DATA->HVAC_RELAY_FUNCTION != NON_FUNCTIONAL) &&
          ((state_Engine != ENGINE_CRANKING) || (state_Engine == ENGINE_RUNNING))
          && (state_HVACOutput == NORMAL) && (state_System == SYS_NORMAL)) {
        // Transition: '<S436>:13'
        MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway =
          MX_Gateway_IN_ACTIVE_gz5o;

        // Entry 'ACTIVE': '<S436>:2'
        dout_HVACOutput = ((int32_T)ACTIVE != 0);
      }
      break;

     default:
      // During 'STARTUP_ERROR_ON_CHECK': '<S436>:59'
      if ((int32_T)MX_Gateway_DWork.debounceCount_foat >= (int32_T)((int32_T)
           CONSTANT_DATA->HVAC_RELAY_DEBOUNCE_ERROR_ON + 100)) {
        // Transition: '<S436>:60'
        MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway =
          MX_Gateway_IN_INACTIVE_phj4;

        // Entry 'INACTIVE': '<S436>:1'
        dout_HVACOutput = ((int32_T)INACTIVE != 0);
      } else if ((CONSTANT_DATA->HVAC_RELAY_FUNCTION != NON_FUNCTIONAL) &&
                 (state_Engine == ENGINE_RUNNING) && (state_HVACOutput == NORMAL)
                 && (state_System == SYS_NORMAL)) {
        // Transition: '<S436>:66'
        MX_Gateway_DWork.bitsForTID1.is_c36_MX_Gateway =
          MX_Gateway_IN_ACTIVE_gz5o;

        // Entry 'ACTIVE': '<S436>:2'
        dout_HVACOutput = ((int32_T)ACTIVE != 0);
      } else {
        MX_Gateway_DWork.debounceCount_foat = (uint16_T)(int32_T)((int32_T)
          MX_Gateway_DWork.debounceCount_foat + 1);
      }
      break;
    }
  }

  // End of Chart: '<S428>/RelaySolenoid'

  // Outputs for Enabled SubSystem: '<S428>/dout_chk'
  MX_Gateway_dout_chk(rtb_LogicalOperator1_i4tt, dout_HVACOutput,
                      dfbk_HVACOutput, &state_HVACOutput, &MX_Gateway_B.dout_chk,
                      &MX_Gateway_DWork.dout_chk,
                      CONSTANT_DATA->HVAC_RELAY_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->HVAC_RELAY_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S428>/dout_chk'
}

// System initialize for atomic system: '<S26>/FuelPri_HVAC'
void MX_Gateway_FuelPri_HVAC_Init(void)
{
  // SystemInitialize for Atomic SubSystem: '<S307>/Fuel_Primary_Relay'
  MX_Gate_Fuel_Primary_Relay_Init();

  // End of SystemInitialize for SubSystem: '<S307>/Fuel_Primary_Relay'

  // SystemInitialize for Atomic SubSystem: '<S307>/HVAC_Relay'
  MX_Gateway_HVAC_Relay_Init();

  // End of SystemInitialize for SubSystem: '<S307>/HVAC_Relay'
}

// Output and update for atomic system: '<S26>/FuelPri_HVAC'
void MX_Gateway_FuelPri_HVAC(void)
{
  // Outputs for Atomic SubSystem: '<S307>/Fuel_Primary_Relay'
  MX_Gateway_Fuel_Primary_Relay();

  // End of Outputs for SubSystem: '<S307>/Fuel_Primary_Relay'

  // Outputs for Atomic SubSystem: '<S307>/HVAC_Relay'
  MX_Gateway_HVAC_Relay();

  // End of Outputs for SubSystem: '<S307>/HVAC_Relay'
}

// System initialize for atomic system: '<S26>/FuelSec_ECUHold'
void MX_Gateway_FuelSec_ECUHold_Init(void)
{
  // SystemInitialize for Chart: '<S308>/Solenoid'
  MX_Gateway_DWork.bitsForTID1.is_ECU_HOLD = MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n = MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gateway_DWork.bitsForTID1.is_FUEL_HOLD = MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei = MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gateway_DWork.bitsForTID1.is_active_c37_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gateway_DWork.debounceCount_bjgo = 0U;
  duty_FuelSec = 0U;
  state_FuelSec = 0U;
  state_ECUHold = 0U;

  // SystemInitialize for Enabled SubSystem: '<S308>/hc_hsd'
  MX_Gateway_hc_hsd_Init(&error_FuelSec, &MX_Gateway_B.hc_hsd,
    &MX_Gateway_DWork.hc_hsd);

  // End of SystemInitialize for SubSystem: '<S308>/hc_hsd'
}

// Output and update for atomic system: '<S26>/FuelSec_ECUHold'
void MX_Gateway_FuelSec_ECUHold(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_hc_hs;
  uint16_T rtb_afbkGain_FuelSec;

  // Gain: '<S308>/Gain'
  rtb_afbkGain_FuelSec = (uint16_T)(uint32_T)((uint32_T)
    CONSTANT_DATA->FUEL_SECONDARY_AFBK_GAIN * (uint32_T)afbk_FuelSec);

  // SignalConversion: '<S308>/HiddenBuf_InsertedFor_hc_hsd_at_inport_3' incorporates:
  //   Constant: '<S308>/FunctionState'
  //   Constant: '<S308>/FunctionState1'
  //   Constant: '<S439>/Constant'
  //   Constant: '<S440>/Constant'
  //   Constant: '<S441>/Constant'
  //   Logic: '<S308>/Logical Operator'
  //   Logic: '<S308>/Logical Operator1'
  //   RelationalOperator: '<S439>/Compare'
  //   RelationalOperator: '<S440>/Compare'
  //   RelationalOperator: '<S441>/Compare'

  rtb_HiddenBuf_InsertedFor_hc_hs =
    (((CONSTANT_DATA->FUEL_SECONDARY_FEEDBACK_FUNCTION != NON_FUNCTIONAL) ||
      (CONSTANT_DATA->ECU_FUNCTION != NON_FUNCTIONAL)) &&
     (MX_Gateway_B.RateTransition42 != OORL));

  // Chart: '<S308>/Solenoid' incorporates:
  //   UnitDelay: '<S308>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
  // During: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
  if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c37_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
    MX_Gateway_DWork.bitsForTID1.is_active_c37_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
    // Transition: '<S442>:13'
    MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway =
      MX_Gatew_IN_NON_FUNCTIONAL_hp4p;

    // Entry 'NON_FUNCTIONAL': '<S442>:4'
    duty_FuelSec = 0U;
    state_FuelSec = INACTIVE;
    state_ECUHold = INACTIVE;
  } else {
    switch (MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway) {
     case MX_Gateway_IN_ECU_HOLD:
      // During 'ECU_HOLD': '<S442>:38'
      if ((state_System != SYS_NORMAL) || (state_Engine == SHUTDOWN)) {
        // Transition: '<S442>:49'
        // Exit Internal 'ECU_HOLD': '<S442>:38'
        MX_Gateway_DWork.bitsForTID1.is_ECU_HOLD =
          MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;

        // Exit Internal 'NORMAL': '<S442>:77'
        MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n =
          MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
        MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway =
          MX_Gatew_IN_NON_FUNCTIONAL_hp4p;

        // Entry 'NON_FUNCTIONAL': '<S442>:4'
        duty_FuelSec = 0U;
        state_FuelSec = INACTIVE;
        state_ECUHold = INACTIVE;
      } else if (MX_Gateway_DWork.bitsForTID1.is_ECU_HOLD ==
                 MX_Gateway_IN_ERROR_oymp) {
        duty_FuelSec = 0U;

        // During 'ERROR': '<S442>:83'
        if (error_FuelSec == NORMAL) {
          // Transition: '<S442>:85'
          MX_Gateway_DWork.bitsForTID1.is_ECU_HOLD = MX_Gateway_IN_NORMAL_chyf;

          // Entry Internal 'NORMAL': '<S442>:77'
          // Transition: '<S442>:61'
          MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n =
            MX_Gateway_IN_CHECK_ERROR_ON;

          // Entry 'CHECK_ERROR_ON': '<S442>:60'
          duty_FuelSec = 0U;
          state_ECUHold = INACTIVE;
          MX_Gateway_DWork.debounceCount_bjgo = 0U;
        }
      } else {
        // During 'NORMAL': '<S442>:77'
        if (error_FuelSec != NORMAL) {
          // Transition: '<S442>:84'
          // Exit Internal 'NORMAL': '<S442>:77'
          MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n =
            MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
          MX_Gateway_DWork.bitsForTID1.is_ECU_HOLD = MX_Gateway_IN_ERROR_oymp;

          // Entry 'ERROR': '<S442>:83'
          duty_FuelSec = 0U;
          state_ECUHold = error_FuelSec;
        } else if (MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n ==
                   MX_Gateway_IN_ACTIVE_e31e) {
          duty_FuelSec = FULL_ON;

          // During 'ACTIVE': '<S442>:62'
          if ((MX_Gateway_B.UnitDelay9_hk24 != NORMAL) ||
              (MX_Gateway_B.UnitDelay10_kkg2 != NORMAL) || (state_Engine ==
               ENGINE_OFF)) {
            // Transition: '<S442>:89'
            MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n =
              MX_Gateway_IN_CHECK_ERROR_ON;

            // Entry 'CHECK_ERROR_ON': '<S442>:60'
            duty_FuelSec = 0U;
            state_ECUHold = INACTIVE;
            MX_Gateway_DWork.debounceCount_bjgo = 0U;
          }
        } else {
          duty_FuelSec = 0U;

          // During 'CHECK_ERROR_ON': '<S442>:60'
          if ((MX_Gateway_DWork.debounceCount_bjgo >=
               CONSTANT_DATA->ECU_HOLD_DEBOUNCE_ERROR_ON) &&
              (MX_Gateway_B.UnitDelay9_hk24 == NORMAL) &&
              (MX_Gateway_B.UnitDelay10_kkg2 == NORMAL) && ((din_StarterRelay ==
                (int32_T)INACTIVE) || (state_Engine == ENGINE_CRANKING)) &&
              (state_Engine != ENGINE_OFF)) {
            // Transition: '<S442>:63'
            MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n =
              MX_Gateway_IN_ACTIVE_e31e;

            // Entry 'ACTIVE': '<S442>:62'
            duty_FuelSec = FULL_ON;
            state_ECUHold = ACTIVE;
          } else {
            MX_Gateway_DWork.debounceCount_bjgo = (uint16_T)(int32_T)((int32_T)
              MX_Gateway_DWork.debounceCount_bjgo + 1);
          }
        }
      }
      break;

     case MX_Gateway_IN_FUEL_HOLD:
      // During 'FUEL_HOLD': '<S442>:36'
      if (state_System != SYS_NORMAL) {
        // Transition: '<S442>:10'
        // Exit Internal 'FUEL_HOLD': '<S442>:36'
        // Exit Internal 'ACTIVE': '<S442>:3'
        MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei =
          MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
        MX_Gateway_DWork.bitsForTID1.is_FUEL_HOLD =
          MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
        MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway =
          MX_Gatew_IN_NON_FUNCTIONAL_hp4p;

        // Entry 'NON_FUNCTIONAL': '<S442>:4'
        duty_FuelSec = 0U;
        state_FuelSec = INACTIVE;
        state_ECUHold = INACTIVE;
      } else if (MX_Gateway_DWork.bitsForTID1.is_FUEL_HOLD ==
                 MX_Gateway_IN_ACTIVE_e31e) {
        // During 'ACTIVE': '<S442>:3'
        if (error_FuelSec != NORMAL) {
          // Transition: '<S442>:11'
          // Exit Internal 'ACTIVE': '<S442>:3'
          MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei =
            MX_Gate_IN_NO_ACTIVE_CHILD_fnr0;
          MX_Gateway_DWork.bitsForTID1.is_FUEL_HOLD = MX_Gateway_IN_ERROR_oymps;

          // Entry 'ERROR': '<S442>:5'
          duty_FuelSec = 0U;
          state_FuelSec = error_FuelSec;
        } else if (MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei ==
                   MX_Gateway_IN_ACTIVE_e31e) {
          duty_FuelSec = FULL_ON;

          // During 'ACTIVE': '<S442>:1'
          if ((state_Engine == SHUTDOWN) || (state_Engine == ENGINE_OFF)) {
            // Transition: '<S442>:8'
            MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei =
              MX_Gateway_IN_INACTIVE_nope;

            // Entry 'INACTIVE': '<S442>:2'
            duty_FuelSec = 0U;
            state_FuelSec = INACTIVE;
          }
        } else {
          duty_FuelSec = 0U;

          // During 'INACTIVE': '<S442>:2'
          if (state_Engine == ENGINE_CRANKING) {
            // Transition: '<S442>:7'
            MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei =
              MX_Gateway_IN_ACTIVE_e31e;

            // Entry 'ACTIVE': '<S442>:1'
            duty_FuelSec = FULL_ON;
            state_FuelSec = ACTIVE;
          }
        }
      } else {
        duty_FuelSec = 0U;

        // During 'ERROR': '<S442>:5'
        if (error_FuelSec == NORMAL) {
          // Transition: '<S442>:12'
          MX_Gateway_DWork.bitsForTID1.is_FUEL_HOLD = MX_Gateway_IN_ACTIVE_e31e;

          // Entry Internal 'ACTIVE': '<S442>:3'
          // Transition: '<S442>:6'
          MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei =
            MX_Gateway_IN_INACTIVE_nope;

          // Entry 'INACTIVE': '<S442>:2'
          duty_FuelSec = 0U;
          state_FuelSec = INACTIVE;
        }
      }
      break;

     default:
      duty_FuelSec = 0U;

      // During 'NON_FUNCTIONAL': '<S442>:4'
      if ((CONSTANT_DATA->ECU_FUNCTION != NON_FUNCTIONAL) && (state_System ==
           SYS_NORMAL) && (state_Engine != SHUTDOWN)) {
        // Transition: '<S442>:48'
        MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway = MX_Gateway_IN_ECU_HOLD;

        // Entry Internal 'ECU_HOLD': '<S442>:38'
        // Transition: '<S442>:86'
        MX_Gateway_DWork.bitsForTID1.is_ECU_HOLD = MX_Gateway_IN_NORMAL_chyf;

        // Entry Internal 'NORMAL': '<S442>:77'
        // Transition: '<S442>:61'
        MX_Gateway_DWork.bitsForTID1.is_NORMAL_eo1n =
          MX_Gateway_IN_CHECK_ERROR_ON;

        // Entry 'CHECK_ERROR_ON': '<S442>:60'
        duty_FuelSec = 0U;
        state_ECUHold = INACTIVE;
        MX_Gateway_DWork.debounceCount_bjgo = 0U;
      } else {
        if ((CONSTANT_DATA->FUEL_SECONDARY_FUNCTION != NON_FUNCTIONAL) &&
            (state_System == SYS_NORMAL)) {
          // Transition: '<S442>:9'
          MX_Gateway_DWork.bitsForTID1.is_c37_MX_Gateway =
            MX_Gateway_IN_FUEL_HOLD;

          // Entry Internal 'FUEL_HOLD': '<S442>:36'
          // Transition: '<S442>:76'
          MX_Gateway_DWork.bitsForTID1.is_FUEL_HOLD = MX_Gateway_IN_ACTIVE_e31e;

          // Entry Internal 'ACTIVE': '<S442>:3'
          // Transition: '<S442>:6'
          MX_Gateway_DWork.bitsForTID1.is_ACTIVE_niei =
            MX_Gateway_IN_INACTIVE_nope;

          // Entry 'INACTIVE': '<S442>:2'
          duty_FuelSec = 0U;
          state_FuelSec = INACTIVE;
        }
      }
      break;
    }
  }

  // End of Chart: '<S308>/Solenoid'

  // Outputs for Enabled SubSystem: '<S308>/hc_hsd'
  MX_Gateway_hc_hsd(rtb_HiddenBuf_InsertedFor_hc_hs, duty_FuelSec,
                    rtb_afbkGain_FuelSec, MX_Gateway_B.RateTransition7_fb0n,
                    &error_FuelSec, &MX_Gateway_B.hc_hsd,
                    &MX_Gateway_DWork.hc_hsd,
                    CONSTANT_DATA->FUEL_SECONDARY_DEBOUNCE_OPEN_CIRCUIT,
                    CONSTANT_DATA->FUEL_SECONDARY_DEBOUNCE_SHORT_TO_BATTERY,
                    CONSTANT_DATA->FUEL_SECONDARY_DEBOUNCE_SHORT_TO_GROUND);

  // End of Outputs for SubSystem: '<S308>/hc_hsd'
}

// System initialize for atomic system: '<S26>/Fuel_Resolution_Timer'
void MX_G_Fuel_Resolution_Timer_Init(void)
{
  // SystemInitialize for Chart: '<S309>/Timer'
  MX_Gateway_DWork.bitsForTID2.is_active_c58_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID2.is_c58_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_mh0r;
  MX_Gateway_DWork.resolutionTimer = 0U;
  timer_FuelResolution = 0U;
}

// Output and update for atomic system: '<S26>/Fuel_Resolution_Timer'
void MX_Gatewa_Fuel_Resolution_Timer(void)
{
  // Chart: '<S309>/Timer'
  // Gateway: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
  // During: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
  if ((uint32_T)MX_Gateway_DWork.bitsForTID2.is_active_c58_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
    MX_Gateway_DWork.bitsForTID2.is_active_c58_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
    // Transition: '<S445>:4'
    MX_Gateway_DWork.bitsForTID2.is_c58_MX_Gateway = MX_Gateway_IN_INACTIVE_c0o4;

    // Entry 'INACTIVE': '<S445>:2'
    timer_FuelResolution = INACTIVE;
  } else {
    switch (MX_Gateway_DWork.bitsForTID2.is_c58_MX_Gateway) {
     case MX_Gateway_IN_ACTIVE_g3bz:
      timer_FuelResolution = ACTIVE;

      // During 'ACTIVE': '<S445>:3'
      if ((int32_T)MX_Gateway_DWork.resolutionTimer <= 0) {
        // Transition: '<S445>:7'
        MX_Gateway_DWork.bitsForTID2.is_c58_MX_Gateway =
          MX_Gateway_IN_INACTIVE_c0o4;

        // Entry 'INACTIVE': '<S445>:2'
        timer_FuelResolution = INACTIVE;
      } else {
        MX_Gateway_DWork.resolutionTimer = (uint16_T)(int32_T)((int32_T)
          MX_Gateway_DWork.resolutionTimer - 1);
      }
      break;

     case MX_Gateway_IN_INACTIVE_c0o4:
      timer_FuelResolution = INACTIVE;

      // During 'INACTIVE': '<S445>:2'
      if ((CONSTANT_DATA->FUEL_PRIMARY_FUNCTION != NON_FUNCTIONAL) &&
          (MX_Gateway_B.dout_FuelPri_kx3h != (int32_T)INACTIVE)) {
        // Transition: '<S445>:5'
        MX_Gateway_DWork.bitsForTID2.is_c58_MX_Gateway =
          MX_Gateway_IN_INACTIVE_WAIT;

        // Entry 'INACTIVE_WAIT': '<S445>:1'
        MX_Gateway_DWork.resolutionTimer = CONSTANT_DATA->FUEL_RESOLUTION_TIMER;
      }
      break;

     default:
      // During 'INACTIVE_WAIT': '<S445>:1'
      if (MX_Gateway_B.dout_FuelPri_kx3h == (int32_T)INACTIVE) {
        // Transition: '<S445>:6'
        MX_Gateway_DWork.bitsForTID2.is_c58_MX_Gateway =
          MX_Gateway_IN_ACTIVE_g3bz;

        // Entry 'ACTIVE': '<S445>:3'
        timer_FuelResolution = ACTIVE;
      }
      break;
    }
  }

  // End of Chart: '<S309>/Timer'
}

// Function for Chart: '<S310>/GlowPlug'
static void MX_Gateway_PreheatTime(uint16_T temp)
{
  // Graphical Function 'PreheatTime': '<S449>:100'
  // Transition: '<S449>:163'
  //  Glow plug preheat time
  if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL1) {
    // Transition: '<S449>:165'
    // Transition: '<S449>:170'
    MX_Gateway_DWork.debounceCount_ivzl =
      CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL0;

    // Transition: '<S449>:169'
    // Transition: '<S449>:168'
    // Transition: '<S449>:175'
  } else {
    // Transition: '<S449>:164'
    if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL2) {
      // Transition: '<S449>:172'
      // Transition: '<S449>:171'
      MX_Gateway_DWork.debounceCount_ivzl =
        CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL1;

      // Transition: '<S449>:168'
      // Transition: '<S449>:175'
    } else {
      // Transition: '<S449>:167'
      if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL3) {
        // Transition: '<S449>:173'
        // Transition: '<S449>:174'
        MX_Gateway_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL2;

        // Transition: '<S449>:175'
      } else {
        // Transition: '<S449>:176'
        MX_Gateway_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL3;
      }
    }
  }

  // Transition: '<S449>:166'
}

// Function for Chart: '<S310>/GlowPlug'
static void MX_Gateway_AfterglowTime(uint16_T temp)
{
  // Graphical Function 'AfterglowTime': '<S449>:210'
  // Transition: '<S449>:222'
  //  Glow plug preheat time
  if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL1) {
    // Transition: '<S449>:223'
    // Transition: '<S449>:225'
    MX_Gateway_DWork.debounceCount_ivzl =
      CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL0;

    // Transition: '<S449>:234'
    // Transition: '<S449>:233'
    // Transition: '<S449>:232'
  } else {
    // Transition: '<S449>:224'
    if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL2) {
      // Transition: '<S449>:226'
      // Transition: '<S449>:228'
      MX_Gateway_DWork.debounceCount_ivzl =
        CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL1;

      // Transition: '<S449>:233'
      // Transition: '<S449>:232'
    } else {
      // Transition: '<S449>:227'
      if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL3) {
        // Transition: '<S449>:229'
        // Transition: '<S449>:231'
        MX_Gateway_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL2;

        // Transition: '<S449>:232'
      } else {
        // Transition: '<S449>:230'
        MX_Gateway_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL3;
      }
    }
  }

  // Transition: '<S449>:235'
}

// Function for Chart: '<S310>/GlowPlug'
static void MX_Gateway_PreheatWaitTime(uint16_T temp)
{
  // Graphical Function 'PreheatWaitTime': '<S449>:183'
  // Transition: '<S449>:195'
  //  Glow plug preheat time
  if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL1) {
    // Transition: '<S449>:196'
    // Transition: '<S449>:198'
    MX_Gateway_DWork.debounceCount_ivzl =
      CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL0;

    // Transition: '<S449>:207'
    // Transition: '<S449>:206'
    // Transition: '<S449>:205'
  } else {
    // Transition: '<S449>:197'
    if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL2) {
      // Transition: '<S449>:199'
      // Transition: '<S449>:201'
      MX_Gateway_DWork.debounceCount_ivzl =
        CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL1;

      // Transition: '<S449>:206'
      // Transition: '<S449>:205'
    } else {
      // Transition: '<S449>:200'
      if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL3) {
        // Transition: '<S449>:202'
        // Transition: '<S449>:204'
        MX_Gateway_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL2;

        // Transition: '<S449>:205'
      } else {
        // Transition: '<S449>:203'
        MX_Gateway_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL3;
      }
    }
  }

  // Transition: '<S449>:208'
}

// System initialize for atomic system: '<S26>/GlowPlug'
void MX_Gateway_GlowPlug_Init(void)
{
  // InitializeConditions for UnitDelay: '<S310>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 = ((uint8_T)8U);

  // InitializeConditions for UnitDelay: '<S310>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_awti = ((uint8_T)8U);

  // SystemInitialize for Chart: '<S310>/GlowPlug'
  MX_Gateway_DWork.bitsForTID2.is_ECU = MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gateway_DWork.bitsForTID2.is_INACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gateway_DWork.bitsForTID2.is_PREHEAT = MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gateway_DWork.bitsForTID2.is_active_c38_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID2.is_c38_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gateway_DWork.debounceCount_ivzl = 0U;
  MX_Gateway_DWork.cycleCount = 0U;
  MX_Gateway_DWork.bitsForTID2.glowPlugAfterGlowDone = false;
  MX_Gateway_DWork.state_CrankTimerExpired = 0U;
  MX_Gateway_DWork.debounceCrank = 0U;
  dout_GlowPlug = false;
  count_GlowPlug = 0U;

  // SystemInitialize for Enabled SubSystem: '<S310>/relay_oc'
  MX_Gateway_relay_oc_Init(&state_GlowPlugOutput, &state_GlowPlugRelay,
    &MX_Gateway_B.relay_oc_dsbs, &MX_Gateway_DWork.relay_oc_dsbs);

  // End of SystemInitialize for SubSystem: '<S310>/relay_oc'
}

// Output and update for atomic system: '<S26>/GlowPlug'
void MX_Gateway_GlowPlug(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;
  uint16_T temp_Lowest;

  // Lookup: '<S310>/ECU_Glow_Time'
  //
  //  About '<S310>/ECU_Glow_Time':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Linear_Endpoint
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  LookUp_U16_U16_SAT( &(MX_Gateway_B.time_GlowPlug), (&(MXGTW_ECU_GLOW_TIME[0])),
                     MX_Gateway_B.RateTransition26_peze, (&(MXGTW_ECU_GLOW_TEMP
    [0])), 15U);

  // Switch: '<S310>/Switch' incorporates:
  //   Constant: '<S310>/FunctionState1'
  //   Constant: '<S448>/Constant'
  //   Logic: '<S310>/Logical Operator'
  //   RelationalOperator: '<S310>/Relational Operator'
  //   RelationalOperator: '<S448>/Compare'

  if ((CONSTANT_DATA->HOT_FUNCTION != NON_FUNCTIONAL) && (flt_HOT < flt_ECT)) {
    temp_Lowest = flt_HOT;
  } else {
    temp_Lowest = flt_ECT;
  }

  // End of Switch: '<S310>/Switch'

  // Chart: '<S310>/GlowPlug' incorporates:
  //   UnitDelay: '<S310>/Unit Delay'
  //   UnitDelay: '<S310>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
  // During: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
  if ((uint32_T)MX_Gateway_DWork.bitsForTID2.is_active_c38_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
    MX_Gateway_DWork.bitsForTID2.is_active_c38_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
    // Transition: '<S449>:247'
    MX_Gateway_DWork.bitsForTID2.is_c38_MX_Gateway =
      MX_Gatew_IN_NON_FUNCTIONAL_pvlo;

    // Entry 'NON_FUNCTIONAL': '<S449>:246'
    dout_GlowPlug = ((int32_T)INACTIVE != 0);
    count_GlowPlug = 0U;
  } else {
    switch (MX_Gateway_DWork.bitsForTID2.is_c38_MX_Gateway) {
     case MX_Gateway_IN_ECU_ljaf:
      // During 'ECU': '<S449>:245'
      switch (MX_Gateway_DWork.bitsForTID2.is_ECU) {
       case MX_Gateway_IN_Countdown:
        // During 'Countdown': '<S449>:252'
        if ((MX_Gateway_B.RateTransition16_hyai == ENGINE_RUNNING) ||
            (MX_Gateway_B.RateTransition24_bca5 == INACTIVE) || ((int32_T)
             count_GlowPlug == 0)) {
          // Transition: '<S449>:255'
          MX_Gateway_DWork.bitsForTID2.is_ECU = MX_Gateway_IN_Stop;

          // Entry 'Stop': '<S449>:254'
          count_GlowPlug = 0U;
        } else {
          count_GlowPlug = (uint16_T)(int32_T)((int32_T)count_GlowPlug - 1);
        }
        break;

       case MX_Gateway_IN_Stop:
        // During 'Stop': '<S449>:254'
        if ((MX_Gateway_B.RateTransition16_hyai == ENGINE_NOT_RUNNING) &&
            (MX_Gateway_B.RateTransition24_bca5 == INACTIVE)) {
          // Transition: '<S449>:256'
          MX_Gateway_DWork.bitsForTID2.is_ECU = MX_Gateway_IN_Wait;

          // Entry 'Wait': '<S449>:250'
          count_GlowPlug = 0U;
        }
        break;

       default:
        // During 'Wait': '<S449>:250'
        if ((MX_Gateway_B.RateTransition24_bca5 == ACTIVE) &&
            (MX_Gateway_B.RateTransition27_chza == NORMAL)) {
          // Transition: '<S449>:253'
          MX_Gateway_DWork.bitsForTID2.is_ECU = MX_Gateway_IN_Countdown;

          // Entry 'Countdown': '<S449>:252'
          count_GlowPlug = MX_Gateway_B.time_GlowPlug;
        }
        break;
      }
      break;

     case MX_Gatew_IN_NON_FUNCTIONAL_pvlo:
      // During 'NON_FUNCTIONAL': '<S449>:246'
      if ((CONSTANT_DATA->ECU_FUNCTION == ECU_J1939) &&
          (CONSTANT_DATA->GLOW_PLUG_ECU_COUNTDOWN_FUNCTION != NON_FUNCTIONAL)) {
        // Transition: '<S449>:248'
        MX_Gateway_DWork.bitsForTID2.is_c38_MX_Gateway = MX_Gateway_IN_ECU_ljaf;

        // Entry Internal 'ECU': '<S449>:245'
        // Transition: '<S449>:251'
        MX_Gateway_DWork.bitsForTID2.is_ECU = MX_Gateway_IN_Wait;

        // Entry 'Wait': '<S449>:250'
        count_GlowPlug = 0U;
      } else {
        // Transition: '<S449>:249'
        MX_Gateway_DWork.bitsForTID2.is_c38_MX_Gateway =
          MX_Gateway_IN_NORMAL_jia4;

        // Entry Internal 'NORMAL': '<S449>:244'
        // Transition: '<S449>:97'
        MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_WAIT_STARTUP;

        // Entry 'WAIT_STARTUP': '<S449>:96'
        dout_GlowPlug = false;
        MX_Gateway_DWork.debounceCrank = 0U;
      }
      break;

     default:
      // During 'NORMAL': '<S449>:244'
      switch (MX_Gateway_DWork.bitsForTID2.is_NORMAL) {
       case MX_Gateway_IN_AFTERGLOW:
        // During 'AFTERGLOW': '<S449>:4'
        if (((int32_T)MX_Gateway_DWork.debounceCount_ivzl == 0) ||
            (!((MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
               (MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == FAILURE))) ||
            (MX_Gateway_DWork.UnitDelay1_DSTATE_awti != NORMAL) ||
            (MX_Gateway_B.RateTransition44 != SYS_NORMAL)) {
          // Transition: '<S449>:12'
          // Exit 'AFTERGLOW': '<S449>:4'
          MX_Gateway_DWork.bitsForTID2.glowPlugAfterGlowDone = ((int32_T)ACTIVE
            != 0);
          MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S449>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S449>:2'
          // Transition: '<S449>:38'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE = MX_Gateway_IN_CRANKING;
        } else {
          MX_Gateway_DWork.debounceCount_ivzl = (uint16_T)(int32_T)((int32_T)
            MX_Gateway_DWork.debounceCount_ivzl - 1);
        }
        break;

       case MX_Gateway_IN_GLOW_DURING_CRANK:
        // During 'GLOW_DURING_CRANK': '<S449>:6'
        if ((MX_Gateway_B.RateTransition16_hyai != ENGINE_CRANKING) ||
            (!((MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
               (MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == FAILURE))) ||
            (MX_Gateway_DWork.UnitDelay1_DSTATE_awti != NORMAL) ||
            (state_VBattery == OORL) || (MX_Gateway_B.RateTransition44 !=
             SYS_NORMAL) || ((MX_Gateway_DWork.debounceCrank >=
                              CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_CRANK) &&
                             (CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_CRANK !=
                              UNLIMITED))) {
          // Transition: '<S449>:35'
          // Exit 'GLOW_DURING_CRANK': '<S449>:6'
          MX_Gateway_DWork.state_CrankTimerExpired = ACTIVE;
          MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S449>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S449>:2'
          // Transition: '<S449>:38'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE = MX_Gateway_IN_CRANKING;
        } else {
          MX_Gateway_DWork.debounceCrank = (uint16_T)(int32_T)((int32_T)
            MX_Gateway_DWork.debounceCrank + 1);
        }
        break;

       case MX_Gateway_IN_INACTIVE_lvoc:
        // During 'INACTIVE': '<S449>:2'
        if ((CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_FUNCTION != NON_FUNCTIONAL) &&
            (MX_Gateway_B.RateTransition16_hyai == ENGINE_RUNNING) &&
            ((MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
             (MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == FAILURE)) &&
            (MX_Gateway_DWork.UnitDelay1_DSTATE_awti == NORMAL) &&
            (MX_Gateway_DWork.bitsForTID2.glowPlugAfterGlowDone == (int32_T)
             INACTIVE)) {
          // Transition: '<S449>:11'
          MX_Gateway_AfterglowTime(temp_Lowest);

          // Exit Internal 'INACTIVE': '<S449>:2'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_AFTERGLOW;

          // Entry 'AFTERGLOW': '<S449>:4'
          dout_GlowPlug = ((int32_T)ACTIVE != 0);
          count_GlowPlug = 0U;
        } else if ((CONSTANT_DATA->GLOW_PLUG_CRANKING_FUNCTION != NON_FUNCTIONAL)
                   && (state_VBattery != OORL) &&
                   (MX_Gateway_B.RateTransition16_hyai == ENGINE_CRANKING) &&
                   ((MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
                    (MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == FAILURE)) &&
                   (MX_Gateway_DWork.UnitDelay1_DSTATE_awti == NORMAL) &&
                   (MX_Gateway_DWork.state_CrankTimerExpired != ACTIVE)) {
          // Transition: '<S449>:36'
          // Exit Internal 'INACTIVE': '<S449>:2'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gateway_DWork.bitsForTID2.is_NORMAL =
            MX_Gateway_IN_GLOW_DURING_CRANK;

          // Entry 'GLOW_DURING_CRANK': '<S449>:6'
          dout_GlowPlug = ((int32_T)ACTIVE != 0);
          MX_Gateway_DWork.debounceCrank = 0U;
          MX_Gateway_DWork.bitsForTID2.glowPlugAfterGlowDone = ((int32_T)
            INACTIVE != 0);
        } else if ((CONSTANT_DATA->GLOW_PLUG_PREHEAT_FUNCTION != NON_FUNCTIONAL)
                   && (MX_Gateway_DWork.cycleCount <
                       CONSTANT_DATA->GLOW_PLUG_PREHEAT_COUNTER) &&
                   (state_VBattery != OORL) &&
                   ((CONSTANT_DATA->GLOW_PLUG_OFF_WITH_LOW_BATTERY ==
                     NON_FUNCTIONAL) || (state_VBattery == NORMAL) ||
                    (state_VBattery == HIGH)) &&
                   ((MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
                    (MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == FAILURE)) &&
                   (MX_Gateway_DWork.UnitDelay1_DSTATE_awti == NORMAL) &&
                   (MX_Gateway_B.RateTransition16_hyai == ENGINE_NOT_RUNNING) &&
                   (MX_Gateway_B.RateTransition44 == SYS_NORMAL)) {
          // Transition: '<S449>:9'
          MX_Gateway_PreheatTime(temp_Lowest);

          // Exit Internal 'INACTIVE': '<S449>:2'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_PREHEAT;

          // Entry Internal 'PREHEAT': '<S449>:242'
          // Transition: '<S449>:243'
          MX_Gateway_DWork.bitsForTID2.is_PREHEAT = MX_Gateway_IN_PREGLOW;

          // Entry Internal 'PREGLOW': '<S449>:3'
          // Transition: '<S449>:30'
          if ((int32_T)MX_Gateway_DWork.debounceCount_ivzl != 0) {
            // Transition: '<S449>:31'
            // Transition: '<S449>:32'
            dout_GlowPlug = ((int32_T)ACTIVE != 0);

            // Transition: '<S449>:33'
          } else {
            // Transition: '<S449>:34'
            dout_GlowPlug = ((int32_T)INACTIVE != 0);
          }
        } else if ((MX_Gateway_DWork.bitsForTID2.is_INACTIVE ==
                    MX_Gateway_IN_CRANKING) &&
                   ((MX_Gateway_B.RateTransition16_hyai != ENGINE_CRANKING) &&
                    (CONSTANT_DATA->GLOW_PLUG_CRANKING_FUNCTION !=
                     NON_FUNCTIONAL))) {
          // During 'CRANKING': '<S449>:8'
          // Transition: '<S449>:37'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE = MX_Gateway_IN_RESET_CRANK;

          // Entry 'RESET_CRANK': '<S449>:7'
          MX_Gateway_DWork.state_CrankTimerExpired = INACTIVE;
        } else {
          // During 'RESET_CRANK': '<S449>:7'
        }
        break;

       case MX_Gateway_IN_PREHEAT:
        // During 'PREHEAT': '<S449>:242'
        if ((MX_Gateway_B.RateTransition16_hyai == ENGINE_RUNNING) ||
            (MX_Gateway_B.RateTransition16_hyai == ENGINE_CRANKING) ||
            (!((MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
               (MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 == FAILURE))) ||
            (MX_Gateway_DWork.UnitDelay1_DSTATE_awti != NORMAL) ||
            (MX_Gateway_B.RateTransition44 != SYS_NORMAL) || (state_VBattery ==
             OORL) || (MX_Gateway_DWork.cycleCount >=
                       CONSTANT_DATA->GLOW_PLUG_PREHEAT_COUNTER)) {
          // Transition: '<S449>:26'
          MX_Gateway_DWork.cycleCount = (uint16_T)
            CONSTANT_DATA->GLOW_PLUG_PREHEAT_COUNTER;

          // Exit Internal 'PREHEAT': '<S449>:242'
          MX_Gateway_DWork.bitsForTID2.is_PREHEAT =
            MX_Gate_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S449>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S449>:2'
          // Transition: '<S449>:38'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE = MX_Gateway_IN_CRANKING;
        } else if (MX_Gateway_DWork.bitsForTID2.is_PREHEAT ==
                   MX_Gateway_IN_PREGLOW) {
          // During 'PREGLOW': '<S449>:3'
          if ((int32_T)MX_Gateway_DWork.debounceCount_ivzl == 0) {
            // Transition: '<S449>:21'
            MX_Gateway_PreheatWaitTime(temp_Lowest);
            MX_Gateway_DWork.bitsForTID2.is_PREHEAT = MX_Gateway_IN_PREGLOW_WAIT;

            // Entry 'PREGLOW_WAIT': '<S449>:1'
            dout_GlowPlug = ((int32_T)INACTIVE != 0);
            MX_Gateway_DWork.cycleCount = (uint16_T)(int32_T)((int32_T)
              MX_Gateway_DWork.cycleCount + 1);
          } else {
            MX_Gateway_DWork.debounceCount_ivzl = (uint16_T)(int32_T)((int32_T)
              MX_Gateway_DWork.debounceCount_ivzl - 1);
            count_GlowPlug = MX_Gateway_DWork.debounceCount_ivzl;
          }
        } else {
          // During 'PREGLOW_WAIT': '<S449>:1'
          if ((int32_T)MX_Gateway_DWork.debounceCount_ivzl == 0) {
            // Transition: '<S449>:22'
            MX_Gateway_PreheatTime(temp_Lowest);
            MX_Gateway_DWork.bitsForTID2.is_PREHEAT = MX_Gateway_IN_PREGLOW;

            // Entry Internal 'PREGLOW': '<S449>:3'
            // Transition: '<S449>:30'
            if ((int32_T)MX_Gateway_DWork.debounceCount_ivzl != 0) {
              // Transition: '<S449>:31'
              // Transition: '<S449>:32'
              dout_GlowPlug = ((int32_T)ACTIVE != 0);

              // Transition: '<S449>:33'
            } else {
              // Transition: '<S449>:34'
              dout_GlowPlug = ((int32_T)INACTIVE != 0);
            }
          } else {
            MX_Gateway_DWork.debounceCount_ivzl = (uint16_T)(int32_T)((int32_T)
              MX_Gateway_DWork.debounceCount_ivzl - 1);
          }
        }
        break;

       default:
        // During 'WAIT_STARTUP': '<S449>:96'
        if ((int32_T)MX_Gateway_DWork.debounceCrank > 3) {
          // Transition: '<S449>:29'
          MX_Gateway_DWork.bitsForTID2.is_NORMAL = MX_Gateway_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S449>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S449>:2'
          // Transition: '<S449>:38'
          MX_Gateway_DWork.bitsForTID2.is_INACTIVE = MX_Gateway_IN_CRANKING;
        } else {
          MX_Gateway_DWork.debounceCrank = (uint16_T)(int32_T)((int32_T)
            MX_Gateway_DWork.debounceCrank + 1);
        }
        break;
      }
      break;
    }
  }

  // End of Chart: '<S310>/GlowPlug'

  // SignalConversion: '<S310>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S310>/FunctionState'
  //   Constant: '<S446>/Constant'
  //   Constant: '<S447>/Constant'
  //   Logic: '<S310>/Logical Operator1'
  //   RelationalOperator: '<S446>/Compare'
  //   RelationalOperator: '<S447>/Compare'

  rtb_HiddenBuf_InsertedFor_relay =
    ((CONSTANT_DATA->GLOW_PLUG_PREHEAT_FEEDBACK_FUNCTION != NON_FUNCTIONAL) &&
     (state_VBattery != OORL));

  // Outputs for Enabled SubSystem: '<S310>/relay_oc'
  MX_Gateway_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_GlowPlug,
                      MX_Gateway_B.RateTransition29_kajv,
                      MX_Gateway_B.RateTransition30_mgbl, &state_GlowPlugOutput,
                      &state_GlowPlugRelay, &MX_Gateway_B.relay_oc_dsbs,
                      &MX_Gateway_DWork.relay_oc_dsbs,
                      CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_ERROR_ON,
                      CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S310>/relay_oc'

  // Update for UnitDelay: '<S310>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE_jdy3 = state_GlowPlugOutput;

  // Update for UnitDelay: '<S310>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_awti = state_GlowPlugRelay;
}

// System initialize for atomic system: '<S26>/Hyd_Bypass'
void MX_Gateway_Hyd_Bypass_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S311>/Hyd_Bypass'
  // SystemInitialize for Chart: '<S454>/Hyd_Bypass'
  MX_Gateway_DWork.temporalCounter_i1_iy55 = 0U;
  MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht =
    MX_Gate_IN_NO_ACTIVE_CHILD_k5om;
  MX_Gateway_DWork.bitsForTID1.is_active_c59_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_k5om;
  MX_Gateway_B.dout_HydBypass = false;

  // SystemInitialize for Atomic SubSystem: '<S454>/output_pair_open_loop'
  MX_Ga_output_pair_OpenLoop_Init(&MX_Gateway_B.hs_cmd_bwye,
    &MX_Gateway_B.ls_cmd_kapg, &MX_Gateway_B.state_Output_ad00,
    &MX_Gateway_B.output_pair_open_loop_ckv4,
    &MX_Gateway_DWork.output_pair_open_loop_ckv4);

  // End of SystemInitialize for SubSystem: '<S454>/output_pair_open_loop'

  // End of SystemInitialize for SubSystem: '<S311>/Hyd_Bypass'
}

// Output and update for atomic system: '<S26>/Hyd_Bypass'
void MX_Gateway_Hyd_Bypass(void)
{
  boolean_T rtb_Compare_k0qr;

  // Outputs for Enabled SubSystem: '<S311>/Hyd_Bypass' incorporates:
  //   EnablePort: '<S454>/Enable'

  // Logic: '<S311>/Logical Operator' incorporates:
  //   Constant: '<S311>/Constant'
  //   Constant: '<S452>/Constant'
  //   Constant: '<S453>/Constant'
  //   RelationalOperator: '<S452>/Compare'
  //   RelationalOperator: '<S453>/Compare'

  if ((state_System == SYS_NORMAL) && (CONSTANT_DATA->HYD_BYPASS_FUNCTION !=
       NON_FUNCTIONAL)) {
    if (!MX_Gateway_DWork.Hyd_Bypass_MODE) {
      // SystemReset for Chart: '<S454>/Hyd_Bypass'
      MX_Gateway_DWork.temporalCounter_i1_iy55 = 0U;
      MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht =
        MX_Gate_IN_NO_ACTIVE_CHILD_k5om;
      MX_Gateway_DWork.bitsForTID1.is_active_c59_MX_Gateway = 0U;
      MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
        MX_Gate_IN_NO_ACTIVE_CHILD_k5om;
      MX_Gateway_B.dout_HydBypass = false;

      // SystemReset for Atomic SubSystem: '<S454>/output_pair_open_loop'
      MX_G_output_pair_OpenLoop_Reset(&MX_Gateway_B.hs_cmd_bwye,
        &MX_Gateway_B.ls_cmd_kapg, &MX_Gateway_B.state_Output_ad00,
        &MX_Gateway_B.output_pair_open_loop_ckv4,
        &MX_Gateway_DWork.output_pair_open_loop_ckv4);

      // End of SystemReset for SubSystem: '<S454>/output_pair_open_loop'
      MX_Gateway_DWork.Hyd_Bypass_MODE = true;
    }

    // RelationalOperator: '<S455>/Compare' incorporates:
    //   Constant: '<S455>/Constant'

    rtb_Compare_k0qr = (state_Console != ACTIVE);

    // Chart: '<S454>/Hyd_Bypass'
    // Gateway: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass
    if ((uint32_T)MX_Gateway_DWork.temporalCounter_i1_iy55 < 255U) {
      MX_Gateway_DWork.temporalCounter_i1_iy55 = (uint8_T)(int32_T)((int32_T)
        MX_Gateway_DWork.temporalCounter_i1_iy55 + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass
    if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c59_MX_Gateway == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass
      MX_Gateway_DWork.bitsForTID1.is_active_c59_MX_Gateway = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass 
      // Transition: '<S456>:36'
      MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
        MX_Gateway_IN_Not_Cranking;

      // Entry Internal 'Not_Cranking': '<S456>:14'
      // Transition: '<S456>:21'
      MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht = MX_Gateway_IN_Off_chbn;

      // Entry 'Off': '<S456>:2'
      MX_Gateway_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
    } else {
      switch (MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway) {
       case MX_Gateway_IN_Cranking:
        // During 'Cranking': '<S456>:15'
        if (state_Engine != ENGINE_CRANKING) {
          // Transition: '<S456>:33'
          MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
            MX_Gateway_IN_Delay_dyin;
          MX_Gateway_DWork.temporalCounter_i1_iy55 = 0U;
        }
        break;

       case MX_Gateway_IN_Delay_dyin:
        // During 'Delay': '<S456>:16'
        if (MX_Gateway_DWork.temporalCounter_i1_iy55 >=
            CONSTANT_DATA->HYD_BYPASS_CRANK_DELAY) {
          // Transition: '<S456>:35'
          MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
            MX_Gateway_IN_Not_Cranking;

          // Entry Internal 'Not_Cranking': '<S456>:14'
          // Transition: '<S456>:21'
          MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht =
            MX_Gateway_IN_Off_chbn;

          // Entry 'Off': '<S456>:2'
          MX_Gateway_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
        } else {
          if (state_Engine == ENGINE_CRANKING) {
            // Transition: '<S456>:34'
            MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
              MX_Gateway_IN_Cranking;

            // Entry 'Cranking': '<S456>:15'
            MX_Gateway_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
          }
        }
        break;

       default:
        // During 'Not_Cranking': '<S456>:14'
        if (state_Engine == ENGINE_CRANKING) {
          // Transition: '<S456>:32'
          // Exit Internal 'Not_Cranking': '<S456>:14'
          MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht =
            MX_Gate_IN_NO_ACTIVE_CHILD_k5om;
          MX_Gateway_DWork.bitsForTID1.is_c59_MX_Gateway =
            MX_Gateway_IN_Cranking;

          // Entry 'Cranking': '<S456>:15'
          MX_Gateway_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
        } else if (MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht ==
                   MX_Gateway_IN_Off_chbn) {
          // During 'Off': '<S456>:2'
          if (state_Console == ACTIVE) {
            // Transition: '<S456>:20'
            MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht =
              MX_Gateway_IN_On_cbgn;

            // Entry 'On': '<S456>:9'
            MX_Gateway_B.dout_HydBypass = ((int32_T)ACTIVE != 0);
          }
        } else {
          // During 'On': '<S456>:9'
          if (state_Console != ACTIVE) {
            // Transition: '<S456>:18'
            MX_Gateway_DWork.bitsForTID1.is_Not_Cranking_jyht =
              MX_Gateway_IN_Off_chbn;

            // Entry 'Off': '<S456>:2'
            MX_Gateway_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
          }
        }
        break;
      }
    }

    // End of Chart: '<S454>/Hyd_Bypass'

    // Outputs for Atomic SubSystem: '<S454>/output_pair_open_loop'
    MX_Gateway_output_pair_OpenLoop(MX_Gateway_B.dout_HydBypass,
      rtb_Compare_k0qr, state_Engine, afbk_HydBypass, ifbk_HydBypass,
      MX_Gateway_B.RateTransition12_a0us, MX_Gateway_B.RateTransition1_egwe,
      ain_PrecisionReference, &MX_Gateway_B.hs_cmd_bwye,
      &MX_Gateway_B.ls_cmd_kapg, &MX_Gateway_B.state_Output_ad00,
      &MX_Gateway_B.output_pair_open_loop_ckv4,
      &MX_Gateway_DWork.output_pair_open_loop_ckv4,
      CONSTANT_DATA->HYD_BYPASS_MAX_VOLTS,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_BYPASS_OVERCURRENT,
      CONSTANT_DATA->HYD_BYPASS_NON_ZERO_DUTY,
      CONSTANT_DATA->HYD_BYPASS_NON_ZERO_CURRENT,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->HYD_BYPASS_FEEDBACK_FUNCTION,
      CONSTANT_DATA->HYD_BYPASS_AFBK_GAIN, CONSTANT_DATA->HYD_BYPASS_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S454>/output_pair_open_loop'

    // SignalConversion: '<S454>/OutportBufferForhs_HydBypass'
    hs_HydBypass = MX_Gateway_B.hs_cmd_bwye;

    // SignalConversion: '<S454>/OutportBufferForls_HydBypass'
    ls_HydBypass = MX_Gateway_B.ls_cmd_kapg;

    // SignalConversion: '<S454>/OutportBufferForstate_HydBypass'
    state_HydBypass = MX_Gateway_B.state_Output_ad00;
  } else {
    if (MX_Gateway_DWork.Hyd_Bypass_MODE) {
      // Disable for Outport: '<S454>/state_HydBypass'
      state_HydBypass = ((uint8_T)0U);

      // Disable for Outport: '<S454>/hs_HydBypass'
      hs_HydBypass = ((uint16_T)0U);

      // Disable for Outport: '<S454>/ls_HydBypass'
      ls_HydBypass = false;
      MX_Gateway_DWork.Hyd_Bypass_MODE = false;
    }
  }

  // End of Logic: '<S311>/Logical Operator'
  // End of Outputs for SubSystem: '<S311>/Hyd_Bypass'
}

// System initialize for atomic system: '<S26>/Hyd_Enable'
void MX_Gateway_Hyd_Enable_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S312>/Hyd_Enable'
  // SystemInitialize for Chart: '<S473>/Hyd_Enable'
  MX_Gateway_DWork.temporalCounter_i1_jqtp = 0U;
  MX_Gateway_DWork.bitsForTID1.is_Not_Cranking = MX_Gate_IN_NO_ACTIVE_CHILD_pdyo;
  MX_Gateway_DWork.bitsForTID1.is_active_c11_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_pdyo;
  MX_Gateway_B.dout_HydEnable = false;

  // SystemInitialize for Atomic SubSystem: '<S473>/output_pair_open_loop'
  MX_Ga_output_pair_OpenLoop_Init(&MX_Gateway_B.hs_cmd_jt20,
    &MX_Gateway_B.ls_cmd_g0eq, &MX_Gateway_B.state_Output_giiq,
    &MX_Gateway_B.output_pair_open_loop_gaik,
    &MX_Gateway_DWork.output_pair_open_loop_gaik);

  // End of SystemInitialize for SubSystem: '<S473>/output_pair_open_loop'

  // End of SystemInitialize for SubSystem: '<S312>/Hyd_Enable'
}

// Output and update for atomic system: '<S26>/Hyd_Enable'
void MX_Gateway_Hyd_Enable(void)
{
  boolean_T rtb_Compare_o3g4;
  boolean_T rtb_Switch_fq53;

  // Outputs for Enabled SubSystem: '<S312>/Hyd_Enable' incorporates:
  //   EnablePort: '<S473>/Enable'

  // RelationalOperator: '<S472>/Compare' incorporates:
  //   Constant: '<S472>/Constant'

  if (state_System == SYS_NORMAL) {
    if (!MX_Gateway_DWork.Hyd_Enable_MODE) {
      // SystemReset for Chart: '<S473>/Hyd_Enable'
      MX_Gateway_DWork.temporalCounter_i1_jqtp = 0U;
      MX_Gateway_DWork.bitsForTID1.is_Not_Cranking =
        MX_Gate_IN_NO_ACTIVE_CHILD_pdyo;
      MX_Gateway_DWork.bitsForTID1.is_active_c11_MX_Gateway = 0U;
      MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
        MX_Gate_IN_NO_ACTIVE_CHILD_pdyo;
      MX_Gateway_B.dout_HydEnable = false;

      // SystemReset for Atomic SubSystem: '<S473>/output_pair_open_loop'
      MX_G_output_pair_OpenLoop_Reset(&MX_Gateway_B.hs_cmd_jt20,
        &MX_Gateway_B.ls_cmd_g0eq, &MX_Gateway_B.state_Output_giiq,
        &MX_Gateway_B.output_pair_open_loop_gaik,
        &MX_Gateway_DWork.output_pair_open_loop_gaik);

      // End of SystemReset for SubSystem: '<S473>/output_pair_open_loop'
      MX_Gateway_DWork.Hyd_Enable_MODE = true;
    }

    // RelationalOperator: '<S474>/Compare' incorporates:
    //   Constant: '<S474>/Constant'

    rtb_Compare_o3g4 = (state_Console != ACTIVE);

    // Chart: '<S473>/Hyd_Enable'
    // Gateway: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable
    if ((uint32_T)MX_Gateway_DWork.temporalCounter_i1_jqtp < 255U) {
      MX_Gateway_DWork.temporalCounter_i1_jqtp = (uint8_T)(int32_T)((int32_T)
        MX_Gateway_DWork.temporalCounter_i1_jqtp + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable
    if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c11_MX_Gateway == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable
      MX_Gateway_DWork.bitsForTID1.is_active_c11_MX_Gateway = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable 
      // Transition: '<S475>:36'
      MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
        MX_Gateway_IN_Not_Cranking_llua;

      // Entry Internal 'Not_Cranking': '<S475>:14'
      // Transition: '<S475>:21'
      MX_Gateway_DWork.bitsForTID1.is_Not_Cranking = MX_Gateway_IN_Off_cbc5;

      // Entry 'Off': '<S475>:2'
      MX_Gateway_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
    } else {
      switch (MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway) {
       case MX_Gateway_IN_Cranking_c5p0:
        // During 'Cranking': '<S475>:15'
        if (state_Engine != ENGINE_CRANKING) {
          // Transition: '<S475>:33'
          MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
            MX_Gateway_IN_Delay_gzfi;
          MX_Gateway_DWork.temporalCounter_i1_jqtp = 0U;
        }
        break;

       case MX_Gateway_IN_Delay_gzfi:
        // During 'Delay': '<S475>:16'
        if (MX_Gateway_DWork.temporalCounter_i1_jqtp >=
            CONSTANT_DATA->HYD_ENABLE_CRANK_DELAY) {
          // Transition: '<S475>:35'
          MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
            MX_Gateway_IN_Not_Cranking_llua;

          // Entry Internal 'Not_Cranking': '<S475>:14'
          // Transition: '<S475>:21'
          MX_Gateway_DWork.bitsForTID1.is_Not_Cranking = MX_Gateway_IN_Off_cbc5;

          // Entry 'Off': '<S475>:2'
          MX_Gateway_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
        } else {
          if (state_Engine == ENGINE_CRANKING) {
            // Transition: '<S475>:34'
            MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
              MX_Gateway_IN_Cranking_c5p0;

            // Entry 'Cranking': '<S475>:15'
            MX_Gateway_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
          }
        }
        break;

       default:
        // During 'Not_Cranking': '<S475>:14'
        if (state_Engine == ENGINE_CRANKING) {
          // Transition: '<S475>:32'
          // Exit Internal 'Not_Cranking': '<S475>:14'
          MX_Gateway_DWork.bitsForTID1.is_Not_Cranking =
            MX_Gate_IN_NO_ACTIVE_CHILD_pdyo;
          MX_Gateway_DWork.bitsForTID1.is_c11_MX_Gateway =
            MX_Gateway_IN_Cranking_c5p0;

          // Entry 'Cranking': '<S475>:15'
          MX_Gateway_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
        } else if (MX_Gateway_DWork.bitsForTID1.is_Not_Cranking ==
                   MX_Gateway_IN_Off_cbc5) {
          // During 'Off': '<S475>:2'
          if (state_Console == ACTIVE) {
            // Transition: '<S475>:20'
            MX_Gateway_DWork.bitsForTID1.is_Not_Cranking = MX_Gateway_IN_On_f50i;

            // Entry 'On': '<S475>:9'
            MX_Gateway_B.dout_HydEnable = ((int32_T)ACTIVE != 0);
          }
        } else {
          // During 'On': '<S475>:9'
          if (state_Console != ACTIVE) {
            // Transition: '<S475>:18'
            MX_Gateway_DWork.bitsForTID1.is_Not_Cranking =
              MX_Gateway_IN_Off_cbc5;

            // Entry 'Off': '<S475>:2'
            MX_Gateway_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
          }
        }
        break;
      }
    }

    // End of Chart: '<S473>/Hyd_Enable'

    // Switch: '<S473>/Switch' incorporates:
    //   Constant: '<S473>/Constant'

    if (CONSTANT_DATA->EMEA_ELECTRIC_VERSION >= ((uint8_T)0U)) {
      rtb_Switch_fq53 = ((int32_T)state_Inverter != 0);
    } else {
      rtb_Switch_fq53 = MX_Gateway_B.dout_HydEnable;
    }

    // End of Switch: '<S473>/Switch'

    // Outputs for Atomic SubSystem: '<S473>/output_pair_open_loop'
    MX_Gateway_output_pair_OpenLoop(rtb_Switch_fq53, rtb_Compare_o3g4,
      state_Engine, afbk_HydEnable, ifbk_HydEnable,
      MX_Gateway_B.RateTransition15_ozmr, MX_Gateway_B.RateTransition13_aepw,
      ain_PrecisionReference, &MX_Gateway_B.hs_cmd_jt20,
      &MX_Gateway_B.ls_cmd_g0eq, &MX_Gateway_B.state_Output_giiq,
      &MX_Gateway_B.output_pair_open_loop_gaik,
      &MX_Gateway_DWork.output_pair_open_loop_gaik,
      CONSTANT_DATA->HYD_ENABLE_MAX_VOLTS,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_ENABLE_OVERCURRENT,
      CONSTANT_DATA->HYD_ENABLE_NON_ZERO_DUTY,
      CONSTANT_DATA->HYD_ENABLE_NON_ZERO_CURRENT,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->HYD_ENABLE_FEEDBACK_FUNCTION,
      CONSTANT_DATA->HYD_ENABLE_AFBK_GAIN, CONSTANT_DATA->HYD_ENABLE_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S473>/output_pair_open_loop'

    // SignalConversion: '<S473>/OutportBufferForhs_HydEnable'
    hs_HydEnable = MX_Gateway_B.hs_cmd_jt20;

    // SignalConversion: '<S473>/OutportBufferForls_HydEnable'
    ls_HydEnable = MX_Gateway_B.ls_cmd_g0eq;

    // SignalConversion: '<S473>/OutportBufferForstate_HydEnable'
    state_HydEnable = MX_Gateway_B.state_Output_giiq;
  } else {
    if (MX_Gateway_DWork.Hyd_Enable_MODE) {
      // Disable for Outport: '<S473>/state_HydEnable'
      state_HydEnable = ((uint8_T)0U);

      // Disable for Outport: '<S473>/hs_HydEnable'
      hs_HydEnable = ((uint16_T)0U);

      // Disable for Outport: '<S473>/ls_HydEnable'
      ls_HydEnable = false;
      MX_Gateway_DWork.Hyd_Enable_MODE = false;
    }
  }

  // End of RelationalOperator: '<S472>/Compare'
  // End of Outputs for SubSystem: '<S312>/Hyd_Enable'
}

// System initialize for atomic system: '<S26>/Hydraulic_Exchange'
void MX_Gate_Hydraulic_Exchange_Init(void)
{
  // SystemInitialize for Chart: '<S313>/Hydraulic_Xchange'
  MX_Gateway_DWork.bitsForTID2.is_Functional_pmyt =
    MX_Gate_IN_NO_ACTIVE_CHILD_daqq;
  MX_Gateway_DWork.bitsForTID2.is_active_c46_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID2.is_c46_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_daqq;
  dout_HydExchange = false;

  // SystemInitialize for Enabled SubSystem: '<S313>/dout_chk'
  MX_Gateway_dout_chk_Init(&state_HydExchange, &MX_Gateway_B.dout_chk_ci2g,
    &MX_Gateway_DWork.dout_chk_ci2g);

  // End of SystemInitialize for SubSystem: '<S313>/dout_chk'
}

// Output and update for atomic system: '<S26>/Hydraulic_Exchange'
void MX_Gateway_Hydraulic_Exchange(void)
{
  boolean_T rtb_LogicalOperator_eydd;

  // Chart: '<S313>/Hydraulic_Xchange' incorporates:
  //   UnitDelay: '<S313>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange
  // During: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange
  if ((uint32_T)MX_Gateway_DWork.bitsForTID2.is_active_c46_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange
    MX_Gateway_DWork.bitsForTID2.is_active_c46_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange 
    // Transition: '<S493>:12'
    MX_Gateway_DWork.bitsForTID2.is_c46_MX_Gateway = MX_Gateway_IN_Nonfunctional;

    // Entry 'Nonfunctional': '<S493>:2'
    dout_HydExchange = ((int32_T)INACTIVE != 0);
  } else if (MX_Gateway_DWork.bitsForTID2.is_c46_MX_Gateway ==
             MX_Gateway_IN_Functional) {
    // During 'Functional': '<S493>:3'
    if (MX_Gateway_DWork.bitsForTID2.is_Functional_pmyt ==
        MX_Gateway_IN_Active_lofk) {
      // During 'Active': '<S493>:10'
      if ((MX_Gateway_B.RateTransition17_gzoi != ACTIVE) || (state_HydExchange
           != NORMAL)) {
        // Transition: '<S493>:23'
        MX_Gateway_DWork.bitsForTID2.is_Functional_pmyt =
          MX_Gateway_IN_Inactive_j3td;

        // Entry 'Inactive': '<S493>:11'
        dout_HydExchange = ((int32_T)INACTIVE != 0);
      }
    } else {
      // During 'Inactive': '<S493>:11'
      if ((MX_Gateway_B.RateTransition17_gzoi == ACTIVE) && (state_HydExchange ==
           NORMAL)) {
        // Transition: '<S493>:22'
        MX_Gateway_DWork.bitsForTID2.is_Functional_pmyt =
          MX_Gateway_IN_Active_lofk;

        // Entry 'Active': '<S493>:10'
        dout_HydExchange = ((int32_T)ACTIVE != 0);
      }
    }
  } else {
    // During 'Nonfunctional': '<S493>:2'
    if (CONSTANT_DATA->HYD_EXCHANGE_FUNCTION != NON_FUNCTIONAL) {
      // Transition: '<S493>:13'
      MX_Gateway_DWork.bitsForTID2.is_c46_MX_Gateway = MX_Gateway_IN_Functional;

      // Entry Internal 'Functional': '<S493>:3'
      // Transition: '<S493>:21'
      MX_Gateway_DWork.bitsForTID2.is_Functional_pmyt =
        MX_Gateway_IN_Inactive_j3td;

      // Entry 'Inactive': '<S493>:11'
      dout_HydExchange = ((int32_T)INACTIVE != 0);
    }
  }

  // End of Chart: '<S313>/Hydraulic_Xchange'

  // Logic: '<S313>/Logical Operator' incorporates:
  //   Constant: '<S313>/FunctionState'
  //   Constant: '<S491>/Constant'
  //   Constant: '<S492>/Constant'
  //   RelationalOperator: '<S491>/Compare'
  //   RelationalOperator: '<S492>/Compare'

  rtb_LogicalOperator_eydd = ((CONSTANT_DATA->HYD_EXCHANGE_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // Outputs for Enabled SubSystem: '<S313>/dout_chk'
  MX_Gateway_dout_chk(rtb_LogicalOperator_eydd, dout_HydExchange,
                      MX_Gateway_B.RateTransition21_dojr, &state_HydExchange,
                      &MX_Gateway_B.dout_chk_ci2g,
                      &MX_Gateway_DWork.dout_chk_ci2g,
                      CONSTANT_DATA->HYD_EXCHANGE_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->HYD_EXCHANGE_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S313>/dout_chk'
}

// System initialize for atomic system: '<S26>/Lights'
void MX_Gateway_Lights_Init(void)
{
  // InitializeConditions for UnitDelay: '<S314>/Unit Delay3'
  MX_Gateway_DWork.UnitDelay3_DSTATE_fo0b = NORMAL;

  // InitializeConditions for UnitDelay: '<S314>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_e1ba = NORMAL;

  // SystemInitialize for Chart: '<S314>/Lights'
  MX_Gateway_DWork.state_Buttons_Old = 0U;

  // Chart: '<S314>/Lights'
  // Entry: MX_Gtwy_Control/Outputs/Lights/Lights
  // Entry Internal: MX_Gtwy_Control/Outputs/Lights/Lights
  // Transition: '<S500>:10'
  MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway = MX_Gateway_IN_LIGHTS_INACTIVE;

  // Entry 'LIGHTS_INACTIVE': '<S500>:1'
  dout_Lights = ((int32_T)INACTIVE != 0);

  // SystemInitialize for Enabled SubSystem: '<S314>/dout_chk'
  MX_Gateway_dout_chk_Init(&MX_Gateway_B.OutportBufferForstate_futm,
    &MX_Gateway_B.dout_chk_jzfm, &MX_Gateway_DWork.dout_chk_jzfm);

  // End of SystemInitialize for SubSystem: '<S314>/dout_chk'

  // SystemInitialize for Enabled SubSystem: '<S314>/relay_oc'
  MX_Gateway_relay_oc_Init(&MX_Gateway_B.state_Output_bilf, &state_LightsRelay,
    &MX_Gateway_B.relay_oc_kvfj, &MX_Gateway_DWork.relay_oc_kvfj);

  // End of SystemInitialize for SubSystem: '<S314>/relay_oc'
}

// Output and update for atomic system: '<S26>/Lights'
void MX_Gateway_Lights(void)
{
  boolean_T rtb_LogicalOperator1_ochu;
  boolean_T rtb_HiddenBuf_InsertedFor_relay;
  boolean_T rtb_ErrorDetectionEnable;

  // Logic: '<S314>/Logical Operator1' incorporates:
  //   Constant: '<S314>/Light1FeedbackState1'
  //   Constant: '<S498>/Constant'
  //   Constant: '<S499>/Constant'
  //   RelationalOperator: '<S498>/Compare'
  //   RelationalOperator: '<S499>/Compare'

  rtb_LogicalOperator1_ochu = ((CONSTANT_DATA->LIGHTS_RELAY_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // SignalConversion: '<S314>/HiddenBuf_InsertedFor_relay_oc_at_inport_3'
  rtb_HiddenBuf_InsertedFor_relay = rtb_LogicalOperator1_ochu;

  // Chart: '<S314>/Lights' incorporates:
  //   UnitDelay: '<S314>/Unit Delay1'
  //   UnitDelay: '<S314>/Unit Delay3'

  // Gateway: MX_Gtwy_Control/Outputs/Lights/Lights
  // During: MX_Gtwy_Control/Outputs/Lights/Lights
  switch (MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway) {
   case MX_Gateway_IN_LIGHTS_ACTIVE:
    // During 'LIGHTS_ACTIVE': '<S500>:2'
    if (((MX_Gateway_DWork.state_Buttons_Old == NO_COMMUNICATION) &&
         (MX_Gateway_B.RateTransition22_crtc != NO_COMMUNICATION)) ||
        (!((state_VBattery == NORMAL) || (state_VBattery == LOW))) ||
        (MX_Gateway_DWork.UnitDelay3_DSTATE_fo0b != NORMAL) ||
        (MX_Gateway_DWork.UnitDelay1_DSTATE_e1ba != NORMAL)) {
      // Transition: '<S500>:14'
      MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway =
        MX_Gateway_IN_LIGHTS_INACTIVE;

      // Entry 'LIGHTS_INACTIVE': '<S500>:1'
      dout_Lights = ((int32_T)INACTIVE != 0);
    } else {
      if (MX_Gateway_B.RateTransition36_ijpl == (int32_T)ACTIVE) {
        // Transition: '<S500>:16'
        MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway =
          MX_Gat_IN_LIGHTS_ACTIVE_RISING2;

        // Entry 'LIGHTS_ACTIVE_RISING2': '<S500>:5'
        dout_Lights = ((int32_T)ACTIVE != 0);
      }
    }
    break;

   case MX_Gat_IN_LIGHTS_ACTIVE_RISING1:
    // During 'LIGHTS_ACTIVE_RISING1': '<S500>:4'
    if (MX_Gateway_B.RateTransition36_ijpl == (int32_T)INACTIVE) {
      // Transition: '<S500>:15'
      MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway =
        MX_Gateway_IN_LIGHTS_ACTIVE;

      // Entry 'LIGHTS_ACTIVE': '<S500>:2'
      MX_Gateway_DWork.state_Buttons_Old = MX_Gateway_B.RateTransition22_crtc;
      dout_Lights = ((int32_T)ACTIVE != 0);
    }
    break;

   case MX_Gat_IN_LIGHTS_ACTIVE_RISING2:
    // During 'LIGHTS_ACTIVE_RISING2': '<S500>:5'
    if (MX_Gateway_B.RateTransition36_ijpl == (int32_T)INACTIVE) {
      // Transition: '<S500>:11'
      MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway =
        MX_Gateway_IN_LIGHTS_INACTIVE;

      // Entry 'LIGHTS_INACTIVE': '<S500>:1'
      dout_Lights = ((int32_T)INACTIVE != 0);
    }
    break;

   default:
    // During 'LIGHTS_INACTIVE': '<S500>:1'
    if (((state_VBattery == NORMAL) || (state_VBattery == LOW)) &&
        (CONSTANT_DATA->LIGHTS_FUNCTION != NON_FUNCTIONAL) &&
        (MX_Gateway_B.RateTransition22_crtc == NO_COMMUNICATION) &&
        (MX_Gateway_DWork.UnitDelay3_DSTATE_fo0b == NORMAL) &&
        (MX_Gateway_DWork.UnitDelay1_DSTATE_e1ba == NORMAL)) {
      // Transition: '<S500>:13'
      MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway =
        MX_Gateway_IN_LIGHTS_ACTIVE;

      // Entry 'LIGHTS_ACTIVE': '<S500>:2'
      MX_Gateway_DWork.state_Buttons_Old = MX_Gateway_B.RateTransition22_crtc;
      dout_Lights = ((int32_T)ACTIVE != 0);
    } else {
      if (((state_VBattery == NORMAL) || (state_VBattery == LOW)) &&
          (CONSTANT_DATA->LIGHTS_FUNCTION != NON_FUNCTIONAL) &&
          (MX_Gateway_B.RateTransition36_ijpl == (int32_T)ACTIVE) &&
          (MX_Gateway_DWork.UnitDelay3_DSTATE_fo0b == NORMAL) &&
          (MX_Gateway_DWork.UnitDelay1_DSTATE_e1ba == NORMAL)) {
        // Transition: '<S500>:8'
        MX_Gateway_DWork.bitsForTID2.is_c34_MX_Gateway =
          MX_Gat_IN_LIGHTS_ACTIVE_RISING1;

        // Entry 'LIGHTS_ACTIVE_RISING1': '<S500>:4'
        dout_Lights = ((int32_T)ACTIVE != 0);
      }
    }
    break;
  }

  // End of Chart: '<S314>/Lights'

  // Logic: '<S314>/Logical Operator2' incorporates:
  //   Constant: '<S314>/Light1FeedbackState'
  //   Constant: '<S496>/Constant'
  //   Constant: '<S497>/Constant'
  //   RelationalOperator: '<S496>/Compare'
  //   RelationalOperator: '<S497>/Compare'

  rtb_ErrorDetectionEnable = ((CONSTANT_DATA->LIGHTS_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // Outputs for Enabled SubSystem: '<S314>/dout_chk'
  MX_Gateway_dout_chk(rtb_ErrorDetectionEnable, dout_Lights,
                      MX_Gateway_B.RateTransition25_a55f,
                      &MX_Gateway_B.OutportBufferForstate_futm,
                      &MX_Gateway_B.dout_chk_jzfm,
                      &MX_Gateway_DWork.dout_chk_jzfm,
                      CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S314>/dout_chk'

  // Outputs for Enabled SubSystem: '<S314>/relay_oc'
  MX_Gateway_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_Lights,
                      MX_Gateway_B.RateTransition25_a55f,
                      MX_Gateway_B.RateTransition18_etzj,
                      &MX_Gateway_B.state_Output_bilf, &state_LightsRelay,
                      &MX_Gateway_B.relay_oc_kvfj,
                      &MX_Gateway_DWork.relay_oc_kvfj,
                      CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_ON,
                      CONSTANT_DATA->LIGHTS_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S314>/relay_oc'

  // Switch: '<S314>/Switch' incorporates:
  //   Logic: '<S314>/Logical Operator3'

  if (!rtb_LogicalOperator1_ochu) {
    state_LightsOutput = MX_Gateway_B.OutportBufferForstate_futm;
  } else {
    state_LightsOutput = MX_Gateway_B.state_Output_bilf;
  }

  // End of Switch: '<S314>/Switch'

  // Update for UnitDelay: '<S314>/Unit Delay3'
  MX_Gateway_DWork.UnitDelay3_DSTATE_fo0b = state_LightsOutput;

  // Update for UnitDelay: '<S314>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_e1ba = state_LightsRelay;
}

// System initialize for atomic system: '<S26>/Offset'
void MX_Gateway_Offset_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S315>/Offset'
  // SystemInitialize for Chart: '<S507>/Commands'
  MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 = MX_Gate_IN_NO_ACTIVE_CHILD_ik2b;
  MX_Gateway_DWork.bitsForTID1.is_active_c33_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c33_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_ik2b;
  MX_Gateway_B.icmd_Base = 0U;
  MX_Gateway_B.icmd_Rod = 0U;

  // SystemInitialize for Atomic SubSystem: '<S507>/hc_pair_control'
  MX__output_pair_ClosedLoop_Init(&MX_Gateway_B.hs_cmd_pjid,
    &MX_Gateway_B.ls_cmd_ifxm, &MX_Gateway_B.state_Output_lu5e,
    &MX_Gateway_B.hc_pair_control_lgu5, &MX_Gateway_DWork.hc_pair_control_lgu5);

  // End of SystemInitialize for SubSystem: '<S507>/hc_pair_control'

  // SystemInitialize for Atomic SubSystem: '<S507>/hc_pair_control1'
  MX__output_pair_ClosedLoop_Init(&MX_Gateway_B.hs_cmd, &MX_Gateway_B.ls_cmd,
    &MX_Gateway_B.state_Output_fskg, &MX_Gateway_B.hc_pair_control1_cc44,
    &MX_Gateway_DWork.hc_pair_control1_cc44);

  // End of SystemInitialize for SubSystem: '<S507>/hc_pair_control1'

  // End of SystemInitialize for SubSystem: '<S315>/Offset'
}

// Output and update for atomic system: '<S26>/Offset'
void MX_Gateway_Offset(void)
{
  // local block i/o variables
  uint16_T rtb_position_Pot_jbn4;
  uint16_T rtb_Offset_Table;
  uint16_T rtb_CurrentvsFlowCmd;
  uint16_T rtb_Aux2Flow_Table;
  boolean_T aVarTruthTableCondition_1;
  boolean_T aVarTruthTableCondition_2;
  boolean_T aVarTruthTableCondition_4;
  boolean_T b;
  uint8_T rtb_state_Pot;
  uint16_T rtb_Switch_jh5g;
  int16_T rtb_Saturation;
  boolean_T rtb_Compare_ajov;
  uint16_T rtb_Product_km1l;
  uint16_T rtb_TmpSignalConversionAtC_bbzb[2];
  uint16_T rtb_TmpSignalConversionAtCurren[2];

  // Outputs for Enabled SubSystem: '<S315>/Offset' incorporates:
  //   EnablePort: '<S507>/Enable'

  // Logic: '<S315>/Logical Operator' incorporates:
  //   Constant: '<S315>/Constant'
  //   Constant: '<S505>/Constant'
  //   Constant: '<S506>/Constant'
  //   RelationalOperator: '<S505>/Compare'
  //   RelationalOperator: '<S506>/Compare'

  if ((state_System == SYS_NORMAL) && (CONSTANT_DATA->OFFSET_FUNCTION !=
       NON_FUNCTIONAL)) {
    if (!MX_Gateway_DWork.Offset_MODE) {
      // SystemReset for Chart: '<S507>/Commands'
      MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
        MX_Gate_IN_NO_ACTIVE_CHILD_ik2b;
      MX_Gateway_DWork.bitsForTID1.is_active_c33_MX_Gateway = 0U;
      MX_Gateway_DWork.bitsForTID1.is_c33_MX_Gateway =
        MX_Gate_IN_NO_ACTIVE_CHILD_ik2b;
      MX_Gateway_B.icmd_Base = 0U;
      MX_Gateway_B.icmd_Rod = 0U;

      // SystemReset for Atomic SubSystem: '<S507>/hc_pair_control'
      MX_output_pair_ClosedLoop_Reset(&MX_Gateway_B.hs_cmd_pjid,
        &MX_Gateway_B.ls_cmd_ifxm, &MX_Gateway_B.state_Output_lu5e,
        &MX_Gateway_B.hc_pair_control_lgu5,
        &MX_Gateway_DWork.hc_pair_control_lgu5);

      // End of SystemReset for SubSystem: '<S507>/hc_pair_control'

      // SystemReset for Atomic SubSystem: '<S507>/hc_pair_control1'
      MX_output_pair_ClosedLoop_Reset(&MX_Gateway_B.hs_cmd, &MX_Gateway_B.ls_cmd,
        &MX_Gateway_B.state_Output_fskg, &MX_Gateway_B.hc_pair_control1_cc44,
        &MX_Gateway_DWork.hc_pair_control1_cc44);

      // End of SystemReset for SubSystem: '<S507>/hc_pair_control1'
      MX_Gateway_DWork.Offset_MODE = true;
    }

    // Truth Table: '<S507>/Controls_Select'
    // Truth Table Function 'MX_Gtwy_Control/Outputs/Offset/Offset/Controls_Select': '<S511>:1' 
    //  EMEA Controls
    // Condition '#1': '<S511>:1:11'
    aVarTruthTableCondition_1 = (CONSTANT_DATA->AUX_FUNCTION ==
      AUX_EMEA_CONTROLS);

    //  Joysticks Reversed (Kawasaki)
    // Condition '#2': '<S511>:1:15'
    aVarTruthTableCondition_2 = (CONSTANT_DATA->EMEA_CONTROLS_REVERSE ==
      NON_FUNCTIONAL);

    //  Offset or Aux2 on Left
    if ((mode_LeftControl == MODE_LEFT_OFFSET) || (mode_LeftControl ==
         MODE_LEFT_AUX2)) {
      // Condition '#3': '<S511>:1:19'
      b = true;
    } else {
      b = false;
    }

    //  Offset on Right
    // Condition '#4': '<S511>:1:23'
    aVarTruthTableCondition_4 = (mode_RightControl == MODE_RIGHT_OFFSET);
    if ((!aVarTruthTableCondition_1) && aVarTruthTableCondition_2 && b &&
        (!aVarTruthTableCondition_4)) {
      // Decision 'D1': '<S511>:1:25'
      //  Offset Pot
      // Action '1': '<S511>:1:41'
      rtb_position_Pot_jbn4 = position_OffsetPot;

      // Action '1': '<S511>:1:42'
      rtb_state_Pot = state_OffsetPot;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_2) && b
               && (!aVarTruthTableCondition_4)) {
      // Decision 'D2': '<S511>:1:27'
      //  Left Pot
      // Action '2': '<S511>:1:48'
      rtb_position_Pot_jbn4 = position_LeftPot;

      // Action '2': '<S511>:1:49'
      rtb_state_Pot = state_LeftPot;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) && b &&
               (!aVarTruthTableCondition_4)) {
      // Decision 'D3': '<S511>:1:29'
      //  Left Pot
      // Action '2': '<S511>:1:48'
      rtb_position_Pot_jbn4 = position_LeftPot;

      // Action '2': '<S511>:1:49'
      rtb_state_Pot = state_LeftPot;
    } else if (aVarTruthTableCondition_1 && (!b) && aVarTruthTableCondition_4) {
      // Decision 'D4': '<S511>:1:31'
      //  Right Pot
      // Action '3': '<S511>:1:55'
      rtb_position_Pot_jbn4 = position_RightPot;

      // Action '3': '<S511>:1:56'
      rtb_state_Pot = state_RightPot;
    } else {
      // Decision 'D5': '<S511>:1:33'
      //  Default
      //  Neutral
      // Action '4': '<S511>:1:62'
      rtb_position_Pot_jbn4 = 500U;

      // Action '4': '<S511>:1:63'
      rtb_state_Pot = 8U;
    }

    // End of Truth Table: '<S507>/Controls_Select'

    // Lookup: '<S513>/Offset_Table'
    //
    //  About '<S513>/Offset_Table':
    //  Input0  Data Type:  Integer        U16
    //  Output0 Data Type:  Fixed Point    U16  2^-12
    //  Saturation Mode: Saturate
    //  Lookup Method: Linear_Endpoint
    //
    //  XData is inlined and evenly spaced, so the algorithm only needs
    //  the value of the first element, the last element, and the spacing.
    //  For efficiency, XData is excluded from the generated code.
    //  YData parameter uses the same data type and scaling as Output0

    LookUpEven_U16_U16_SAT( &(rtb_Offset_Table), (&(MXGTW_OFFSET[0])),
      rtb_position_Pot_jbn4, 20U, 160U, 6U);

    // Switch: '<S507>/Switch' incorporates:
    //   Constant: '<S510>/Constant'
    //   RelationalOperator: '<S510>/Compare'

    if (mode_LeftControl != MODE_LEFT_AUX2) {
      // Switch: '<S513>/Switch1' incorporates:
      //   Constant: '<S513>/Constant2'
      //   Constant: '<S513>/Constant4'
      //   Constant: '<S519>/Constant'
      //   DataStoreRead: '<S513>/Data Store Read'
      //   DataTypeConversion: '<S513>/Data Type Conversion1'
      //   Gain: '<S513>/Gain'
      //   Logic: '<S513>/Logical Operator'
      //   Product: '<S513>/Product'
      //   RelationalOperator: '<S519>/Compare'
      //   Sum: '<S513>/Sum1'

      if (!(((int32_T)eeMirror.deluxe_G5 != 0) &&
            (CONSTANT_DATA->OFFSET_DLX_ADJ_FUNCTION != NON_FUNCTIONAL))) {
        rtb_Switch_jh5g = rtb_Offset_Table;
      } else {
        // Sum: '<S513>/Sum' incorporates:
        //   Constant: '<S513>/Constant4'
        //   DataTypeConversion: '<S513>/Data Type Conversion'

        rtb_Saturation = (int16_T)(int32_T)((int32_T)((int32_T)(int16_T)
          rtb_Offset_Table - (int32_T)CONSTANT_DATA->OFFSET_CRACKPOINT_CURRENT) >>
          1);

        // Saturate: '<S513>/Saturation'
        if ((int32_T)rtb_Saturation > (int32_T)4096) {
          rtb_Saturation = 4096;
        } else {
          if ((int32_T)rtb_Saturation < (int32_T)0) {
            rtb_Saturation = 0;
          }
        }

        // End of Saturate: '<S513>/Saturation'
        rtb_Switch_jh5g = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)
          CONSTANT_DATA->OFFSET_CRACKPOINT_CURRENT << 4) + (uint32_T)(uint16_T)
          (uint32_T)((uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
          rtb_Saturation << 1) * (uint32_T)(uint16_T)(uint32_T)((uint32_T)
          ((uint32_T)((uint16_T)41943U) * (uint32_T)flow_OffsetPercent) >> 6)) >>
                     12)) >> 4);
      }

      // End of Switch: '<S513>/Switch1'
    } else {
      // Lookup: '<S512>/Aux2Flow_Table'
      //
      //  About '<S512>/Aux2Flow_Table':
      //  Input0  Data Type:  Integer        U16
      //  Output0 Data Type:  Fixed Point    U16  2^-16
      //  Saturation Mode: Saturate
      //  Lookup Method: Linear_Endpoint
      //
      //  XData is inlined and evenly spaced, so the algorithm only needs
      //  the value of the first element, the last element, and the spacing.
      //  For efficiency, XData is excluded from the generated code.
      //  YData parameter uses the same data type and scaling as Output0

      LookUpEven_U16_U16_SAT( &(rtb_Aux2Flow_Table), (&(MXGTW_AUX2_FLOW[0])),
        rtb_position_Pot_jbn4, 0U, 100U, 10U);

      // Switch: '<S512>/Switch' incorporates:
      //   Constant: '<S516>/Constant1'
      //   Constant: '<S516>/Constant10'
      //   Constant: '<S516>/Constant6'
      //   Constant: '<S517>/Constant'
      //   Constant: '<S518>/Constant'
      //   DataStoreRead: '<S512>/Data Store Read'
      //   Gain: '<S512>/Gain'
      //   RelationalOperator: '<S517>/Compare'
      //   RelationalOperator: '<S518>/Compare'
      //   Switch: '<S516>/Switch'
      //   Switch: '<S516>/Switch1'

      if ((int32_T)eeMirror.deluxe_G5 != 0) {
        rtb_Switch_jh5g = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint16_T)
          41943U) * (uint32_T)flow_Aux2Percent) >> 6);
      } else if (CONSTANT_DATA->AUX2_FLOW_LOW_FUNCTION != NON_FUNCTIONAL) {
        // Switch: '<S516>/Switch' incorporates:
        //   Constant: '<S516>/Constant8'

        rtb_Switch_jh5g = CONSTANT_DATA->AUX2_LOW_FLOW_PERCENT;
      } else if (CONSTANT_DATA->AUX2_FLOW_MED_FUNCTION != NON_FUNCTIONAL) {
        // Switch: '<S516>/Switch1' incorporates:
        //   Constant: '<S516>/Constant9'
        //   Switch: '<S516>/Switch'

        rtb_Switch_jh5g = CONSTANT_DATA->AUX2_MED_FLOW_PERCENT;
      } else {
        rtb_Switch_jh5g = CONSTANT_DATA->AUX2_HI_FLOW_PERCENT;
      }

      // End of Switch: '<S512>/Switch'

      // Product: '<S512>/Product' incorporates:
      //   Lookup: '<S512>/Aux2Flow_Table'

      rtb_Product_km1l = (uint16_T)(uint32_T)((uint32_T)((uint32_T)
        rtb_Aux2Flow_Table * (uint32_T)rtb_Switch_jh5g) >> 16);

      // Switch: '<S512>/Switch1' incorporates:
      //   Constant: '<S512>/Constant6'

      if (rtb_Product_km1l > ((uint16_T)0U)) {
        // SignalConversion: '<S512>/TmpSignal ConversionAtCurrent vs Flow CmdInport3' incorporates:
        //   Constant: '<S512>/Constant4'
        //   Constant: '<S512>/Constant5'

        rtb_TmpSignalConversionAtCurren[0] =
          CONSTANT_DATA->AUX2_CRACKPOINT_CURRENT;
        rtb_TmpSignalConversionAtCurren[1] =
          CONSTANT_DATA->AUX2_MAX_FLOW_CURRENT;

        // SignalConversion: '<S512>/TmpSignal ConversionAtCurrent vs Flow CmdInport2' incorporates:
        //   Constant: '<S512>/Constant2'
        //   Constant: '<S512>/Constant3'

        rtb_TmpSignalConversionAtC_bbzb[0] = ((uint16_T)0U);
        rtb_TmpSignalConversionAtC_bbzb[1] = ((uint16_T)65535U);

        // S-Function (sfix_look1_dyn): '<S512>/Current vs Flow Cmd'
        // Dynamic Look-Up Table Block: '<S512>/Current vs Flow Cmd'
        //  Input0  Data Type:  Fixed Point    U16  2^-16
        //  Input1  Data Type:  Fixed Point    U16  2^-16
        //  Input2  Data Type:  Fixed Point    U16  2^-12
        //  Output0 Data Type:  Fixed Point    U16  2^-12
        //  Lookup Method: Linear_Endpoint
        //

        LookUp_U16_U16( &(rtb_CurrentvsFlowCmd),
                       &rtb_TmpSignalConversionAtCurren[0], rtb_Product_km1l,
                       &rtb_TmpSignalConversionAtC_bbzb[0], 1U);
        rtb_Switch_jh5g = rtb_CurrentvsFlowCmd;
      } else {
        rtb_Switch_jh5g = (uint16_T)(int32_T)(uint32_T)((uint32_T)((uint16_T)0U)
          >> 4);
      }

      // End of Switch: '<S512>/Switch1'
    }

    // End of Switch: '<S507>/Switch'

    // Chart: '<S507>/Commands'
    // Gateway: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
    // During: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
    if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c33_MX_Gateway == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
      MX_Gateway_DWork.bitsForTID1.is_active_c33_MX_Gateway = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
      // Transition: '<S508>:63'
      MX_Gateway_DWork.bitsForTID1.is_c33_MX_Gateway =
        MX_Gateway_IN_Inactive_cx3o;

      // Entry 'Inactive': '<S508>:24'
      MX_Gateway_B.icmd_Base = 0U;
      MX_Gateway_B.icmd_Rod = 0U;
    } else if (MX_Gateway_DWork.bitsForTID1.is_c33_MX_Gateway ==
               MX_Gateway_IN_Active_f4bs) {
      // During 'Active': '<S508>:3'
      if ((state_Console != ACTIVE) || (state_Engine == ENGINE_CRANKING) ||
          ((state_Diverter != ACTIVE) && (state_Diverter != INACTIVE))) {
        // Transition: '<S508>:72'
        // Exit Internal 'Active': '<S508>:3'
        MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
          MX_Gate_IN_NO_ACTIVE_CHILD_ik2b;
        MX_Gateway_DWork.bitsForTID1.is_c33_MX_Gateway =
          MX_Gateway_IN_Inactive_cx3o;

        // Entry 'Inactive': '<S508>:24'
        MX_Gateway_B.icmd_Base = 0U;
        MX_Gateway_B.icmd_Rod = 0U;
      } else {
        switch (MX_Gateway_DWork.bitsForTID1.is_Active_k0x2) {
         case MX_Gateway_IN_BaseActive:
          // During 'BaseActive': '<S508>:25'
          if ((rtb_state_Pot != BASE_ACTIVE) && (rtb_state_Pot != ROD_ACTIVE)) {
            // Transition: '<S508>:66'
            MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
              MX_Gateway_IN_Neutral_nhy3;

            // Entry 'Neutral': '<S508>:27'
            MX_Gateway_B.icmd_Base = 0U;
            MX_Gateway_B.icmd_Rod = 0U;
          } else if (rtb_state_Pot == ROD_ACTIVE) {
            // Transition: '<S508>:68'
            MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
              MX_Gateway_IN_RodActive;

            // Entry 'RodActive': '<S508>:26'
            MX_Gateway_B.icmd_Base = 0U;
            MX_Gateway_B.icmd_Rod = rtb_Switch_jh5g;
          } else {
            MX_Gateway_B.icmd_Base = rtb_Switch_jh5g;
          }
          break;

         case MX_Gateway_IN_Neutral_nhy3:
          // During 'Neutral': '<S508>:27'
          if (rtb_state_Pot == ROD_ACTIVE) {
            // Transition: '<S508>:64'
            MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
              MX_Gateway_IN_RodActive;

            // Entry 'RodActive': '<S508>:26'
            MX_Gateway_B.icmd_Base = 0U;
            MX_Gateway_B.icmd_Rod = rtb_Switch_jh5g;
          } else {
            if (rtb_state_Pot == BASE_ACTIVE) {
              // Transition: '<S508>:67'
              MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
                MX_Gateway_IN_BaseActive;

              // Entry 'BaseActive': '<S508>:25'
              MX_Gateway_B.icmd_Rod = 0U;
              MX_Gateway_B.icmd_Base = rtb_Switch_jh5g;
            }
          }
          break;

         default:
          // During 'RodActive': '<S508>:26'
          if ((rtb_state_Pot != BASE_ACTIVE) && (rtb_state_Pot != ROD_ACTIVE)) {
            // Transition: '<S508>:65'
            MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
              MX_Gateway_IN_Neutral_nhy3;

            // Entry 'Neutral': '<S508>:27'
            MX_Gateway_B.icmd_Base = 0U;
            MX_Gateway_B.icmd_Rod = 0U;
          } else if (rtb_state_Pot == BASE_ACTIVE) {
            // Transition: '<S508>:69'
            MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 =
              MX_Gateway_IN_BaseActive;

            // Entry 'BaseActive': '<S508>:25'
            MX_Gateway_B.icmd_Rod = 0U;
            MX_Gateway_B.icmd_Base = rtb_Switch_jh5g;
          } else {
            MX_Gateway_B.icmd_Rod = rtb_Switch_jh5g;
          }
          break;
        }
      }
    } else {
      // During 'Inactive': '<S508>:24'
      if ((state_Console == ACTIVE) && (state_Engine != ENGINE_CRANKING) &&
          ((state_Diverter == ACTIVE) || (state_Diverter == INACTIVE))) {
        // Transition: '<S508>:71'
        MX_Gateway_DWork.bitsForTID1.is_c33_MX_Gateway =
          MX_Gateway_IN_Active_f4bs;

        // Entry Internal 'Active': '<S508>:3'
        // Transition: '<S508>:70'
        MX_Gateway_DWork.bitsForTID1.is_Active_k0x2 = MX_Gateway_IN_Neutral_nhy3;

        // Entry 'Neutral': '<S508>:27'
        MX_Gateway_B.icmd_Base = 0U;
        MX_Gateway_B.icmd_Rod = 0U;
      }
    }

    // End of Chart: '<S507>/Commands'

    // RelationalOperator: '<S509>/Compare' incorporates:
    //   Constant: '<S509>/Constant'

    rtb_Compare_ajov = (state_Console != ACTIVE);

    // Outputs for Atomic SubSystem: '<S507>/hc_pair_control'
    MX_Gatew_output_pair_ClosedLoop(MX_Gateway_B.icmd_Base, rtb_Compare_ajov,
      afbk_OffsetBase, ifbk_OffsetBase, MX_Gateway_B.RateTransition4_i0so,
      state_Engine, MX_Gateway_B.RateTransition5_lpr2, ain_PrecisionReference,
      &MX_Gateway_B.hs_cmd_pjid, &MX_Gateway_B.ls_cmd_ifxm,
      &MX_Gateway_B.error_dmed, &calc_ifbk_OffsetBase,
      &MX_Gateway_B.state_Output_lu5e, &MX_Gateway_B.hc_pair_control_lgu5,
      &MX_Gateway_DWork.hc_pair_control_lgu5,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->OFFSET_KP,
      CONSTANT_DATA->OFFSET_KI, CONSTANT_DATA->OFFSET_OVERCURRENT,
      CONSTANT_DATA->OFFSET_NON_ZERO_DUTY,
      CONSTANT_DATA->OFFSET_NON_ZERO_CURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->OFFSET_BIDIRECTIONAL_CONTROL,
      CONSTANT_DATA->OFFSET_AFBK_GAIN, CONSTANT_DATA->OFFSET_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S507>/hc_pair_control'

    // SignalConversion: '<S507>/OutportBufferForerrorCC_OffsetBase'
    errorCC_OffsetBase = MX_Gateway_B.error_dmed;

    // Outputs for Atomic SubSystem: '<S507>/hc_pair_control1'
    MX_Gatew_output_pair_ClosedLoop(MX_Gateway_B.icmd_Rod, rtb_Compare_ajov,
      afbk_OffsetRod, ifbk_OffsetRod, MX_Gateway_B.RateTransition4_i0so,
      state_Engine, MX_Gateway_B.RateTransition5_lpr2, ain_PrecisionReference,
      &MX_Gateway_B.hs_cmd, &MX_Gateway_B.ls_cmd, &MX_Gateway_B.error,
      &calc_ifbk_OffsetRod, &MX_Gateway_B.state_Output_fskg,
      &MX_Gateway_B.hc_pair_control1_cc44,
      &MX_Gateway_DWork.hc_pair_control1_cc44,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->OFFSET_KP,
      CONSTANT_DATA->OFFSET_KI, CONSTANT_DATA->OFFSET_OVERCURRENT,
      CONSTANT_DATA->OFFSET_NON_ZERO_DUTY,
      CONSTANT_DATA->OFFSET_NON_ZERO_CURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->OFFSET_BIDIRECTIONAL_CONTROL,
      CONSTANT_DATA->OFFSET_AFBK_GAIN, CONSTANT_DATA->OFFSET_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S507>/hc_pair_control1'

    // SignalConversion: '<S507>/OutportBufferForerrorCC_OffsetRod'
    errorCC_OffsetRod = MX_Gateway_B.error;

    // SignalConversion: '<S507>/OutportBufferForhs_OffsetBase'
    hs_OffsetBase = MX_Gateway_B.hs_cmd_pjid;

    // SignalConversion: '<S507>/OutportBufferForhs_OffsetRod'
    hs_OffsetRod = MX_Gateway_B.hs_cmd;

    // SignalConversion: '<S507>/OutportBufferForls_OffsetBase'
    ls_OffsetBase = MX_Gateway_B.ls_cmd_ifxm;

    // SignalConversion: '<S507>/OutportBufferForls_OffsetRod'
    ls_OffsetRod = MX_Gateway_B.ls_cmd;

    // SignalConversion: '<S507>/OutportBufferForstate_OffsetBase'
    state_OffsetBase = MX_Gateway_B.state_Output_lu5e;

    // SignalConversion: '<S507>/OutportBufferForstate_OffsetRod'
    state_OffsetRod = MX_Gateway_B.state_Output_fskg;
  } else {
    if (MX_Gateway_DWork.Offset_MODE) {
      // Disable for Atomic SubSystem: '<S507>/hc_pair_control'
      output_pair_ClosedLoop_Disable(&MX_Gateway_B.error_dmed,
        &MX_Gateway_B.hc_pair_control_lgu5,
        &MX_Gateway_DWork.hc_pair_control_lgu5);

      // End of Disable for SubSystem: '<S507>/hc_pair_control'

      // Disable for Atomic SubSystem: '<S507>/hc_pair_control1'
      output_pair_ClosedLoop_Disable(&MX_Gateway_B.error,
        &MX_Gateway_B.hc_pair_control1_cc44,
        &MX_Gateway_DWork.hc_pair_control1_cc44);

      // End of Disable for SubSystem: '<S507>/hc_pair_control1'

      // Disable for Outport: '<S507>/hs_OffsetBase'
      hs_OffsetBase = ((uint16_T)0U);

      // Disable for Outport: '<S507>/ls_OffsetBase'
      ls_OffsetBase = false;

      // Disable for Outport: '<S507>/errorCC_OffsetBase'
      errorCC_OffsetBase = 0;

      // Disable for Outport: '<S507>/calc_ifbk_OffsetBase'
      calc_ifbk_OffsetBase = ((uint16_T)0U);

      // Disable for Outport: '<S507>/state_OffsetBase'
      state_OffsetBase = ((uint8_T)0U);

      // Disable for Outport: '<S507>/hs_OffsetRod'
      hs_OffsetRod = ((uint16_T)0U);

      // Disable for Outport: '<S507>/ls_OffsetRod'
      ls_OffsetRod = false;

      // Disable for Outport: '<S507>/errorCC_OffsetRod'
      errorCC_OffsetRod = 0;

      // Disable for Outport: '<S507>/calc_ifbk_OffsetRod'
      calc_ifbk_OffsetRod = ((uint16_T)0U);
      MX_Gateway_DWork.Offset_MODE = false;
    }
  }

  // End of Logic: '<S315>/Logical Operator'
  // End of Outputs for SubSystem: '<S315>/Offset'
}

// System initialize for atomic system: '<S26>/PB_Valve'
void MX_Gateway_PB_Valve_Init(void)
{
  // InitializeConditions for UnitDelay: '<S316>/Unit Delay3'
  MX_Gateway_DWork.UnitDelay3_DSTATE_h0lf = NORMAL;

  // InitializeConditions for UnitDelay: '<S316>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_enrc = NORMAL;

  // Chart: '<S316>/PBValve'
  // Entry: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  // Entry Internal: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  // Transition: '<S559>:10'
  MX_Gateway_DWork.bitsForTID2.is_c40_MX_Gateway = MX_Gateway_IN_INACTIVE_h2aq;

  // Entry 'INACTIVE': '<S559>:1'
  dout_PBValve = ((int32_T)INACTIVE != 0);

  // SystemInitialize for Enabled SubSystem: '<S316>/dout_chk'
  MX_Gateway_dout_chk_Init(&MX_Gateway_B.OutportBufferForstate,
    &MX_Gateway_B.dout_chk_k45l, &MX_Gateway_DWork.dout_chk_k45l);

  // End of SystemInitialize for SubSystem: '<S316>/dout_chk'

  // SystemInitialize for Enabled SubSystem: '<S316>/relay_oc'
  MX_Gateway_relay_oc_Init(&MX_Gateway_B.state_Output_idoi, &state_PBValveRelay,
    &MX_Gateway_B.relay_oc_mc2f, &MX_Gateway_DWork.relay_oc_mc2f);

  // End of SystemInitialize for SubSystem: '<S316>/relay_oc'
}

// Output and update for atomic system: '<S26>/PB_Valve'
void MX_Gateway_PB_Valve(void)
{
  boolean_T rtb_LogicalOperator1_io14;
  boolean_T Compare_lv2j;
  boolean_T rtb_HiddenBuf_InsertedFor_relay;
  boolean_T rtb_ErrorDetectionEnable;

  // RelationalOperator: '<S554>/Compare' incorporates:
  //   Constant: '<S554>/Constant'

  Compare_lv2j = (MX_Gateway_B.RateTransition37_bstc > ((uint16_T)512U));

  // Logic: '<S316>/Logical Operator1' incorporates:
  //   Constant: '<S316>/Light1FeedbackState1'
  //   Constant: '<S557>/Constant'
  //   Constant: '<S558>/Constant'
  //   RelationalOperator: '<S557>/Compare'
  //   RelationalOperator: '<S558>/Compare'

  rtb_LogicalOperator1_io14 = ((CONSTANT_DATA->PBVALVE_RELAY_FEEDBACK_FUNCTION
    != NON_FUNCTIONAL) && (state_VBattery != OORL));

  // SignalConversion: '<S316>/HiddenBuf_InsertedFor_relay_oc_at_inport_3'
  rtb_HiddenBuf_InsertedFor_relay = rtb_LogicalOperator1_io14;

  // Logic: '<S316>/Logical Operator2' incorporates:
  //   Constant: '<S316>/Light1FeedbackState'
  //   Constant: '<S555>/Constant'
  //   Constant: '<S556>/Constant'
  //   RelationalOperator: '<S555>/Compare'
  //   RelationalOperator: '<S556>/Compare'

  rtb_ErrorDetectionEnable = ((CONSTANT_DATA->PBVALVE_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // Chart: '<S316>/PBValve' incorporates:
  //   UnitDelay: '<S316>/Unit Delay1'
  //   UnitDelay: '<S316>/Unit Delay3'

  // Gateway: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  // During: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  if (MX_Gateway_DWork.bitsForTID2.is_c40_MX_Gateway ==
      MX_Gateway_IN_ACTIVE_ftsh) {
    // During 'ACTIVE': '<S559>:2'
    if ((((MX_Gateway_B.RateTransition38_cu5w != AUX_FLOW_HIGH) ||
          (MX_Gateway_B.RateTransition39_gsng == INACTIVE)) && (Compare_lv2j ==
          (int32_T)INACTIVE)) || (MX_Gateway_DWork.UnitDelay3_DSTATE_h0lf !=
         NORMAL) || (MX_Gateway_DWork.UnitDelay1_DSTATE_enrc != NORMAL)) {
      // Transition: '<S559>:14'
      MX_Gateway_DWork.bitsForTID2.is_c40_MX_Gateway =
        MX_Gateway_IN_INACTIVE_h2aq;

      // Entry 'INACTIVE': '<S559>:1'
      dout_PBValve = ((int32_T)INACTIVE != 0);
    }
  } else {
    // During 'INACTIVE': '<S559>:1'
    if ((CONSTANT_DATA->PBVALVE_FUNCTION != NON_FUNCTIONAL) &&
        (((MX_Gateway_B.RateTransition38_cu5w == AUX_FLOW_HIGH) &&
          (MX_Gateway_B.RateTransition39_gsng == ACTIVE)) || (Compare_lv2j ==
          (int32_T)ACTIVE)) && (MX_Gateway_DWork.UnitDelay3_DSTATE_h0lf ==
         NORMAL) && (MX_Gateway_DWork.UnitDelay1_DSTATE_enrc == NORMAL)) {
      // Transition: '<S559>:8'
      MX_Gateway_DWork.bitsForTID2.is_c40_MX_Gateway = MX_Gateway_IN_ACTIVE_ftsh;

      // Entry 'ACTIVE': '<S559>:2'
      dout_PBValve = ((int32_T)ACTIVE != 0);
    }
  }

  // End of Chart: '<S316>/PBValve'

  // Outputs for Enabled SubSystem: '<S316>/dout_chk'
  MX_Gateway_dout_chk(rtb_ErrorDetectionEnable, dout_PBValve,
                      MX_Gateway_B.RateTransition32_dkx3,
                      &MX_Gateway_B.OutportBufferForstate,
                      &MX_Gateway_B.dout_chk_k45l,
                      &MX_Gateway_DWork.dout_chk_k45l,
                      CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S316>/dout_chk'

  // Outputs for Enabled SubSystem: '<S316>/relay_oc'
  MX_Gateway_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_PBValve,
                      MX_Gateway_B.RateTransition32_dkx3,
                      MX_Gateway_B.RateTransition35_gogg,
                      &MX_Gateway_B.state_Output_idoi, &state_PBValveRelay,
                      &MX_Gateway_B.relay_oc_mc2f,
                      &MX_Gateway_DWork.relay_oc_mc2f,
                      CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_ON,
                      CONSTANT_DATA->PBVALVE_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S316>/relay_oc'

  // Switch: '<S316>/Switch' incorporates:
  //   Logic: '<S316>/Logical Operator3'

  if (!rtb_LogicalOperator1_io14) {
    state_PBValveOutput = MX_Gateway_B.OutportBufferForstate;
  } else {
    state_PBValveOutput = MX_Gateway_B.state_Output_idoi;
  }

  // End of Switch: '<S316>/Switch'

  // Update for UnitDelay: '<S316>/Unit Delay3'
  MX_Gateway_DWork.UnitDelay3_DSTATE_h0lf = state_PBValveOutput;

  // Update for UnitDelay: '<S316>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_enrc = state_PBValveRelay;
}

// System initialize for atomic system: '<S26>/Starter'
void MX_Gateway_Starter_Init(void)
{
  // InitializeConditions for UnitDelay: '<S317>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE_eduf = ((uint8_T)8U);

  // InitializeConditions for UnitDelay: '<S317>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_jgsb = ((uint8_T)8U);

  // SystemInitialize for Chart: '<S317>/Starter'
  MX_Gateway_DWork.bitsForTID1.is_AUTOMATED = MX_Gate_IN_NO_ACTIVE_CHILD_fajt;
  MX_Gateway_DWork.bitsForTID1.is_MANUAL = MX_Gate_IN_NO_ACTIVE_CHILD_fajt;
  MX_Gateway_DWork.bitsForTID1.is_active_c64_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c64_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_fajt;
  MX_Gateway_DWork.debounceAuto = 0U;
  dout_Starter = false;

  // SystemInitialize for Enabled SubSystem: '<S317>/relay_oc'
  MX_Gateway_relay_oc_Init(&state_StarterOutput, &state_StarterRelay,
    &MX_Gateway_B.relay_oc_n5e3, &MX_Gateway_DWork.relay_oc_n5e3);

  // End of SystemInitialize for SubSystem: '<S317>/relay_oc'
}

// Output and update for atomic system: '<S26>/Starter'
void MX_Gateway_Starter(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;

  // SignalConversion: '<S317>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S317>/FunctionState'
  //   Constant: '<S564>/Constant'
  //   Constant: '<S565>/Constant'
  //   Logic: '<S317>/Logical Operator1'
  //   RelationalOperator: '<S564>/Compare'
  //   RelationalOperator: '<S565>/Compare'

  rtb_HiddenBuf_InsertedFor_relay = ((CONSTANT_DATA->STARTER_FEEDBACK_FUNCTION
    != NON_FUNCTIONAL) && (MX_Gateway_B.RateTransition20_arnl != OORL));

  // Lookup: '<S317>/Starter_Engage_RPM'
  //
  //  About '<S317>/Starter_Engage_RPM':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Below
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;
    BINARYSEARCH_U16_iL( &(iLeft), ecu_EOT, (&(MXGTW_STARTER_AUTOMATED_OIL_TEMP
      [0])), 9U);
    level_StarterAutomatedEngage =
      MXGTW_STARTER_AUTOMATED_RPM_ENGAGE_LEVEL[iLeft];
  }

  // Lookup: '<S317>/Starter_Disenage_RPM'
  //
  //  About '<S317>/Starter_Disenage_RPM':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Below
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;
    BINARYSEARCH_U16_iL( &(iLeft), ecu_EOT, (&(MXGTW_STARTER_AUTOMATED_OIL_TEMP
      [0])), 9U);
    level_StarterAutomatedDisengage =
      MXGTW_STARTER_AUTOMATED_RPM_DISENGAGE_LEVEL[iLeft];
  }

  // Lookup: '<S317>/Starter_Max_Time'
  //
  //  About '<S317>/Starter_Max_Time':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Below
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;
    BINARYSEARCH_U16_iL( &(iLeft), ecu_EOT, (&(MXGTW_STARTER_AUTOMATED_OIL_TEMP
      [0])), 9U);
    time_StarterAutomated = MXGTW_STARTER_AUTOMATED_MAX_TIME[iLeft];
  }

  // Chart: '<S317>/Starter' incorporates:
  //   UnitDelay: '<S317>/Unit Delay'
  //   UnitDelay: '<S317>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/Starter/Starter
  // During: MX_Gtwy_Control/Outputs/Starter/Starter
  if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c64_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/Starter/Starter
    MX_Gateway_DWork.bitsForTID1.is_active_c64_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Starter/Starter
    // Transition: '<S566>:32'
    MX_Gateway_DWork.bitsForTID1.is_c64_MX_Gateway =
      MX_Gatew_IN_NON_FUNCTIONAL_gcn1;

    // Entry 'NON_FUNCTIONAL': '<S566>:30'
    dout_Starter = ((int32_T)INACTIVE != 0);
  } else {
    switch (MX_Gateway_DWork.bitsForTID1.is_c64_MX_Gateway) {
     case MX_Gateway_IN_AUTOMATED:
      // During 'AUTOMATED': '<S566>:34'
      switch (MX_Gateway_DWork.bitsForTID1.is_AUTOMATED) {
       case MX_Gateway_IN_ACTIVE_bwmt:
        // During 'ACTIVE': '<S566>:35'
        if ((state_Engine != ENGINE_CRANKING) ||
            (MX_Gateway_B.RateTransition20_arnl == OORL) || (error_FuelSec !=
             NORMAL) || (state_FuelPriOutput != NORMAL) || (state_FuelPriRelay
             != NORMAL)) {
          // Transition: '<S566>:37'
          MX_Gateway_DWork.bitsForTID1.is_AUTOMATED =
            MX_Gateway_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S566>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          if (flt_EngineSpeed >= level_StarterAutomatedEngage) {
            // Transition: '<S566>:44'
            MX_Gateway_DWork.bitsForTID1.is_AUTOMATED =
              MX_Gateway_IN_DEBOUNCE_FOR_AUTO;

            // Entry 'DEBOUNCE_FOR_AUTO': '<S566>:43'
            dout_Starter = ((int32_T)ACTIVE != 0);
            MX_Gateway_DWork.debounceAuto = 0U;
          }
        }
        break;

       case MX_Gateway_IN_AUTOMATED_START:
        // During 'AUTOMATED_START': '<S566>:45'
        if ((flt_EngineSpeed >= level_StarterAutomatedDisengage) ||
            (MX_Gateway_DWork.debounceAuto >= time_StarterAutomated) ||
            (MX_Gateway_B.RateTransition20_arnl == OORL) || (error_FuelSec !=
             NORMAL) || (state_FuelPriOutput != NORMAL) || (state_FuelPriRelay
             != NORMAL)) {
          // Transition: '<S566>:48'
          MX_Gateway_DWork.bitsForTID1.is_AUTOMATED =
            MX_Gateway_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S566>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          MX_Gateway_DWork.debounceAuto = (uint16_T)(int32_T)((int32_T)
            MX_Gateway_DWork.debounceAuto + 1);
        }
        break;

       case MX_Gateway_IN_DEBOUNCE_FOR_AUTO:
        // During 'DEBOUNCE_FOR_AUTO': '<S566>:43'
        if (MX_Gateway_DWork.debounceAuto >=
            CONSTANT_DATA->STARTER_AUTOMATED_DEBOUNCE_ACTIVATE) {
          // Transition: '<S566>:46'
          MX_Gateway_DWork.bitsForTID1.is_AUTOMATED =
            MX_Gateway_IN_AUTOMATED_START;

          // Entry 'AUTOMATED_START': '<S566>:45'
          dout_Starter = ((int32_T)ACTIVE != 0);
          MX_Gateway_DWork.debounceAuto = 0U;
        } else if ((state_Engine != ENGINE_CRANKING) ||
                   (MX_Gateway_B.RateTransition20_arnl == OORL) ||
                   (error_FuelSec != NORMAL) || (state_FuelPriOutput != NORMAL) ||
                   (state_FuelPriRelay != NORMAL)) {
          // Transition: '<S566>:51'
          MX_Gateway_DWork.bitsForTID1.is_AUTOMATED =
            MX_Gateway_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S566>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          MX_Gateway_DWork.debounceAuto = (uint16_T)(int32_T)((int32_T)
            MX_Gateway_DWork.debounceAuto + 1);
        }
        break;

       default:
        // During 'INACTIVE': '<S566>:38'
        if ((state_Engine == ENGINE_CRANKING) &&
            (MX_Gateway_B.RateTransition20_arnl != OORL) &&
            (MX_Gateway_DWork.UnitDelay_DSTATE_eduf != ERROR_ON) &&
            (MX_Gateway_DWork.UnitDelay1_DSTATE_jgsb != ERROR_ON) &&
            (error_FuelSec == NORMAL) && (state_FuelPriOutput == NORMAL) &&
            (state_FuelPriRelay == NORMAL)) {
          // Transition: '<S566>:36'
          MX_Gateway_DWork.bitsForTID1.is_AUTOMATED = MX_Gateway_IN_ACTIVE_bwmt;

          // Entry 'ACTIVE': '<S566>:35'
          dout_Starter = ((int32_T)ACTIVE != 0);
        }
        break;
      }
      break;

     case MX_Gateway_IN_MANUAL:
      // During 'MANUAL': '<S566>:31'
      if (MX_Gateway_DWork.bitsForTID1.is_MANUAL == MX_Gateway_IN_ACTIVE_bwmt) {
        // During 'ACTIVE': '<S566>:2'
        if ((state_Engine != ENGINE_CRANKING) ||
            (MX_Gateway_B.RateTransition20_arnl == OORL) || (error_FuelSec !=
             NORMAL) || (state_FuelPriOutput != NORMAL) || (state_FuelPriRelay
             != NORMAL)) {
          // Transition: '<S566>:6'
          MX_Gateway_DWork.bitsForTID1.is_MANUAL = MX_Gateway_IN_INACTIVE_h31q;

          // Entry 'INACTIVE': '<S566>:1'
          dout_Starter = ((int32_T)INACTIVE != 0);
        }
      } else {
        // During 'INACTIVE': '<S566>:1'
        if ((state_Engine == ENGINE_CRANKING) &&
            (MX_Gateway_B.RateTransition20_arnl != OORL) &&
            (MX_Gateway_DWork.UnitDelay_DSTATE_eduf != ERROR_ON) &&
            (MX_Gateway_DWork.UnitDelay1_DSTATE_jgsb != ERROR_ON) &&
            (error_FuelSec == NORMAL) && (state_FuelPriOutput == NORMAL) &&
            (state_FuelPriRelay == NORMAL)) {
          // Transition: '<S566>:5'
          MX_Gateway_DWork.bitsForTID1.is_MANUAL = MX_Gateway_IN_ACTIVE_bwmt;

          // Entry 'ACTIVE': '<S566>:2'
          dout_Starter = ((int32_T)ACTIVE != 0);
        }
      }
      break;

     default:
      // During 'NON_FUNCTIONAL': '<S566>:30'
      if (CONSTANT_DATA->STARTER_FUNCTION != NON_FUNCTIONAL) {
        // Transition: '<S566>:40'
        if (CONSTANT_DATA->STARTER_AUTOMATED_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S566>:42'
          MX_Gateway_DWork.bitsForTID1.is_c64_MX_Gateway =
            MX_Gateway_IN_AUTOMATED;

          // Entry Internal 'AUTOMATED': '<S566>:34'
          // Transition: '<S566>:33'
          MX_Gateway_DWork.bitsForTID1.is_AUTOMATED =
            MX_Gateway_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S566>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          // Transition: '<S566>:41'
          MX_Gateway_DWork.bitsForTID1.is_c64_MX_Gateway = MX_Gateway_IN_MANUAL;

          // Entry Internal 'MANUAL': '<S566>:31'
          // Transition: '<S566>:4'
          MX_Gateway_DWork.bitsForTID1.is_MANUAL = MX_Gateway_IN_INACTIVE_h31q;

          // Entry 'INACTIVE': '<S566>:1'
          dout_Starter = ((int32_T)INACTIVE != 0);
        }
      }
      break;
    }
  }

  // End of Chart: '<S317>/Starter'

  // Outputs for Enabled SubSystem: '<S317>/relay_oc'
  MX_Gateway_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_Starter,
                      dfbk_StarterOutput, din_StarterRelay, &state_StarterOutput,
                      &state_StarterRelay, &MX_Gateway_B.relay_oc_n5e3,
                      &MX_Gateway_DWork.relay_oc_n5e3,
                      CONSTANT_DATA->STARTER_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->STARTER_DEBOUNCE_ERROR_ON,
                      CONSTANT_DATA->STARTER_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S317>/relay_oc'

  // Update for UnitDelay: '<S317>/Unit Delay'
  MX_Gateway_DWork.UnitDelay_DSTATE_eduf = state_StarterOutput;

  // Update for UnitDelay: '<S317>/Unit Delay1'
  MX_Gateway_DWork.UnitDelay1_DSTATE_jgsb = state_StarterRelay;
}

// System initialize for atomic system: '<S26>/SwitchedPower'
void MX_Gateway_SwitchedPower_Init(void)
{
  // SystemInitialize for Chart: '<S319>/Relay'
  MX_Gateway_DWork.bitsForTID1.is_active_c50_MX_Gateway = 0U;
  MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway =
    MX_Gate_IN_NO_ACTIVE_CHILD_liu3;
  MX_Gateway_DWork.debounceCount_kmuu = 0U;
  dout_SwitchedPwr = false;

  // SystemInitialize for Enabled SubSystem: '<S319>/relay_oc'
  MX_Gateway_relay_oc_Init(&state_SwitchedPwrOutput, &state_SwitchedPwrRelay,
    &MX_Gateway_B.relay_oc_icgt, &MX_Gateway_DWork.relay_oc_icgt);

  // End of SystemInitialize for SubSystem: '<S319>/relay_oc'
}

// Output and update for atomic system: '<S26>/SwitchedPower'
void MX_Gateway_SwitchedPower(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;

  // SignalConversion: '<S319>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S319>/Constant'
  //   Constant: '<S570>/Constant'
  //   Constant: '<S571>/Constant'
  //   Constant: '<S572>/Constant'
  //   Logic: '<S319>/Logical Operator'
  //   RelationalOperator: '<S570>/Compare'
  //   RelationalOperator: '<S571>/Compare'
  //   RelationalOperator: '<S572>/Compare'

  rtb_HiddenBuf_InsertedFor_relay =
    ((CONSTANT_DATA->SWITCHED_POWER_RELAY_FEEDBACK_FUNCTION != NON_FUNCTIONAL) &&
     (MX_Gateway_B.RateTransition14_b2gt != OORL) && (state_System !=
      SYS_POWER_DOWN));

  // Chart: '<S319>/Relay'
  // Gateway: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
  // During: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
  if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c50_MX_Gateway == 0U) {
    // Entry: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
    MX_Gateway_DWork.bitsForTID1.is_active_c50_MX_Gateway = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
    // Transition: '<S573>:7'
    MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway = MX_Gateway_IN_INACTIVE_bo51;

    // Entry 'INACTIVE': '<S573>:1'
    dout_SwitchedPwr = ((int32_T)INACTIVE != 0);
  } else {
    switch (MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway) {
     case MX_Gateway_IN_ACTIVE_ftye:
      // During 'ACTIVE': '<S573>:2'
      if ((state_System == SYS_POWER_DOWN) || ((state_System == SYS_LIMITED) &&
           (state_Key == INACTIVE))) {
        // Transition: '<S573>:9'
        MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway = MX_Gateway_IN_DELAY_OFF;

        // Entry 'DELAY_OFF': '<S573>:5'
        MX_Gateway_DWork.debounceCount_kmuu = 0U;
      }
      break;

     case MX_G_IN_DEBOUNCE_ERROR_ON_CHECK:
      // During 'DEBOUNCE_ERROR_ON_CHECK': '<S573>:3'
      // Transition: '<S573>:27'
      if ((CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_ON == UNLIMITED) ||
          ((int32_T)MX_Gateway_DWork.debounceCount_kmuu >= (int32_T)((int32_T)
            CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_ON + 2))) {
        // Transition: '<S573>:28'
        // Transition: '<S573>:10'
        MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway =
          MX_Gateway_IN_ACTIVE_ftye;

        // Entry 'ACTIVE': '<S573>:2'
        dout_SwitchedPwr = ((int32_T)ACTIVE != 0);
      } else {
        // Transition: '<S573>:30'
        MX_Gateway_DWork.debounceCount_kmuu = (uint16_T)(int32_T)((int32_T)
          MX_Gateway_DWork.debounceCount_kmuu + 1);
      }
      break;

     case MX_Gateway_IN_DELAY_OFF:
      // During 'DELAY_OFF': '<S573>:5'
      if (MX_Gateway_DWork.debounceCount_kmuu >=
          CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_SHUTDOWN) {
        // Transition: '<S573>:12'
        MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway =
          MX_Gateway_IN_INACTIVE_bo51;

        // Entry 'INACTIVE': '<S573>:1'
        dout_SwitchedPwr = ((int32_T)INACTIVE != 0);
      } else {
        MX_Gateway_DWork.debounceCount_kmuu = (uint16_T)(int32_T)((int32_T)
          MX_Gateway_DWork.debounceCount_kmuu + 1);
      }
      break;

     default:
      // During 'INACTIVE': '<S573>:1'
      if ((state_Key != INACTIVE) && (din_RemoteKey == INACTIVE) &&
          (state_System != SYS_POWER_DOWN) && (state_System != SYS_LIMITED)) {
        // Transition: '<S573>:8'
        MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway =
          MX_G_IN_DEBOUNCE_ERROR_ON_CHECK;

        // Entry 'DEBOUNCE_ERROR_ON_CHECK': '<S573>:3'
        MX_Gateway_DWork.debounceCount_kmuu = 0U;
      } else {
        if ((din_RemoteKey == ACTIVE) && (state_System != SYS_POWER_DOWN)) {
          // Transition: '<S573>:11'
          MX_Gateway_DWork.bitsForTID1.is_c50_MX_Gateway =
            MX_Gateway_IN_ACTIVE_ftye;

          // Entry 'ACTIVE': '<S573>:2'
          dout_SwitchedPwr = ((int32_T)ACTIVE != 0);
        }
      }
      break;
    }
  }

  // End of Chart: '<S319>/Relay'

  // Outputs for Enabled SubSystem: '<S319>/relay_oc'
  MX_Gateway_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_SwitchedPwr,
                      dfbk_SwPowerOutput, din_SwPowerRelay,
                      &state_SwitchedPwrOutput, &state_SwitchedPwrRelay,
                      &MX_Gateway_B.relay_oc_icgt,
                      &MX_Gateway_DWork.relay_oc_icgt,
                      CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_OFF,
                      CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_ON,
                      CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S319>/relay_oc'
}

// Function for Chart: '<S579>/TwoSpeed_Control'
static void MX_Gateway_Normal(uint8_T *state_TwoSpeedIcon_czcv, uint8_T
  *FixPtRelationalOperator_n1fs)
{
  // During 'Normal': '<S582>:80'
  if (MX_Gateway_DWork.bitsForTID1.is_Normal_epj5 == MX_Gateway_IN_Active_pkjk)
  {
    // During 'Active': '<S582>:14'
    if ((state_Console != ACTIVE) || (MX_Gateway_B.RateTransition8_hocx == HIGH)
        || (MX_Gateway_B.RateTransition8_hocx == EXTREMELY_HIGH) ||
        (MX_Gateway_B.RateTransition6_awvq == HIGH) ||
        (MX_Gateway_B.RateTransition6_awvq == EXTREMELY_HIGH)) {
      // Transition: '<S582>:28'
      // Exit Internal 'Active': '<S582>:14'
      MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Normal_epj5 = MX_Gateway_IN_Inactive_mv0f;

      // Entry 'Inactive': '<S582>:12'
      MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
      *state_TwoSpeedIcon_czcv = INACTIVE;
    } else if (MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 == MX_Gateway_IN_High)
    {
      *state_TwoSpeedIcon_czcv = ACTIVE;

      // During 'High': '<S582>:10'
      if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
        // Transition: '<S582>:156'
        if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S582>:166'
          // Transition: '<S582>:167'
          state_Buzzer = SINGLE_SHORT_BEEP;
        } else {
          // Transition: '<S582>:165'
        }

        MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 = MX_Gateway_IN_Low;

        // Entry 'Low': '<S582>:11'
        MX_Gateway_DWork.cmd_TwoSpeed = LOW;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Low': '<S582>:11'
      if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
        // Transition: '<S582>:157'
        if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S582>:160'
          // Transition: '<S582>:161'
          state_Buzzer = DOUBLE_SHORT_BEEP;
        } else {
          // Transition: '<S582>:162'
        }

        MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 = MX_Gateway_IN_High;

        // Entry 'High': '<S582>:10'
        MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
        *state_TwoSpeedIcon_czcv = ACTIVE;
      }
    }
  } else {
    *state_TwoSpeedIcon_czcv = INACTIVE;

    // During 'Inactive': '<S582>:12'
    if ((state_Console == ACTIVE) && (MX_Gateway_B.RateTransition8_hocx != HIGH)
        && (MX_Gateway_B.RateTransition8_hocx != EXTREMELY_HIGH) &&
        (MX_Gateway_B.RateTransition6_awvq != HIGH) &&
        (MX_Gateway_B.RateTransition6_awvq != EXTREMELY_HIGH)) {
      // Transition: '<S582>:31'
      MX_Gateway_DWork.bitsForTID1.is_Normal_epj5 = MX_Gateway_IN_Active_pkjk;

      // Entry Internal 'Active': '<S582>:14'
      // Transition: '<S582>:24'
      MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 = MX_Gateway_IN_Low;

      // Entry 'Low': '<S582>:11'
      MX_Gateway_DWork.cmd_TwoSpeed = LOW;
    }
  }
}

// Function for Chart: '<S579>/TwoSpeed_Control'
static void MX_Gateway_Control(uint8_T *state_TwoSpeedIcon_czcv, const boolean_T
  *Compare_geoy, const uint16_T *DataTypeConversion3, uint8_T
  *FixPtRelationalOperator_n1fs)
{
  // During 'Control': '<S582>:6'
  switch (MX_Gateway_DWork.bitsForTID1.is_Control_ksz1) {
   case MX_Gateway_IN_AutoShift:
    // During 'AutoShift': '<S582>:85'
    if (MX_Gateway_DWork.bitsForTID1.is_AutoShift == MX_Gateway_IN_Active_pkjk)
    {
      // During 'Active': '<S582>:90'
      if ((state_Console != ACTIVE) || (MX_Gateway_B.RateTransition8_hocx ==
           HIGH) || (MX_Gateway_B.RateTransition8_hocx == EXTREMELY_HIGH) ||
          (MX_Gateway_B.RateTransition6_awvq == HIGH) ||
          (MX_Gateway_B.RateTransition6_awvq == EXTREMELY_HIGH)) {
        // Transition: '<S582>:87'
        // Exit Internal 'Active': '<S582>:90'
        // Exit Internal 'Autoshift_Active': '<S582>:95'
        MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gateway_DWork.bitsForTID1.is_Active_cebz =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gateway_DWork.bitsForTID1.is_AutoShift = MX_Gateway_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S582>:89'
        MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      } else if (MX_Gateway_DWork.bitsForTID1.is_Active_cebz ==
                 MX_Gateway_IN_Autoshift_Active) {
        *state_TwoSpeedIcon_czcv = ACTIVE;

        // During 'Autoshift_Active': '<S582>:95'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S582>:93'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S582>:154'
            // Transition: '<S582>:155'
            state_Buzzer = SINGLE_SHORT_BEEP;
          } else {
            // Transition: '<S582>:153'
          }

          // Exit Internal 'Autoshift_Active': '<S582>:95'
          MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
            MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gateway_DWork.bitsForTID1.is_Active_cebz =
            MX_Gatewa_IN_Autoshift_Inactive;

          // Entry 'Autoshift_Inactive': '<S582>:94'
          MX_Gateway_DWork.cmd_TwoSpeed = LOW;
          *state_TwoSpeedIcon_czcv = INACTIVE;
        } else {
          switch (MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active) {
           case MX_Gateway_IN_Delay_b1g5:
            // During 'Delay': '<S582>:121'
            if (MX_Gateway_DWork.temporalCounter_i1_ozg1 >=
                CONSTANT_DATA->AUTOSHIFT_TRAVEL_DELAY) {
              // Transition: '<S582>:116'
              MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                MX_Gateway_IN_High_pby2;

              // Entry 'High': '<S582>:104'
              MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
            } else {
              if (*Compare_geoy == (int32_T)INACTIVE) {
                // Transition: '<S582>:117'
                MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                  MX_Gateway_IN_Low_No_Travel;

                // Entry 'Low_No_Travel': '<S582>:103'
                MX_Gateway_DWork.cmd_TwoSpeed = LOW;
              }
            }
            break;

           case MX_Gateway_IN_High_pby2:
            // During 'High': '<S582>:104'
            if ((*DataTypeConversion3 > MX_Gateway_B.P_highLookup) &&
                (state_LoadSense == NORMAL)) {
              // Transition: '<S582>:106'
              MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                MX_Gateway_IN_Low_Travel_aquv;

              // Entry 'Low_Travel': '<S582>:122'
              MX_Gateway_DWork.cmd_TwoSpeed = LOW;
            } else {
              if (*Compare_geoy == (int32_T)INACTIVE) {
                // Transition: '<S582>:115'
                MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                  MX_Gateway_IN_Low_No_Travel;

                // Entry 'Low_No_Travel': '<S582>:103'
                MX_Gateway_DWork.cmd_TwoSpeed = LOW;
              }
            }
            break;

           case MX_Gateway_IN_Low_No_Travel:
            // During 'Low_No_Travel': '<S582>:103'
            if (*Compare_geoy == (int32_T)ACTIVE) {
              // Transition: '<S582>:105'
              if ((int32_T)CONSTANT_DATA->AUTOSHIFT_TRAVEL_DELAY > 0) {
                // Transition: '<S582>:130'
                MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                  MX_Gateway_IN_Delay_b1g5;
                MX_Gateway_DWork.temporalCounter_i1_ozg1 = 0U;
              } else {
                // Transition: '<S582>:133'
                // Transition: '<S582>:131'
                MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                  MX_Gateway_IN_High_pby2;

                // Entry 'High': '<S582>:104'
                MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
              }
            }
            break;

           default:
            // During 'Low_Travel': '<S582>:122'
            if (*Compare_geoy == (int32_T)INACTIVE) {
              // Transition: '<S582>:124'
              MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                MX_Gateway_IN_Low_No_Travel;

              // Entry 'Low_No_Travel': '<S582>:103'
              MX_Gateway_DWork.cmd_TwoSpeed = LOW;
            } else {
              if ((*DataTypeConversion3 < MX_Gateway_B.P_lowLookup) ||
                  (state_LoadSense != NORMAL)) {
                // Transition: '<S582>:123'
                MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
                  MX_Gateway_IN_High_pby2;

                // Entry 'High': '<S582>:104'
                MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
              }
            }
            break;
          }
        }
      } else {
        *state_TwoSpeedIcon_czcv = INACTIVE;

        // During 'Autoshift_Inactive': '<S582>:94'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S582>:92'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S582>:148'
            // Transition: '<S582>:149'
            state_Buzzer = DOUBLE_SHORT_BEEP;
          } else {
            // Transition: '<S582>:150'
          }

          MX_Gateway_DWork.bitsForTID1.is_Active_cebz =
            MX_Gateway_IN_Autoshift_Active;

          // Entry 'Autoshift_Active': '<S582>:95'
          *state_TwoSpeedIcon_czcv = ACTIVE;

          // Entry Internal 'Autoshift_Active': '<S582>:95'
          // Transition: '<S582>:101'
          MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
            MX_Gateway_IN_Low_No_Travel;

          // Entry 'Low_No_Travel': '<S582>:103'
          MX_Gateway_DWork.cmd_TwoSpeed = LOW;
        }
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Inactive': '<S582>:89'
      if ((state_Console == ACTIVE) && (MX_Gateway_B.RateTransition8_hocx !=
           HIGH) && (MX_Gateway_B.RateTransition8_hocx != EXTREMELY_HIGH) &&
          (MX_Gateway_B.RateTransition6_awvq != HIGH) &&
          (MX_Gateway_B.RateTransition6_awvq != EXTREMELY_HIGH)) {
        // Transition: '<S582>:88'
        MX_Gateway_DWork.bitsForTID1.is_AutoShift = MX_Gateway_IN_Active_pkjk;

        // Entry Internal 'Active': '<S582>:90'
        // Transition: '<S582>:107'
        MX_Gateway_DWork.bitsForTID1.is_Active_cebz =
          MX_Gatewa_IN_Autoshift_Inactive;

        // Entry 'Autoshift_Inactive': '<S582>:94'
        MX_Gateway_DWork.cmd_TwoSpeed = LOW;
      }
    }
    break;

   case MX_IN_AutoShift_TrackTensioning:
    // During 'AutoShift_TrackTensioning': '<S582>:205'
    if (MX_Gateway_DWork.bitsForTID1.is_AutoShift_TrackTensioning ==
        MX_Gateway_IN_Active_pkjk) {
      // During 'Active': '<S582>:210'
      if ((state_Console != ACTIVE) || (MX_Gateway_B.RateTransition8_hocx ==
           HIGH) || (MX_Gateway_B.RateTransition8_hocx == EXTREMELY_HIGH) ||
          (MX_Gateway_B.RateTransition6_awvq == HIGH) ||
          (MX_Gateway_B.RateTransition6_awvq == EXTREMELY_HIGH)) {
        // Transition: '<S582>:208'
        // Exit Internal 'Active': '<S582>:210'
        // Exit Internal 'High_Range_Available': '<S582>:225'
        MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;

        // Exit Internal 'Travel_Autoshift': '<S582>:251'
        MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gateway_DWork.bitsForTID1.is_Active_m2xk =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;

        // Exit Internal 'Low_Range': '<S582>:224'
        MX_Gateway_DWork.bitsForTID1.is_Low_Range =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gateway_DWork.bitsForTID1.is_AutoShift_TrackTensioning =
          MX_Gateway_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S582>:209'
        MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      } else if (MX_Gateway_DWork.bitsForTID1.is_Active_m2xk ==
                 MX_Gate_IN_High_Range_Available) {
        *state_TwoSpeedIcon_czcv = ACTIVE;

        // During 'High_Range_Available': '<S582>:225'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S582>:223'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S582>:220'
            // Transition: '<S582>:218'
            state_Buzzer = SINGLE_SHORT_BEEP;
          } else {
            // Transition: '<S582>:217'
          }

          // Exit Internal 'High_Range_Available': '<S582>:225'
          MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
            MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;

          // Exit Internal 'Travel_Autoshift': '<S582>:251'
          MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
            MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gateway_DWork.bitsForTID1.is_Active_m2xk = MX_Gateway_IN_Low_Range;

          // Entry 'Low_Range': '<S582>:224'
          *state_TwoSpeedIcon_czcv = INACTIVE;

          // Entry Internal 'Low_Range': '<S582>:224'
          // Transition: '<S582>:247'
          MX_Gateway_DWork.bitsForTID1.is_Low_Range = MX_Gateway_IN_Normal_h4rfj;

          // Entry 'Normal': '<S582>:246'
          MX_Gateway_DWork.cmd_TwoSpeed = LOW;
        } else if (MX_Gateway_DWork.bitsForTID1.is_High_Range_Available ==
                   MX_Gateway_IN_NoTravel_High) {
          // During 'NoTravel_High': '<S582>:252'
          if (*Compare_geoy == (int32_T)ACTIVE) {
            // Transition: '<S582>:256'
            MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
              MX_Gateway_IN_Travel_Autoshift;

            // Entry Internal 'Travel_Autoshift': '<S582>:251'
            // Transition: '<S582>:228'
            MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
              MX_Gateway_IN_Low_Delay;
            MX_Gateway_DWork.temporalCounter_i1_ozg1 = 0U;

            // Entry 'Low_Delay': '<S582>:254'
            MX_Gateway_DWork.cmd_TwoSpeed = LOW;
          }
        } else {
          // During 'Travel_Autoshift': '<S582>:251'
          if (*Compare_geoy == (int32_T)INACTIVE) {
            // Transition: '<S582>:257'
            // Exit Internal 'Travel_Autoshift': '<S582>:251'
            MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
              MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
            MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
              MX_Gateway_IN_NoTravel_High;

            // Entry 'NoTravel_High': '<S582>:252'
            MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
          } else {
            switch (MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift) {
             case MX_Gateway_IN_High:
              // During 'High': '<S582>:241'
              if ((*DataTypeConversion3 > MX_Gateway_B.P_highLookup) &&
                  (state_LoadSense == NORMAL)) {
                // Transition: '<S582>:237'
                MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
                  MX_Gateway_IN_Low_Travel;

                // Entry 'Low_Travel': '<S582>:242'
                MX_Gateway_DWork.cmd_TwoSpeed = LOW;
              }
              break;

             case MX_Gateway_IN_Low_Delay:
              // During 'Low_Delay': '<S582>:254'
              if (MX_Gateway_DWork.temporalCounter_i1_ozg1 >=
                  CONSTANT_DATA->AUTOSHIFT_TRAVEL_DELAY) {
                // Transition: '<S582>:255'
                MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
                  MX_Gateway_IN_High;

                // Entry 'High': '<S582>:241'
                MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
              }
              break;

             default:
              // During 'Low_Travel': '<S582>:242'
              if ((*DataTypeConversion3 < MX_Gateway_B.P_lowLookup) ||
                  (state_LoadSense != NORMAL)) {
                // Transition: '<S582>:238'
                MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
                  MX_Gateway_IN_High;

                // Entry 'High': '<S582>:241'
                MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
              }
              break;
            }
          }
        }
      } else {
        *state_TwoSpeedIcon_czcv = INACTIVE;

        // During 'Low_Range': '<S582>:224'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S582>:216'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S582>:219'
            // Transition: '<S582>:222'
            state_Buzzer = DOUBLE_SHORT_BEEP;
          } else {
            // Transition: '<S582>:221'
          }

          // Exit Internal 'Low_Range': '<S582>:224'
          MX_Gateway_DWork.bitsForTID1.is_Low_Range =
            MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gateway_DWork.bitsForTID1.is_Active_m2xk =
            MX_Gate_IN_High_Range_Available;

          // Entry 'High_Range_Available': '<S582>:225'
          *state_TwoSpeedIcon_czcv = ACTIVE;

          // Entry Internal 'High_Range_Available': '<S582>:225'
          // Transition: '<S582>:253'
          MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
            MX_Gateway_IN_NoTravel_High;

          // Entry 'NoTravel_High': '<S582>:252'
          MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
        } else if (MX_Gateway_DWork.bitsForTID1.is_Low_Range ==
                   MX_Gateway_IN_Normal_h4rfj) {
          // During 'Normal': '<S582>:246'
          if (*Compare_geoy == (int32_T)INACTIVE) {
            // Transition: '<S582>:243'
            MX_Gateway_DWork.bitsForTID1.is_Low_Range =
              MX_Gateway_IN_Track_Tensioning;

            // Entry 'Track_Tensioning': '<S582>:245'
            MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
          }
        } else {
          // During 'Track_Tensioning': '<S582>:245'
          if (*Compare_geoy == (int32_T)ACTIVE) {
            // Transition: '<S582>:244'
            MX_Gateway_DWork.bitsForTID1.is_Low_Range =
              MX_Gateway_IN_Normal_h4rfj;

            // Entry 'Normal': '<S582>:246'
            MX_Gateway_DWork.cmd_TwoSpeed = LOW;
          }
        }
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Inactive': '<S582>:209'
      if ((state_Console == ACTIVE) && (MX_Gateway_B.RateTransition8_hocx !=
           HIGH) && (MX_Gateway_B.RateTransition8_hocx != EXTREMELY_HIGH) &&
          (MX_Gateway_B.RateTransition6_awvq != HIGH) &&
          (MX_Gateway_B.RateTransition6_awvq != EXTREMELY_HIGH)) {
        // Transition: '<S582>:207'
        MX_Gateway_DWork.bitsForTID1.is_AutoShift_TrackTensioning =
          MX_Gateway_IN_Active_pkjk;

        // Entry Internal 'Active': '<S582>:210'
        // Transition: '<S582>:215'
        MX_Gateway_DWork.bitsForTID1.is_Active_m2xk = MX_Gateway_IN_Low_Range;

        // Entry 'Low_Range': '<S582>:224'
        // Entry Internal 'Low_Range': '<S582>:224'
        // Transition: '<S582>:247'
        MX_Gateway_DWork.bitsForTID1.is_Low_Range = MX_Gateway_IN_Normal_h4rfj;

        // Entry 'Normal': '<S582>:246'
        MX_Gateway_DWork.cmd_TwoSpeed = LOW;
      }
    }
    break;

   case MX_Gateway_IN_NonFunctional:
    *state_TwoSpeedIcon_czcv = INACTIVE;

    // During 'NonFunctional': '<S582>:83'
    // Transition: '<S582>:84'
    if ((CONSTANT_DATA->AUTOSHIFT_FUNCTION != NON_FUNCTIONAL) &&
        (CONSTANT_DATA->TRACKTENSION_FUNCTION != NON_FUNCTIONAL)) {
      // Transition: '<S582>:250'
      MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 =
        MX_IN_AutoShift_TrackTensioning;

      // Entry Internal 'AutoShift_TrackTensioning': '<S582>:205'
      // Transition: '<S582>:206'
      MX_Gateway_DWork.bitsForTID1.is_AutoShift_TrackTensioning =
        MX_Gateway_IN_Inactive_mv0f;

      // Entry 'Inactive': '<S582>:209'
      MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
    } else {
      // Transition: '<S582>:249'
      if (CONSTANT_DATA->AUTOSHIFT_FUNCTION != NON_FUNCTIONAL) {
        // Transition: '<S582>:98'
        MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 = MX_Gateway_IN_AutoShift;

        // Entry Internal 'AutoShift': '<S582>:85'
        // Transition: '<S582>:86'
        MX_Gateway_DWork.bitsForTID1.is_AutoShift = MX_Gateway_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S582>:89'
        MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
      } else {
        // Transition: '<S582>:195'
        if (CONSTANT_DATA->TRACKTENSION_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S582>:194'
          MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 =
            MX_Gateway_IN_TrackTensioning;

          // Entry Internal 'TrackTensioning': '<S582>:172'
          // Transition: '<S582>:173'
          MX_Gateway_DWork.bitsForTID1.is_TrackTensioning =
            MX_Gateway_IN_Inactive_mv0f;

          // Entry 'Inactive': '<S582>:176'
          MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
        } else {
          // Transition: '<S582>:196'
          MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 =
            MX_Gateway_IN_Normal_h4rf;

          // Entry Internal 'Normal': '<S582>:80'
          // Transition: '<S582>:32'
          MX_Gateway_DWork.bitsForTID1.is_Normal_epj5 =
            MX_Gateway_IN_Inactive_mv0f;

          // Entry 'Inactive': '<S582>:12'
          MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
        }
      }
    }
    break;

   case MX_Gateway_IN_Normal_h4rf:
    MX_Gateway_Normal(state_TwoSpeedIcon_czcv, FixPtRelationalOperator_n1fs);
    break;

   default:
    // During 'TrackTensioning': '<S582>:172'
    if (MX_Gateway_DWork.bitsForTID1.is_TrackTensioning ==
        MX_Gateway_IN_Active_pkjk) {
      // During 'Active': '<S582>:177'
      if (state_Console != ACTIVE) {
        // Transition: '<S582>:174'
        // Exit Internal 'Active': '<S582>:177'
        MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 =
          MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;

        // Exit Internal 'Low': '<S582>:191'
        MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gateway_DWork.bitsForTID1.is_TrackTensioning =
          MX_Gateway_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S582>:176'
        MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      } else if (MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 ==
                 MX_Gateway_IN_High) {
        *state_TwoSpeedIcon_czcv = ACTIVE;

        // During 'High': '<S582>:192'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S582>:190'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S582>:187'
            // Transition: '<S582>:185'
            state_Buzzer = SINGLE_SHORT_BEEP;
          } else {
            // Transition: '<S582>:184'
          }

          MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 = MX_Gateway_IN_Low;

          // Entry 'Low': '<S582>:191'
          *state_TwoSpeedIcon_czcv = INACTIVE;

          // Entry Internal 'Low': '<S582>:191'
          // Transition: '<S582>:202'
          MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gateway_IN_Normal_h4rfj;

          // Entry 'Normal': '<S582>:201'
          MX_Gateway_DWork.cmd_TwoSpeed = LOW;
        }
      } else {
        *state_TwoSpeedIcon_czcv = INACTIVE;

        // During 'Low': '<S582>:191'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S582>:183'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S582>:186'
            // Transition: '<S582>:189'
            state_Buzzer = DOUBLE_SHORT_BEEP;
          } else {
            // Transition: '<S582>:188'
          }

          // Exit Internal 'Low': '<S582>:191'
          MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 = MX_Gateway_IN_High;

          // Entry 'High': '<S582>:192'
          MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
          *state_TwoSpeedIcon_czcv = ACTIVE;
        } else if (MX_Gateway_DWork.bitsForTID1.is_Low ==
                   MX_Gateway_IN_Normal_h4rfj) {
          // During 'Normal': '<S582>:201'
          if (*Compare_geoy == (int32_T)INACTIVE) {
            // Transition: '<S582>:203'
            MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gateway_IN_Track_Tensioning;

            // Entry 'Track_Tensioning': '<S582>:198'
            MX_Gateway_DWork.cmd_TwoSpeed = HIGH;
          }
        } else {
          // During 'Track_Tensioning': '<S582>:198'
          if (*Compare_geoy == (int32_T)ACTIVE) {
            // Transition: '<S582>:204'
            MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gateway_IN_Normal_h4rfj;

            // Entry 'Normal': '<S582>:201'
            MX_Gateway_DWork.cmd_TwoSpeed = LOW;
          }
        }
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Inactive': '<S582>:176'
      if (state_Console == ACTIVE) {
        // Transition: '<S582>:175'
        MX_Gateway_DWork.bitsForTID1.is_TrackTensioning =
          MX_Gateway_IN_Active_pkjk;

        // Entry Internal 'Active': '<S582>:177'
        // Transition: '<S582>:182'
        MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 = MX_Gateway_IN_Low;

        // Entry 'Low': '<S582>:191'
        // Entry Internal 'Low': '<S582>:191'
        // Transition: '<S582>:202'
        MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gateway_IN_Normal_h4rfj;

        // Entry 'Normal': '<S582>:201'
        MX_Gateway_DWork.cmd_TwoSpeed = LOW;
      }
    }
    break;
  }
}

// System initialize for atomic system: '<S26>/Two_Speed'
void MX_Gateway_Two_Speed_Init(void)
{
  uint16_T duty_TwoSpeed_mabj;

  // SystemInitialize for Enabled SubSystem: '<S320>/Two_Speed'
  // InitializeConditions for UnitDelay: '<S580>/Delay Input1'
  MX_Gateway_DWork.DelayInput1_DSTATE_defa = ((uint8_T)0U);

  // SystemInitialize for Chart: '<S579>/TwoSpeed_Control'
  MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_AutoShift = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Active_cebz = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
    MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_AutoShift_TrackTensioning =
    MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Active_m2xk = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
    MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
    MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.temporalCounter_i1_ozg1 = 0U;
  MX_Gateway_DWork.bitsForTID1.is_Low_Range = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Normal_epj5 = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_TrackTensioning =
    MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_Two_Speed_Command =
    MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gateway_DWork.bitsForTID1.is_active_c47_MX_Gateway = 0U;
  MX_Gateway_DWork.cmd_TwoSpeed = 0U;
  duty_TwoSpeed_mabj = 0U;

  // SystemInitialize for Atomic SubSystem: '<S579>/hc_Output'
  MX__output_single_OpenLoop_Init(&MX_Gateway_B.state_Output,
    &MX_Gateway_B.hc_Output, &MX_Gateway_DWork.hc_Output);

  // End of SystemInitialize for SubSystem: '<S579>/hc_Output'

  // End of SystemInitialize for SubSystem: '<S320>/Two_Speed'
}

// Output and update for atomic system: '<S26>/Two_Speed'
void MX_Gateway_Two_Speed(void)
{
  uint8_T state_TwoSpeedIcon_czcv;
  uint16_T duty_TwoSpeed_mabj;
  boolean_T Compare_geoy;
  uint16_T DataTypeConversion3;
  int16_T rtb_TmpSignalConversionAtP_lowL[2];
  uint16_T rtb_TmpSignalConversionAtP_jztu[2];
  int16_T rtb_Switch_e2ax;
  uint8_T FixPtRelationalOperator_n1fs;

  // RelationalOperator: '<S576>/Compare' incorporates:
  //   Constant: '<S576>/Constant'

  Compare_geoy = (adin_TravelPressureSwitch > ((uint16_T)512U));

  // DataTypeConversion: '<S320>/Data Type Conversion3'
  DataTypeConversion3 = (uint16_T)(int32_T)(uint32_T)((uint32_T)bar_LoadSense >>
    7);

  // Outputs for Enabled SubSystem: '<S320>/Two_Speed' incorporates:
  //   EnablePort: '<S579>/Enable'

  // Logic: '<S320>/Logical Operator1' incorporates:
  //   Constant: '<S320>/Constant'
  //   Constant: '<S577>/Constant'
  //   Constant: '<S578>/Constant'
  //   RelationalOperator: '<S577>/Compare'
  //   RelationalOperator: '<S578>/Compare'

  if ((CONSTANT_DATA->TWOSPEED_FUNCTION != NON_FUNCTIONAL) && (state_System ==
       SYS_NORMAL)) {
    if (!MX_Gateway_DWork.Two_Speed_MODE) {
      // InitializeConditions for UnitDelay: '<S580>/Delay Input1'
      MX_Gateway_DWork.DelayInput1_DSTATE_defa = ((uint8_T)0U);

      // SystemReset for Chart: '<S579>/TwoSpeed_Control'
      MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_AutoShift =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Active_cebz =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Autoshift_Active =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_AutoShift_TrackTensioning =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Active_m2xk =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_High_Range_Available =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Travel_Autoshift =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.temporalCounter_i1_ozg1 = 0U;
      MX_Gateway_DWork.bitsForTID1.is_Low_Range =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Normal_epj5 =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Active_dfj0 =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_TrackTensioning =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Active_ipr2 =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Low = MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_Two_Speed_Command =
        MX_Gate_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gateway_DWork.bitsForTID1.is_active_c47_MX_Gateway = 0U;
      MX_Gateway_DWork.cmd_TwoSpeed = 0U;
      state_TwoSpeedIcon_czcv = 0U;
      duty_TwoSpeed_mabj = 0U;

      // SystemReset for Atomic SubSystem: '<S579>/hc_Output'
      MX_output_single_OpenLoop_Reset(&MX_Gateway_B.state_Output,
        &MX_Gateway_B.hc_Output, &MX_Gateway_DWork.hc_Output);

      // End of SystemReset for SubSystem: '<S579>/hc_Output'
      MX_Gateway_DWork.Two_Speed_MODE = true;
    }

    // RelationalOperator: '<S580>/FixPt Relational Operator' incorporates:
    //   UnitDelay: '<S580>/Delay Input1'

    FixPtRelationalOperator_n1fs = (uint8_T)(din_TwoSpeedSwitch >
      MX_Gateway_DWork.DelayInput1_DSTATE_defa);

    // Switch: '<S581>/Switch' incorporates:
    //   Constant: '<S581>/Constant8'
    //   Constant: '<S581>/Constant9'
    //   Constant: '<S584>/Constant'
    //   Constant: '<S585>/Constant'
    //   DataTypeConversion: '<S581>/Data Type Conversion'
    //   Logic: '<S581>/Logical Operator'
    //   RelationalOperator: '<S584>/Compare'
    //   RelationalOperator: '<S585>/Compare'
    //   Sum: '<S581>/Sum'

    if ((MX_Gateway_B.RateTransition8_hocx == OORL) ||
        (MX_Gateway_B.RateTransition8_hocx == OORH)) {
      rtb_Switch_e2ax = 300;
    } else {
      rtb_Switch_e2ax = (int16_T)(int32_T)((int32_T)(int16_T)
        MX_Gateway_B.RateTransition9_oiv3 - (int32_T)((uint8_T)40U));
    }

    // End of Switch: '<S581>/Switch'

    // SignalConversion: '<S581>/TmpSignal ConversionAtP_high LookupInport2' incorporates:
    //   Constant: '<S581>/Constant'
    //   Constant: '<S581>/Constant1'

    rtb_TmpSignalConversionAtP_lowL[0] = CONSTANT_DATA->AUTOSHIFT_PHIGH_TEMP1;
    rtb_TmpSignalConversionAtP_lowL[1] = CONSTANT_DATA->AUTOSHIFT_PHIGH_TEMP2;

    // SignalConversion: '<S581>/TmpSignal ConversionAtP_high LookupInport3' incorporates:
    //   Constant: '<S581>/Constant2'
    //   Constant: '<S581>/Constant3'

    rtb_TmpSignalConversionAtP_jztu[0] = CONSTANT_DATA->AUTOSHIFT_PHIGH1;
    rtb_TmpSignalConversionAtP_jztu[1] = CONSTANT_DATA->AUTOSHIFT_PHIGH2;

    // S-Function (sfix_look1_dyn): '<S581>/P_high Lookup'
    // Dynamic Look-Up Table Block: '<S581>/P_high Lookup'
    //  Input0  Data Type:  Integer        S16
    //  Input1  Data Type:  Integer        S16
    //  Input2  Data Type:  Integer        U16
    //  Output0 Data Type:  Integer        U16
    //  Lookup Method: Linear_Endpoint
    //

    LookUp_U16_S16( &(MX_Gateway_B.P_highLookup),
                   &rtb_TmpSignalConversionAtP_jztu[0], rtb_Switch_e2ax,
                   &rtb_TmpSignalConversionAtP_lowL[0], 1U);

    // SignalConversion: '<S581>/TmpSignal ConversionAtP_low LookupInport2' incorporates:
    //   Constant: '<S581>/Constant4'
    //   Constant: '<S581>/Constant5'

    rtb_TmpSignalConversionAtP_lowL[0] = CONSTANT_DATA->AUTOSHIFT_PLOW_TEMP1;
    rtb_TmpSignalConversionAtP_lowL[1] = CONSTANT_DATA->AUTOSHIFT_PLOW_TEMP2;

    // SignalConversion: '<S581>/TmpSignal ConversionAtP_low LookupInport3' incorporates:
    //   Constant: '<S581>/Constant6'
    //   Constant: '<S581>/Constant7'

    rtb_TmpSignalConversionAtP_jztu[0] = CONSTANT_DATA->AUTOSHIFT_PLOW1;
    rtb_TmpSignalConversionAtP_jztu[1] = CONSTANT_DATA->AUTOSHIFT_PLOW2;

    // S-Function (sfix_look1_dyn): '<S581>/P_low Lookup'
    // Dynamic Look-Up Table Block: '<S581>/P_low Lookup'
    //  Input0  Data Type:  Integer        S16
    //  Input1  Data Type:  Integer        S16
    //  Input2  Data Type:  Integer        U16
    //  Output0 Data Type:  Integer        U16
    //  Lookup Method: Linear_Endpoint
    //

    LookUp_U16_S16( &(MX_Gateway_B.P_lowLookup),
                   &rtb_TmpSignalConversionAtP_jztu[0], rtb_Switch_e2ax,
                   &rtb_TmpSignalConversionAtP_lowL[0], 1U);

    // Chart: '<S579>/TwoSpeed_Control'
    // Gateway: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control
    if ((uint32_T)MX_Gateway_DWork.temporalCounter_i1_ozg1 < 255U) {
      MX_Gateway_DWork.temporalCounter_i1_ozg1 = (uint8_T)(int32_T)((int32_T)
        MX_Gateway_DWork.temporalCounter_i1_ozg1 + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control
    if ((uint32_T)MX_Gateway_DWork.bitsForTID1.is_active_c47_MX_Gateway == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control
      MX_Gateway_DWork.bitsForTID1.is_active_c47_MX_Gateway = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control 
      // Entry Internal 'Control': '<S582>:6'
      // Transition: '<S582>:82'
      MX_Gateway_DWork.bitsForTID1.is_Control_ksz1 = MX_Gateway_IN_NonFunctional;

      // Entry 'NonFunctional': '<S582>:83'
      MX_Gateway_DWork.cmd_TwoSpeed = INACTIVE;
      state_TwoSpeedIcon_czcv = INACTIVE;

      // Entry Internal 'Two_Speed_Command': '<S582>:16'
      // Transition: '<S582>:38'
      MX_Gateway_DWork.bitsForTID1.is_Two_Speed_Command = MX_Gateway_IN_Low;

      // Entry 'Low': '<S582>:17'
      duty_TwoSpeed_mabj = 0U;
    } else {
      MX_Gateway_Control(&state_TwoSpeedIcon_czcv, &Compare_geoy,
                         &DataTypeConversion3, &FixPtRelationalOperator_n1fs);

      // During 'Two_Speed_Command': '<S582>:16'
      if (MX_Gateway_DWork.bitsForTID1.is_Two_Speed_Command ==
          MX_Gateway_IN_High) {
        duty_TwoSpeed_mabj = FULL_ON;

        // During 'High': '<S582>:7'
        if ((MX_Gateway_DWork.cmd_TwoSpeed != HIGH) || (state_Engine ==
             ENGINE_CRANKING) || (state_HydEnable != ACTIVE)) {
          // Transition: '<S582>:39'
          MX_Gateway_DWork.bitsForTID1.is_Two_Speed_Command = MX_Gateway_IN_Low;

          // Entry 'Low': '<S582>:17'
          duty_TwoSpeed_mabj = 0U;
        }
      } else {
        duty_TwoSpeed_mabj = 0U;

        // During 'Low': '<S582>:17'
        if ((MX_Gateway_DWork.cmd_TwoSpeed == HIGH) && (state_Engine !=
             ENGINE_CRANKING) && (state_HydEnable == ACTIVE)) {
          // Transition: '<S582>:40'
          MX_Gateway_DWork.bitsForTID1.is_Two_Speed_Command = MX_Gateway_IN_High;

          // Entry 'High': '<S582>:7'
          duty_TwoSpeed_mabj = FULL_ON;
        }
      }
    }

    // End of Chart: '<S579>/TwoSpeed_Control'

    // Outputs for Atomic SubSystem: '<S579>/hc_Output'
    MX_Gatew_output_single_OpenLoop(duty_TwoSpeed_mabj,
      MX_Gateway_B.RateTransition11_kahy, MX_Gateway_B.RateTransition10_fs4r,
      afbk_TwoSpeed, &MX_Gateway_B.state_Output, &duty_TwoSpeed,
      &MX_Gateway_B.hc_Output, &MX_Gateway_DWork.hc_Output,
      CONSTANT_DATA->TWOSPEED_MAX_VOLTS,
      CONSTANT_DATA->TWOSPEED_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->TWOSPEED_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->TWOSPEED_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->TWOSPEED_FUNCTION, CONSTANT_DATA->TWOSPEED_AFBK_GAIN);

    // End of Outputs for SubSystem: '<S579>/hc_Output'

    // SignalConversion: '<S579>/OutportBufferForstate_TwoSpeed'
    state_TwoSpeed = MX_Gateway_B.state_Output;

    // SignalConversion: '<S579>/OutportBufferForstate_TwoSpeedIcon'
    state_TwoSpeedIcon = state_TwoSpeedIcon_czcv;

    // Update for UnitDelay: '<S580>/Delay Input1'
    MX_Gateway_DWork.DelayInput1_DSTATE_defa = din_TwoSpeedSwitch;
  } else {
    if (MX_Gateway_DWork.Two_Speed_MODE) {
      // Disable for Atomic SubSystem: '<S579>/hc_Output'
      output_single_OpenLoop_Disable(&MX_Gateway_B.hc_Output,
        &MX_Gateway_DWork.hc_Output);

      // End of Disable for SubSystem: '<S579>/hc_Output'

      // Disable for Outport: '<S579>/state_TwoSpeed'
      state_TwoSpeed = ((uint8_T)0U);

      // Disable for Outport: '<S579>/state_TwoSpeedIcon'
      state_TwoSpeedIcon = ((uint8_T)0U);

      // Disable for Outport: '<S579>/duty_TwoSpeed'
      duty_TwoSpeed = ((uint16_T)0U);
      MX_Gateway_DWork.Two_Speed_MODE = false;
    }
  }

  // End of Logic: '<S320>/Logical Operator1'
  // End of Outputs for SubSystem: '<S320>/Two_Speed'
}

//
//  [EOF]

