//
//  Copyright (c) 2009 Bobcat Company as an unpublished work.
//  All Rights Reserved.
//
//  The information contained herein is confidential property of Bobcat Company.
//  The use, copying, transfer or disclosure of such information is prohibited except
//  by express written agreement with Bobcat Company.
//
//  Code Generated by Simulink Real-Time Workshop
//
//  Simulink model                       : MX_Gateway


#include "mod_Library.h"

// Include model header file for global data
#include "MX_Gateway.h"
#include "MX_Gateway_private.h"

// Named constants for Chart: '<S177>/LP_Filter_Adj_Gain'
#define MX_Gateway_IN_INITIAL          ((uint8_T)1U)
#define MX_Gateway_IN_LP_FILTER        ((uint8_T)2U)
#define MX_Gateway_IN_NO_ACTIVE_CHILD  ((uint8_T)0U)

// Named constants for Chart: '<S223>/LP_Filter_Adj_Gain'
#define MX_Gate_IN_NO_ACTIVE_CHILD_p1y5 ((uint8_T)0U)
#define MX_Gateway_IN_INITIAL_aowf     ((uint8_T)1U)
#define MX_Gateway_IN_LP_FILTER_hzab   ((uint8_T)2U)

// Named constants for Chart: '<S241>/LP_Fitler_Adj_Gain'
#define MX_Gate_IN_NO_ACTIVE_CHILD_lpib ((uint8_T)0U)
#define MX_Gateway_IN_INITIAL_obic     ((uint8_T)1U)
#define MX_Gateway_IN_LP_FILTER_nfsi   ((uint8_T)2U)

// Named constants for Chart: '<S361>/Fault monitor'
#define MX_Gate_IN_NO_ACTIVE_CHILD_gc4w ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE           ((uint8_T)1U)
#define MX_Gateway_IN_DEBOUNCE         ((uint8_T)1U)
#define MX_Gateway_IN_FAULT            ((uint8_T)2U)
#define MX_Gateway_IN_INACTIVE         ((uint8_T)2U)
#define MX_Gateway_IN_NORMAL           ((uint8_T)1U)
#define MX_Gateway_IN_OC_STG           ((uint8_T)2U)
#define MX_Gateway_IN_OFF              ((uint8_T)1U)
#define MX_Gateway_IN_ON               ((uint8_T)2U)
#define MX_Gateway_IN_OPEN_CIRCUIT     ((uint8_T)3U)
#define MX_Gateway_IN_SHORT_TO_BATTERY ((uint8_T)4U)
#define MX_Gateway_IN_SHORT_TO_GROUND  ((uint8_T)5U)
#define MX_Gateway_IN_TURNING_OFF      ((uint8_T)3U)
#define MX_Gateway_IN_TURNING_ON       ((uint8_T)4U)
#define MX_Gateway_IN_debounce         ((uint8_T)2U)
#define MX_Gateway_IN_error            ((uint8_T)3U)

// Named constants for Chart: '<S352>/oc_operation_detection'
#define MX_Gate_IN_NO_ACTIVE_CHILD_jstd ((uint8_T)0U)
#define MX_Gate_IN_OPEN_STG_ERROR_RESET ((uint8_T)6U)
#define MX_Gatew_IN_OPEN_STG_DIAG_STATE ((uint8_T)4U)
#define MX_Gateway_IN_DIAG_STATE_ERROR ((uint8_T)1U)
#define MX_Gateway_IN_NORMAL_ngcs      ((uint8_T)2U)
#define MX_Gateway_IN_OC_STATE_ERROR   ((uint8_T)3U)
#define MX_Gateway_IN_OPEN_STG_ERROR   ((uint8_T)5U)
#define MX_Gateway_IN_OPEN_STG_RESET   ((uint8_T)7U)

// Named constants for Chart: '<S328>/control'
#define MX_Gate_IN_NO_ACTIVE_CHILD_jgad ((uint8_T)0U)
#define MX_Gate_IN_STGOFF_DIAG_INACTIVE ((uint8_T)2U)
#define MX_Gatewa_IN_STGOFF_DIAG_ACTIVE ((uint8_T)1U)
#define MX_Gateway_IN_ACTIVE_OFF       ((uint8_T)1U)
#define MX_Gateway_IN_ACTIVE_ON        ((uint8_T)2U)
#define MX_Gateway_IN_DIAG_CHECK       ((uint8_T)1U)
#define MX_Gateway_IN_ENABLE_OFF       ((uint8_T)1U)
#define MX_Gateway_IN_ENABLE_ON        ((uint8_T)2U)
#define MX_Gateway_IN_ERROR            ((uint8_T)2U)
#define MX_Gateway_IN_FUNCTIONAL       ((uint8_T)3U)
#define MX_Gateway_IN_Test_OC          ((uint8_T)1U)
#define MX_Gateway_IN_Test_STG         ((uint8_T)2U)

// Named constants for Chart: '<S389>/control'
#define MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz ((uint8_T)1U)
#define MX_Gate_IN_NO_ACTIVE_CHILD_eulg ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE_OFF_o5z1  ((uint8_T)1U)
#define MX_Gateway_IN_ACTIVE_ON_aqdk   ((uint8_T)2U)
#define MX_Gateway_IN_DIAG_CHECK_gfxy  ((uint8_T)1U)
#define MX_Gateway_IN_ENABLE_OFF_ifnc  ((uint8_T)1U)
#define MX_Gateway_IN_ENABLE_ON_p4th   ((uint8_T)2U)
#define MX_Gateway_IN_ERROR_jnvd       ((uint8_T)2U)
#define MX_Gateway_IN_FUNCTIONAL_blpp  ((uint8_T)3U)
#define MX_Gateway_IN_Test_OC_dpgv     ((uint8_T)1U)
#define MX_Gateway_IN_Test_STG_a1mc    ((uint8_T)2U)
#define MX_IN_STGOFF_DIAG_INACTIVE_o1ij ((uint8_T)2U)

// Named constants for Chart: '<S432>/relay_error_state'
#define MX_Gate_IN_NO_ACTIVE_CHILD_bpan ((uint8_T)0U)
#define MX_Gateway_IN_DEBOUNCE_mmz1    ((uint8_T)1U)
#define MX_Gateway_IN_ERROR_OFF        ((uint8_T)1U)
#define MX_Gateway_IN_ERROR_ON         ((uint8_T)2U)
#define MX_Gateway_IN_FAILURE          ((uint8_T)3U)
#define MX_Gateway_IN_FAULT_pyte       ((uint8_T)2U)
#define MX_Gateway_IN_NORMAL_pqen      ((uint8_T)4U)
#define MX_Gateway_IN_NORMAL_pqenz     ((uint8_T)3U)
#define MX_Gateway_IN_OPEN_CIRCUIT_pa2m ((uint8_T)5U)
#define MX_Gateway_IN_OUTPUT           ((uint8_T)1U)
#define MX_Gateway_IN_RELAY            ((uint8_T)2U)

// Named constants for Chart: '<S443>/Fault monitor'
#define MX_Gat_IN_SHORT_TO_BATTERY_mp5u ((uint8_T)3U)
#define MX_Gate_IN_NO_ACTIVE_CHILD_bes5 ((uint8_T)0U)
#define MX_Gate_IN_SHORT_TO_GROUND_e2rb ((uint8_T)4U)
#define MX_Gateway_IN_DEBOUNCE_mxcs    ((uint8_T)1U)
#define MX_Gateway_IN_FAULT_k5qe       ((uint8_T)2U)
#define MX_Gateway_IN_NORMAL_l0jr      ((uint8_T)1U)
#define MX_Gateway_IN_OPEN_CIRCUIT_iupo ((uint8_T)2U)

// Named constants for Chart: '<S583>/control'
#define MX_Gate_IN_NO_ACTIVE_CHILD_opa5 ((uint8_T)0U)
#define MX_Gateway_IN_ACTIVE_itwh      ((uint8_T)1U)
#define MX_Gateway_IN_ERROR_l2ny       ((uint8_T)1U)
#define MX_Gateway_IN_FUNCTIONAL_gxam  ((uint8_T)2U)
#define MX_Gateway_IN_INACTIVE_l135    ((uint8_T)2U)

//
//  Output and update for atomic system:
//     '<S24>/ErrorCode'
//     '<S24>/ErrorCode1'
//     '<S24>/ErrorCode10'
//     '<S24>/ErrorCode11'
//     '<S24>/ErrorCode12'
//     '<S24>/ErrorCode13'
//     '<S24>/ErrorCode14'
//     '<S24>/ErrorCode15'
//     '<S24>/ErrorCode16'
//     '<S24>/ErrorCode17'
//     ...

void MX_Gateway_ErrorCode(uint8_T rtu_failure, uint16_T *rty_ecode, uint16_T
  rtp_FUNCTION)
{
  // Sum: '<S29>/Sum' incorporates:
  //   Constant: '<S29>/Constant'
  //   Constant: '<S29>/Constant1'
  //   Product: '<S29>/Product'

  *rty_ecode = (uint16_T)(uint32_T)((uint32_T)rtu_failure + (uint32_T)(uint16_T)
    (uint32_T)((uint32_T)rtp_FUNCTION * (uint32_T)((uint16_T)256U)));
}

// System initialize for atomic system: '<S96>/LP_Filter'
void MX_Gateway_LP_Filter_Init(rtDW_LP_Filter_MX_Gateway *localDW)
{
  // InitializeConditions for UnitDelay: '<S171>/FixPt Unit Delay2'
  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)1U);
}

// Output and update for atomic system: '<S96>/LP_Filter'
void MX_Gateway_LP_Filter(int16_T rtu_In, int16_T *rty_Out,
  rtDW_LP_Filter_MX_Gateway *localDW)
{
  int16_T rtb_DataTypeConversion1_gw3m;
  int16_T rtb_Init;
  int32_T tmp;

  // DataTypeConversion: '<S169>/Data Type Conversion1'
  rtb_DataTypeConversion1_gw3m = (int16_T)(int32_T)((int32_T)rtu_In << 5);

  // Switch: '<S171>/Init' incorporates:
  //   UnitDelay: '<S171>/FixPt Unit Delay1'
  //   UnitDelay: '<S171>/FixPt Unit Delay2'

  if ((int32_T)localDW->FixPtUnitDelay2_DSTATE != 0) {
    rtb_Init = rtb_DataTypeConversion1_gw3m;
  } else {
    rtb_Init = localDW->FixPtUnitDelay1_DSTATE;
  }

  // End of Switch: '<S171>/Init'

  // Sum: '<S169>/Sum'
  tmp = (int32_T)((int32_T)rtb_DataTypeConversion1_gw3m - (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  // Sum: '<S169>/Sum1' incorporates:
  //   ArithShift: '<S169>/Shift Arithmetic'
  //   Sum: '<S169>/Sum'

  tmp = (int32_T)((int32_T)(tmp >> 3) + (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  *rty_Out = (int16_T)tmp;

  // End of Sum: '<S169>/Sum1'

  // Update for UnitDelay: '<S171>/FixPt Unit Delay2' incorporates:
  //   Constant: '<S171>/FixPt Constant'

  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)0U);

  // Update for UnitDelay: '<S171>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = *rty_Out;
}

//
//  Output and update for atomic system:
//     '<S96>/Ratiometric_Converter'
//     '<S173>/Ratiometric_Converter'
//     '<S201>/Ratiometric_Converter'
//     '<S105>/Ratiometric_Converter'
//     '<S239>/Ratiometric_Converter'
//     '<S287>/Ratiometric_Converter'

void MX_Gatewa_Ratiometric_Converter(uint16_T rtu_SensorInput, uint16_T
  rtu_SensorSupply, uint16_T *rty_Ratiometric, uint16_T rtp_multiplier)
{
  uint16_T u0;

  // DataTypeConversion: '<S170>/Data Type Conversion' incorporates:
  //   Constant: '<S170>/RATIOMETRIC_MULTIPLIER'
  //   Product: '<S170>/Divide'
  //   Product: '<S170>/Product'

  u0 = (uint16_T)((uint32_T)rtu_SensorSupply == 0U ? MAX_uint32_T : (uint32_T)
                  ((uint32_T)((uint32_T)rtu_SensorInput * (uint32_T)
    rtp_multiplier) / (uint32_T)rtu_SensorSupply));

  // Saturate: '<S170>/Saturation'
  if (u0 < ((uint16_T)2047U)) {
    *rty_Ratiometric = u0;
  } else {
    *rty_Ratiometric = ((uint16_T)2047U);
  }

  // End of Saturate: '<S170>/Saturation'
}

//
//  System initialize for atomic system:
//     '<S173>/LP_Filter'
//     '<S204>/LP_Filter'
//     '<S239>/LP_Filter'

void MX_Gateway_LP_Filter_kaxm_Init(rtDW_LP_Filter_MX_Gateway_ntkm *localDW)
{
  // InitializeConditions for UnitDelay: '<S180>/FixPt Unit Delay2'
  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)1U);

  // InitializeConditions for UnitDelay: '<S180>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = 0;
}

//
//  System reset for atomic system:
//     '<S173>/LP_Filter'
//     '<S204>/LP_Filter'
//     '<S239>/LP_Filter'

void MX_Gateway_LP_Filter_ntmf_Reset(rtDW_LP_Filter_MX_Gateway_ntkm *localDW)
{
  // InitializeConditions for UnitDelay: '<S180>/FixPt Unit Delay2'
  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)1U);

  // InitializeConditions for UnitDelay: '<S180>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = 0;
}

//
//  Output and update for atomic system:
//     '<S173>/LP_Filter'
//     '<S204>/LP_Filter'
//     '<S239>/LP_Filter'

void MX_Gateway_LP_Filter_dijo(uint16_T rtu_In, int16_T *rty_Out,
  rtDW_LP_Filter_MX_Gateway_ntkm *localDW)
{
  int16_T rtb_DataTypeConversion1_p2e3;
  int16_T rtb_Init;
  int32_T tmp;

  // DataTypeConversion: '<S176>/Data Type Conversion1'
  rtb_DataTypeConversion1_p2e3 = (int16_T)(int32_T)((int32_T)(int16_T)rtu_In <<
    5);

  // Switch: '<S180>/Init' incorporates:
  //   UnitDelay: '<S180>/FixPt Unit Delay1'
  //   UnitDelay: '<S180>/FixPt Unit Delay2'

  if ((int32_T)localDW->FixPtUnitDelay2_DSTATE != 0) {
    rtb_Init = rtb_DataTypeConversion1_p2e3;
  } else {
    rtb_Init = localDW->FixPtUnitDelay1_DSTATE;
  }

  // End of Switch: '<S180>/Init'

  // Sum: '<S176>/Sum'
  tmp = (int32_T)((int32_T)rtb_DataTypeConversion1_p2e3 - (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  // Sum: '<S176>/Sum1' incorporates:
  //   ArithShift: '<S176>/Shift Arithmetic'
  //   Sum: '<S176>/Sum'

  tmp = (int32_T)((int32_T)(tmp >> 3) + (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  *rty_Out = (int16_T)tmp;

  // End of Sum: '<S176>/Sum1'

  // Update for UnitDelay: '<S180>/FixPt Unit Delay2' incorporates:
  //   Constant: '<S180>/FixPt Constant'

  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)0U);

  // Update for UnitDelay: '<S180>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = *rty_Out;
}

//
//  System initialize for atomic system:
//     '<S173>/LP_Filter_Adj_Gain'
//     '<S204>/LP_Filter_Adj_Gain'
//     '<S105>/LP_Filter_Adj_Gain1'
//     '<S111>/LP_Filter_Adj_Gain'
//     '<S112>/LP_Filter_Adj_Gain'
//     '<S287>/LP_Filter_Adj_Gain'
//     '<S287>/LP_Filter_Adj_Gain1'
//     '<S349>/LP_Filter_Adj_Gain'
//     '<S366>/LP_Filter_Adj_Gain'
//     '<S394>/LP_Filter_Adj_Gain'
//     ...

void MX_Gate_LP_Filter_Adj_Gain_Init(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_Gain_MX_Gate *localDW)
{
  // SystemInitialize for Chart: '<S177>/LP_Filter_Adj_Gain'
  localDW->bitsForTID2.is_active_c1_MX_Library = 0U;
  localDW->bitsForTID2.is_c1_MX_Library = MX_Gateway_IN_NO_ACTIVE_CHILD;
  *rty_Output = 0;
}

//
//  System reset for atomic system:
//     '<S173>/LP_Filter_Adj_Gain'
//     '<S204>/LP_Filter_Adj_Gain'
//     '<S105>/LP_Filter_Adj_Gain1'
//     '<S111>/LP_Filter_Adj_Gain'
//     '<S112>/LP_Filter_Adj_Gain'
//     '<S287>/LP_Filter_Adj_Gain'
//     '<S287>/LP_Filter_Adj_Gain1'
//     '<S349>/LP_Filter_Adj_Gain'
//     '<S366>/LP_Filter_Adj_Gain'
//     '<S394>/LP_Filter_Adj_Gain'
//     ...

void MX_Gat_LP_Filter_Adj_Gain_Reset(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_Gain_MX_Gate *localDW)
{
  // SystemReset for Chart: '<S177>/LP_Filter_Adj_Gain'
  localDW->bitsForTID2.is_active_c1_MX_Library = 0U;
  localDW->bitsForTID2.is_c1_MX_Library = MX_Gateway_IN_NO_ACTIVE_CHILD;
  *rty_Output = 0;
}

//
//  Output and update for atomic system:
//     '<S173>/LP_Filter_Adj_Gain'
//     '<S204>/LP_Filter_Adj_Gain'
//     '<S105>/LP_Filter_Adj_Gain1'
//     '<S111>/LP_Filter_Adj_Gain'
//     '<S112>/LP_Filter_Adj_Gain'
//     '<S287>/LP_Filter_Adj_Gain'
//     '<S287>/LP_Filter_Adj_Gain1'
//     '<S349>/LP_Filter_Adj_Gain'
//     '<S366>/LP_Filter_Adj_Gain'
//     '<S394>/LP_Filter_Adj_Gain'
//     ...

void MX_Gateway_LP_Filter_Adj_Gain(uint8_T rtu_Gain, int16_T rtu_Input, int32_T *
  rty_Output, rtDW_LP_Filter_Adj_Gain_MX_Gate *localDW)
{
  // Chart: '<S177>/LP_Filter_Adj_Gain'
  // Gateway: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  // During: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  if ((uint32_T)localDW->bitsForTID2.is_active_c1_MX_Library == 0U) {
    // Entry: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    localDW->bitsForTID2.is_active_c1_MX_Library = 1U;

    // Entry Internal: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    // Transition: '<S181>:3'
    localDW->bitsForTID2.is_c1_MX_Library = MX_Gateway_IN_INITIAL;

    // Entry 'INITIAL': '<S181>:1'
    *rty_Output = (int32_T)((int32_T)rtu_Input << 16);
  } else if (localDW->bitsForTID2.is_c1_MX_Library == MX_Gateway_IN_INITIAL) {
    // During 'INITIAL': '<S181>:1'
    // Transition: '<S181>:4'
    localDW->bitsForTID2.is_c1_MX_Library = MX_Gateway_IN_LP_FILTER;
  } else {
    // During 'LP_FILTER': '<S181>:2'
    *rty_Output += div_s32((int32_T)((int32_T)((int32_T)rtu_Input << 16) -
      *rty_Output), (int32_T)(1 << (int32_T)rtu_Gain));
  }

  // End of Chart: '<S177>/LP_Filter_Adj_Gain'
}

//
//  System initialize for atomic system:
//     '<S173>/Remove_OOR_Levels'
//     '<S204>/Remove_OOR_Levels'
//     '<S105>/Remove_OOR_Levels'
//     '<S239>/Remove_OOR_Levels'
//     '<S287>/Remove_OOR_Levels'

void MX_Gatew_Remove_OOR_Levels_Init(uint16_T *rty_fltValue_out,
  rtDW_Remove_OOR_Levels_MX_Gatew *localDW)
{
  // SystemInitialize for Chart: '<S179>/RemoveOORLevels'
  localDW->fltValue_old = 0U;
  *rty_fltValue_out = 0U;
}

//
//  System reset for atomic system:
//     '<S173>/Remove_OOR_Levels'
//     '<S204>/Remove_OOR_Levels'
//     '<S105>/Remove_OOR_Levels'
//     '<S239>/Remove_OOR_Levels'
//     '<S287>/Remove_OOR_Levels'

void MX_Gate_Remove_OOR_Levels_Reset(uint16_T *rty_fltValue_out,
  rtDW_Remove_OOR_Levels_MX_Gatew *localDW)
{
  // SystemReset for Chart: '<S179>/RemoveOORLevels'
  localDW->fltValue_old = 0U;
  *rty_fltValue_out = 0U;
}

//
//  Output and update for atomic system:
//     '<S173>/Remove_OOR_Levels'
//     '<S204>/Remove_OOR_Levels'
//     '<S105>/Remove_OOR_Levels'
//     '<S239>/Remove_OOR_Levels'
//     '<S287>/Remove_OOR_Levels'

void MX_Gateway_Remove_OOR_Levels(uint16_T rtu_fltValue_in, uint16_T
  *rty_fltValue_out, rtDW_Remove_OOR_Levels_MX_Gatew *localDW, uint16_T
  rtp_OORH_LEVEL, uint16_T rtp_OORL_LEVEL)
{
  // Chart: '<S179>/RemoveOORLevels'
  // Gateway: Remove_OOR_Levels/RemoveOORLevels
  // During: Remove_OOR_Levels/RemoveOORLevels
  // Entry Internal: Remove_OOR_Levels/RemoveOORLevels
  // Transition: '<S182>:1'
  if ((rtu_fltValue_in > rtp_OORL_LEVEL) && (rtu_fltValue_in < rtp_OORH_LEVEL))
  {
    // Transition: '<S182>:2'
    // Transition: '<S182>:3'
    *rty_fltValue_out = rtu_fltValue_in;
    localDW->fltValue_old = rtu_fltValue_in;

    // Transition: '<S182>:4'
  } else {
    // Transition: '<S182>:5'
    *rty_fltValue_out = localDW->fltValue_old;
  }

  // End of Chart: '<S179>/RemoveOORLevels'
}

// System initialize for atomic system: '<S105>/LP_Filter_Adj_Gain'
void MX_LP_Filter_Adj_Gain_bqur_Init(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_Gain_MX_j5ng *localDW)
{
  // SystemInitialize for Chart: '<S223>/LP_Filter_Adj_Gain'
  localDW->bitsForTID2.is_active_c1_MX_Library = 0U;
  localDW->bitsForTID2.is_c1_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_p1y5;
  *rty_Output = 0;
}

// Output and update for atomic system: '<S105>/LP_Filter_Adj_Gain'
void MX_Gate_LP_Filter_Adj_Gain_hwrc(uint8_T rtu_Gain, int16_T rtu_Input,
  int32_T *rty_Output, rtDW_LP_Filter_Adj_Gain_MX_j5ng *localDW)
{
  // Chart: '<S223>/LP_Filter_Adj_Gain'
  // Gateway: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  // During: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  if ((uint32_T)localDW->bitsForTID2.is_active_c1_MX_Library == 0U) {
    // Entry: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    localDW->bitsForTID2.is_active_c1_MX_Library = 1U;

    // Entry Internal: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    // Transition: '<S228>:3'
    localDW->bitsForTID2.is_c1_MX_Library = MX_Gateway_IN_INITIAL_aowf;

    // Entry 'INITIAL': '<S228>:1'
    *rty_Output = (int32_T)((int32_T)rtu_Input << 16);
  } else if (localDW->bitsForTID2.is_c1_MX_Library == MX_Gateway_IN_INITIAL_aowf)
  {
    // During 'INITIAL': '<S228>:1'
    // Transition: '<S228>:4'
    localDW->bitsForTID2.is_c1_MX_Library = MX_Gateway_IN_LP_FILTER_hzab;
  } else {
    // During 'LP_FILTER': '<S228>:2'
    *rty_Output += div_s32((int32_T)((int32_T)((int32_T)rtu_Input << 16) -
      *rty_Output), (int32_T)(1 << (int32_T)rtu_Gain));
  }

  // End of Chart: '<S223>/LP_Filter_Adj_Gain'
}

// System initialize for atomic system: '<S239>/LP_Filter_Adj_System'
void MX_Ga_LP_Filter_Adj_System_Init(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_System_MX_Ga *localDW)
{
  // SystemInitialize for Chart: '<S241>/LP_Fitler_Adj_Gain'
  localDW->bitsForTID2.is_active_c2_MX_Library = 0U;
  localDW->bitsForTID2.is_c2_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_lpib;
  *rty_Output = 0;
}

// System reset for atomic system: '<S239>/LP_Filter_Adj_System'
void MX_G_LP_Filter_Adj_System_Reset(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_System_MX_Ga *localDW)
{
  // SystemReset for Chart: '<S241>/LP_Fitler_Adj_Gain'
  localDW->bitsForTID2.is_active_c2_MX_Library = 0U;
  localDW->bitsForTID2.is_c2_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_lpib;
  *rty_Output = 0;
}

// Output and update for atomic system: '<S239>/LP_Filter_Adj_System'
void MX_Gateway_LP_Filter_Adj_System(uint8_T rtu_Gain, int16_T rtu_Input,
  uint8_T rtu_state_System, int32_T *rty_Output, rtDW_LP_Filter_Adj_System_MX_Ga
  *localDW)
{
  // Chart: '<S241>/LP_Fitler_Adj_Gain'
  // Gateway: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
  // During: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
  if ((uint32_T)localDW->bitsForTID2.is_active_c2_MX_Library == 0U) {
    // Entry: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
    localDW->bitsForTID2.is_active_c2_MX_Library = 1U;

    // Entry Internal: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
    // Transition: '<S245>:3'
    localDW->bitsForTID2.is_c2_MX_Library = MX_Gateway_IN_INITIAL_obic;

    // Entry 'INITIAL': '<S245>:1'
    *rty_Output = (int32_T)((int32_T)rtu_Input << 16);
  } else if (localDW->bitsForTID2.is_c2_MX_Library == MX_Gateway_IN_INITIAL_obic)
  {
    // During 'INITIAL': '<S245>:1'
    if ((int32_T)rtu_state_System == 1) {
      // Transition: '<S245>:4'
      localDW->bitsForTID2.is_c2_MX_Library = MX_Gateway_IN_LP_FILTER_nfsi;
    }
  } else {
    // During 'LP_FILTER': '<S245>:2'
    *rty_Output += div_s32((int32_T)((int32_T)((int32_T)rtu_Input << 16) -
      *rty_Output), (int32_T)(1 << (int32_T)rtu_Gain));
  }

  // End of Chart: '<S241>/LP_Fitler_Adj_Gain'
}

//
//  System initialize for enable system:
//     '<S351>/control_loop'
//     '<S368>/control_loop'
//     '<S414>/control_loop'
//     '<S524>/control_loop'
//     '<S541>/control_loop'

void MX_Gateway_control_loop_Init(rtDW_control_loop_MX_Gateway *localDW)
{
  // InitializeConditions for DiscreteIntegrator: '<S359>/Discrete-Time Integrator' 
  localDW->DiscreteTimeIntegrator_DSTATE = 0;
}

//
//  System reset for enable system:
//     '<S351>/control_loop'
//     '<S368>/control_loop'
//     '<S414>/control_loop'
//     '<S524>/control_loop'
//     '<S541>/control_loop'

void MX_Gateway_control_loop_Reset(rtDW_control_loop_MX_Gateway *localDW)
{
  // InitializeConditions for DiscreteIntegrator: '<S359>/Discrete-Time Integrator' 
  localDW->DiscreteTimeIntegrator_DSTATE = 0;
}

//
//  Disable for enable system:
//     '<S351>/control_loop'
//     '<S368>/control_loop'
//     '<S414>/control_loop'
//     '<S524>/control_loop'
//     '<S541>/control_loop'

void MX_Gateway_control_loop_Disable(int16_T *rty_error, uint16_T *rty_duty,
  rtB_control_loop_MX_Gateway *localB, rtDW_control_loop_MX_Gateway *localDW)
{
  // Disable for DiscreteIntegrator: '<S359>/Discrete-Time Integrator'
  localDW->DiscreteTimeIntegrator_DSTATE = localB->DiscreteTimeIntegrator;

  // Outputs for Enabled SubSystem: '<S351>/control_loop' incorporates:
  //   EnablePort: '<S359>/Enable'

  // Disable for Outport: '<S359>/error'
  *rty_error = 0;

  // Disable for Outport: '<S359>/duty'
  *rty_duty = ((uint16_T)0U);

  // End of Outputs for SubSystem: '<S351>/control_loop'
  localDW->control_loop_MODE = false;
}

//
//  Output and update for enable system:
//     '<S351>/control_loop'
//     '<S368>/control_loop'
//     '<S414>/control_loop'
//     '<S524>/control_loop'
//     '<S541>/control_loop'

void MX_Gateway_control_loop(boolean_T rtu_Enable, uint16_T rtu_i_cmd, uint16_T
  rtu_i_fbk, int16_T *rty_error, uint16_T *rty_duty, rtB_control_loop_MX_Gateway
  *localB, rtDW_control_loop_MX_Gateway *localDW, uint16_T rtp_KP, uint16_T
  rtp_KI)
{
  int16_T rtb_Saturation_dwkj;
  int32_T tmp;
  uint16_T tmp_0;
  uint16_T tmp_1;

  // Outputs for Enabled SubSystem: '<S351>/control_loop' incorporates:
  //   EnablePort: '<S359>/Enable'

  if (rtu_Enable) {
    if (!localDW->control_loop_MODE) {
      MX_Gateway_control_loop_Reset(localDW);
      localDW->control_loop_MODE = true;
    }

    // Sum: '<S359>/Sum'
    tmp_0 = (uint16_T)(uint32_T)((uint32_T)(int32_T)((int32_T)rtu_i_cmd + 1) >>
      1);
    if ((int32_T)tmp_0 > 32767) {
      tmp_0 = 32767U;
    }

    tmp_1 = (uint16_T)(uint32_T)((uint32_T)(int32_T)((int32_T)rtu_i_fbk + 1) >>
      1);
    if ((int32_T)tmp_1 > 32767) {
      tmp_1 = 32767U;
    }

    *rty_error = (int16_T)(int32_T)((int32_T)tmp_0 - (int32_T)tmp_1);

    // End of Sum: '<S359>/Sum'

    // DiscreteIntegrator: '<S359>/Discrete-Time Integrator'
    localB->DiscreteTimeIntegrator = localDW->DiscreteTimeIntegrator_DSTATE;

    // Gain: '<S359>/Kp'
    tmp_0 = rtp_KP;
    if ((int32_T)rtp_KP > 32767) {
      tmp_0 = 32767U;
    }

    tmp = (int32_T)((int32_T)tmp_0 * (int32_T)*rty_error);
    tmp = (int32_T)((int32_T)(tmp >> 12) + ((int32_T)(tmp & 2048) != 0));
    if (tmp > 32767) {
      tmp = 32767;
    } else {
      if (tmp < -32768) {
        tmp = -32768;
      }
    }

    // Sum: '<S359>/Sum1' incorporates:
    //   Gain: '<S359>/Kp'

    rtb_Saturation_dwkj = (int16_T)(int32_T)(tmp + (int32_T)
      localB->DiscreteTimeIntegrator);

    // Saturate: '<S359>/Saturation'
    if ((int32_T)rtb_Saturation_dwkj > (int32_T)16384) {
      rtb_Saturation_dwkj = 16384;
    } else {
      if ((int32_T)rtb_Saturation_dwkj < (int32_T)0) {
        rtb_Saturation_dwkj = 0;
      }
    }

    // End of Saturate: '<S359>/Saturation'

    // DataTypeConversion: '<S359>/Data Type Conversion'
    if ((int32_T)rtb_Saturation_dwkj <= 0) {
      *rty_duty = 0U;
    } else if ((int32_T)rtb_Saturation_dwkj > 16383) {
      *rty_duty = MAX_uint16_T;
    } else {
      *rty_duty = (uint16_T)(int32_T)((int32_T)rtb_Saturation_dwkj << 2);
    }

    // End of DataTypeConversion: '<S359>/Data Type Conversion'

    // Gain: '<S359>/Ki'
    tmp_0 = rtp_KI;
    if ((int32_T)rtp_KI > 32767) {
      tmp_0 = 32767U;
    }

    tmp = (int32_T)((int32_T)tmp_0 * (int32_T)*rty_error);
    tmp = (int32_T)((int32_T)(tmp >> 12) + ((int32_T)(tmp & 2048) != 0));
    if (tmp > 32767) {
      tmp = 32767;
    } else {
      if (tmp < -32768) {
        tmp = -32768;
      }
    }

    // Update for DiscreteIntegrator: '<S359>/Discrete-Time Integrator' incorporates:
    //   Gain: '<S359>/Ki'

    localDW->DiscreteTimeIntegrator_DSTATE = (int16_T)(int32_T)((int32_T)
      localDW->DiscreteTimeIntegrator_DSTATE + tmp);
    if ((int32_T)localDW->DiscreteTimeIntegrator_DSTATE >= (int32_T)16384) {
      localDW->DiscreteTimeIntegrator_DSTATE = 16384;
    } else {
      if ((int32_T)localDW->DiscreteTimeIntegrator_DSTATE <= (int32_T)(-16384))
      {
        localDW->DiscreteTimeIntegrator_DSTATE = (-16384);
      }
    }

    // End of Update for DiscreteIntegrator: '<S359>/Discrete-Time Integrator'
  } else {
    if (localDW->control_loop_MODE) {
      MX_Gateway_control_loop_Disable(rty_error, rty_duty, localB, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S351>/control_loop'
}

//
//  System initialize for atomic system:
//     '<S351>/hc_pair_OpenLoop'
//     '<S368>/hc_pair_OpenLoop'
//     '<S389>/hc_pair_OpenLoop'
//     '<S414>/hc_pair_OpenLoop'
//     '<S457>/hc_pair_OpenLoop'
//     '<S476>/hc_pair_OpenLoop'
//     '<S524>/hc_pair_OpenLoop'
//     '<S541>/hc_pair_OpenLoop'

void MX_Gatewa_hc_pair_OpenLoop_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_OpenLoop_MX_Gatewa *localDW)
{
  // SystemInitialize for Chart: '<S361>/Fault monitor'
  localDW->bitsForTID1.is_FAULT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_OC_STG = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_OUTPUT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID1.is_OVERCURRENT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_active_c63_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_cnt_oc = 0U;
  *rty_hs_cmd = 0U;
  *rty_ls_cmd = false;
  *rty_diag_state = 8U;
  *rty_oc_state = 0U;
}

//
//  System reset for atomic system:
//     '<S351>/hc_pair_OpenLoop'
//     '<S368>/hc_pair_OpenLoop'
//     '<S389>/hc_pair_OpenLoop'
//     '<S414>/hc_pair_OpenLoop'
//     '<S457>/hc_pair_OpenLoop'
//     '<S476>/hc_pair_OpenLoop'
//     '<S524>/hc_pair_OpenLoop'
//     '<S541>/hc_pair_OpenLoop'

void MX_Gatew_hc_pair_OpenLoop_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_OpenLoop_MX_Gatewa *localDW)
{
  // SystemReset for Chart: '<S361>/Fault monitor'
  localDW->bitsForTID1.is_FAULT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_OC_STG = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_OUTPUT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID1.is_OVERCURRENT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID1.is_active_c63_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_cnt_oc = 0U;
  *rty_hs_cmd = 0U;
  *rty_ls_cmd = false;
  *rty_diag_state = 8U;
  *rty_oc_state = 0U;
}

//
//  Output and update for atomic system:
//     '<S351>/hc_pair_OpenLoop'
//     '<S368>/hc_pair_OpenLoop'
//     '<S389>/hc_pair_OpenLoop'
//     '<S414>/hc_pair_OpenLoop'
//     '<S457>/hc_pair_OpenLoop'
//     '<S476>/hc_pair_OpenLoop'
//     '<S524>/hc_pair_OpenLoop'
//     '<S541>/hc_pair_OpenLoop'

void MX_Gateway_hc_pair_OpenLoop(uint16_T rtu_duty, boolean_T rtu_enable,
  boolean_T rtu_diag_enable, uint16_T rtu_afbk, uint16_T rtu_Vbatt, uint16_T
  rtu_ifbk, uint8_T rtu_ocstg_check, uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_OpenLoop_MX_Gatewa *localDW, uint16_T rtp_IFBK_MAX, uint16_T
  rtp_NZ_DUTY, uint16_T rtp_NZ_IFBK, uint16_T rtp_OC_DB_CNT, uint16_T
  rtp_OPEN_DB_CNT, uint16_T rtp_OSTG_DB_CNT, uint16_T rtp_STB_DB_CNT, uint16_T
  rtp_STG_DB_CNT)
{
  int16_T rtb_afbk_ratio_gqt4;

  // Product: '<S361>/Divide'
  rtb_afbk_ratio_gqt4 = div_s16u32((uint32_T)((uint32_T)rtu_afbk << 8),
    (uint32_T)rtu_Vbatt);

  // Chart: '<S361>/Fault monitor'
  // Gateway: hc_pair_OpenLoop/Open_Loop/Fault monitor
  if ((uint32_T)localDW->temporalCounter_i1 < 63U) {
    localDW->temporalCounter_i1 = (uint8_T)(int32_T)((int32_T)
      localDW->temporalCounter_i1 + 1);
  }

  // During: hc_pair_OpenLoop/Open_Loop/Fault monitor
  if ((uint32_T)localDW->bitsForTID1.is_active_c63_MX_Library == 0U) {
    // Entry: hc_pair_OpenLoop/Open_Loop/Fault monitor
    localDW->bitsForTID1.is_active_c63_MX_Library = 1U;

    // Entry Internal: hc_pair_OpenLoop/Open_Loop/Fault monitor
    // Entry Internal 'OUTPUT': '<S362>:246'
    // Transition: '<S362>:248'
    localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_OFF;
    localDW->temporalCounter_i1 = 0U;

    // Entry 'OFF': '<S362>:255'
    *rty_hs_cmd = 0U;
    *rty_ls_cmd = ((int32_T)INACTIVE != 0);

    // Entry Internal 'FAULT': '<S362>:245'
    // Transition: '<S362>:27'
    localDW->bitsForTID1.is_FAULT = MX_Gateway_IN_INACTIVE;

    // Entry 'INACTIVE': '<S362>:11'
    *rty_diag_state = NORMAL;

    // Entry Internal 'OVERCURRENT': '<S362>:259'
    // Transition: '<S362>:260'
    localDW->bitsForTID1.is_OVERCURRENT = MX_Gateway_IN_NORMAL;

    // Entry 'NORMAL': '<S362>:264'
    *rty_oc_state = NORMAL;
    localDW->db_cnt_oc = 0U;
  } else {
    // During 'OUTPUT': '<S362>:246'
    switch (localDW->bitsForTID1.is_OUTPUT) {
     case MX_Gateway_IN_OFF:
      // During 'OFF': '<S362>:255'
      if (((int32_T)localDW->temporalCounter_i1 >= 50) && ((rtu_enable ==
            (int32_T)ACTIVE) && (*rty_oc_state == NORMAL) && (rtu_diag_enable ==
            (int32_T)ACTIVE))) {
        // Transition: '<S362>:299'
        // Transition: '<S362>:252'
        localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_TURNING_ON;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'TURNING_ON': '<S362>:257'
        *rty_ls_cmd = ((int32_T)ACTIVE != 0);
      }
      break;

     case MX_Gateway_IN_ON:
      // During 'ON': '<S362>:258'
      if ((rtu_enable == (int32_T)INACTIVE) || (rtu_diag_enable == (int32_T)
           INACTIVE)) {
        // Transition: '<S362>:253'
        localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_TURNING_OFF;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'TURNING_OFF': '<S362>:256'
        *rty_hs_cmd = 0U;
      } else if (*rty_oc_state == OVERCURRENT) {
        // Transition: '<S362>:249'
        localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_OFF;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OFF': '<S362>:255'
        *rty_hs_cmd = 0U;
        *rty_ls_cmd = ((int32_T)INACTIVE != 0);
      } else {
        *rty_hs_cmd = rtu_duty;
      }
      break;

     case MX_Gateway_IN_TURNING_OFF:
      // During 'TURNING_OFF': '<S362>:256'
      if ((int32_T)localDW->temporalCounter_i1 >= 2) {
        // Transition: '<S362>:251'
        localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_OFF;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OFF': '<S362>:255'
        *rty_hs_cmd = 0U;
        *rty_ls_cmd = ((int32_T)INACTIVE != 0);
      }
      break;

     default:
      // During 'TURNING_ON': '<S362>:257'
      if ((int32_T)localDW->temporalCounter_i1 >= 2) {
        // Transition: '<S362>:254'
        localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_ON;
      }
      break;
    }

    // During 'FAULT': '<S362>:245'
    if (localDW->bitsForTID1.is_FAULT == MX_Gateway_IN_ACTIVE) {
      // During 'ACTIVE': '<S362>:10'
      if (rtu_ocstg_check == ACTIVE) {
        // Transition: '<S362>:29'
        // Exit Internal 'ACTIVE': '<S362>:10'
        localDW->bitsForTID1.is_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'OC_STG': '<S362>:225'
        localDW->bitsForTID1.is_OC_STG = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'OPEN_CIRCUIT': '<S362>:210'
        localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'SHORT_TO_BATTERY': '<S362>:220'
        localDW->bitsForTID1.is_SHORT_TO_BATTERY =
          MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'SHORT_TO_GROUND': '<S362>:215'
        localDW->bitsForTID1.is_SHORT_TO_GROUND =
          MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
        localDW->bitsForTID1.is_FAULT = MX_Gateway_IN_INACTIVE;

        // Entry 'INACTIVE': '<S362>:11'
        *rty_diag_state = NORMAL;
      } else {
        switch (localDW->bitsForTID1.is_ACTIVE) {
         case MX_Gateway_IN_NORMAL:
          *rty_diag_state = NORMAL;

          // During 'NORMAL': '<S362>:208'
          if (((uint32_T)*rty_hs_cmd == (uint32_T)((uint32_T)INACTIVE << 16)) &&
              ((int32_T)rtb_afbk_ratio_gqt4 > 205) && rtu_diag_enable) {
            // Transition: '<S362>:233'
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_SHORT_TO_BATTERY;

            // Entry Internal 'SHORT_TO_BATTERY': '<S362>:220'
            // Transition: '<S362>:221'
            localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gateway_IN_DEBOUNCE;

            // Entry 'DEBOUNCE': '<S362>:223'
            localDW->db_cnt = 0U;
          } else if ((*rty_ls_cmd) && (*rty_hs_cmd > rtp_NZ_DUTY) && (rtu_ifbk <=
                      rtp_NZ_IFBK) && rtu_diag_enable) {
            // Transition: '<S362>:234'
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_OC_STG;

            // Entry Internal 'OC_STG': '<S362>:225'
            // Transition: '<S362>:226'
            localDW->bitsForTID1.is_OC_STG = MX_Gateway_IN_DEBOUNCE;

            // Entry 'DEBOUNCE': '<S362>:228'
            localDW->db_cnt = 0U;
          } else if (((uint32_T)*rty_hs_cmd == (uint32_T)((uint32_T)INACTIVE <<
                       16)) && (*rty_ls_cmd) && ((int32_T)rtb_afbk_ratio_gqt4 >
                      64) && ((int32_T)rtb_afbk_ratio_gqt4 < 192) &&
                     rtu_diag_enable) {
            // Transition: '<S362>:236'
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_OPEN_CIRCUIT;

            // Entry Internal 'OPEN_CIRCUIT': '<S362>:210'
            // Transition: '<S362>:212'
            localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gateway_IN_DEBOUNCE;

            // Entry 'DEBOUNCE': '<S362>:211'
            localDW->db_cnt = 0U;
          } else {
            if ((!*rty_ls_cmd) && ((int32_T)rtb_afbk_ratio_gqt4 < 51) &&
                rtu_diag_enable) {
              // Transition: '<S362>:238'
              localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_SHORT_TO_GROUND;

              // Entry Internal 'SHORT_TO_GROUND': '<S362>:215'
              // Transition: '<S362>:216'
              localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gateway_IN_DEBOUNCE;

              // Entry 'DEBOUNCE': '<S362>:218'
              localDW->db_cnt = 0U;
            }
          }
          break;

         case MX_Gateway_IN_OC_STG:
          // During 'OC_STG': '<S362>:225'
          if ((*rty_diag_state == NORMAL) && ((!*rty_ls_cmd) || (*rty_hs_cmd <=
                rtp_NZ_DUTY) || (rtu_ifbk > rtp_NZ_IFBK) || (!rtu_diag_enable)))
          {
            // Transition: '<S362>:235'
            // Exit Internal 'OC_STG': '<S362>:225'
            localDW->bitsForTID1.is_OC_STG = MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_NORMAL;

            // Entry 'NORMAL': '<S362>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID1.is_OC_STG == MX_Gateway_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S362>:228'
            if (localDW->db_cnt >= rtp_OSTG_DB_CNT) {
              // Transition: '<S362>:227'
              localDW->bitsForTID1.is_OC_STG = MX_Gateway_IN_FAULT;

              // Entry 'FAULT': '<S362>:229'
              *rty_diag_state = OPEN_STG;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = OPEN_STG;

            // During 'FAULT': '<S362>:229'
          }
          break;

         case MX_Gateway_IN_OPEN_CIRCUIT:
          // During 'OPEN_CIRCUIT': '<S362>:210'
          if ((*rty_diag_state == NORMAL) && (((uint32_T)*rty_hs_cmd !=
                (uint32_T)((uint32_T)INACTIVE << 16)) || (!*rty_ls_cmd) ||
               ((int32_T)rtb_afbk_ratio_gqt4 <= 64) || ((int32_T)
                rtb_afbk_ratio_gqt4 >= 192) || (!rtu_diag_enable))) {
            // Transition: '<S362>:237'
            // Exit Internal 'OPEN_CIRCUIT': '<S362>:210'
            localDW->bitsForTID1.is_OPEN_CIRCUIT =
              MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_NORMAL;

            // Entry 'NORMAL': '<S362>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID1.is_OPEN_CIRCUIT ==
                     MX_Gateway_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S362>:211'
            if (localDW->db_cnt >= rtp_OPEN_DB_CNT) {
              // Transition: '<S362>:214'
              localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gateway_IN_FAULT;

              // Entry 'FAULT': '<S362>:213'
              *rty_diag_state = OPEN_CIRCUIT;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = OPEN_CIRCUIT;

            // During 'FAULT': '<S362>:213'
          }
          break;

         case MX_Gateway_IN_SHORT_TO_BATTERY:
          // During 'SHORT_TO_BATTERY': '<S362>:220'
          if ((*rty_diag_state == NORMAL) && (((uint32_T)*rty_hs_cmd !=
                (uint32_T)((uint32_T)INACTIVE << 16)) || ((int32_T)
                rtb_afbk_ratio_gqt4 <= 205) || (!rtu_diag_enable))) {
            // Transition: '<S362>:232'
            // Exit Internal 'SHORT_TO_BATTERY': '<S362>:220'
            localDW->bitsForTID1.is_SHORT_TO_BATTERY =
              MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_NORMAL;

            // Entry 'NORMAL': '<S362>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID1.is_SHORT_TO_BATTERY ==
                     MX_Gateway_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S362>:223'
            if (localDW->db_cnt >= rtp_STB_DB_CNT) {
              // Transition: '<S362>:222'
              localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gateway_IN_FAULT;

              // Entry 'FAULT': '<S362>:224'
              *rty_diag_state = SHORT_TO_BATTERY;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = SHORT_TO_BATTERY;

            // During 'FAULT': '<S362>:224'
          }
          break;

         default:
          // During 'SHORT_TO_GROUND': '<S362>:215'
          if ((*rty_diag_state == NORMAL) && ((*rty_ls_cmd) || ((int32_T)
                rtb_afbk_ratio_gqt4 >= 51) || (!rtu_diag_enable))) {
            // Transition: '<S362>:239'
            // Exit Internal 'SHORT_TO_GROUND': '<S362>:215'
            localDW->bitsForTID1.is_SHORT_TO_GROUND =
              MX_Gate_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_NORMAL;

            // Entry 'NORMAL': '<S362>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID1.is_SHORT_TO_GROUND ==
                     MX_Gateway_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S362>:218'
            if (localDW->db_cnt >= rtp_STG_DB_CNT) {
              // Transition: '<S362>:217'
              localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gateway_IN_FAULT;

              // Entry 'FAULT': '<S362>:219'
              *rty_diag_state = SHORT_TO_GROUND;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = SHORT_TO_GROUND;

            // During 'FAULT': '<S362>:219'
          }
          break;
        }
      }
    } else {
      *rty_diag_state = NORMAL;

      // During 'INACTIVE': '<S362>:11'
      if (rtu_ocstg_check != ACTIVE) {
        // Transition: '<S362>:28'
        localDW->bitsForTID1.is_FAULT = MX_Gateway_IN_ACTIVE;

        // Entry Internal 'ACTIVE': '<S362>:10'
        // Transition: '<S362>:231'
        localDW->bitsForTID1.is_ACTIVE = MX_Gateway_IN_NORMAL;

        // Entry 'NORMAL': '<S362>:208'
        localDW->db_cnt = 0U;
      }
    }

    // During 'OVERCURRENT': '<S362>:259'
    switch (localDW->bitsForTID1.is_OVERCURRENT) {
     case MX_Gateway_IN_NORMAL:
      *rty_oc_state = NORMAL;

      // During 'NORMAL': '<S362>:264'
      if ((rtu_ifbk > rtp_IFBK_MAX) && rtu_diag_enable) {
        // Transition: '<S362>:261'
        localDW->db_cnt_oc = (uint16_T)(int32_T)((int32_T)localDW->db_cnt_oc + 1);
        localDW->bitsForTID1.is_OVERCURRENT = MX_Gateway_IN_debounce;
      }
      break;

     case MX_Gateway_IN_debounce:
      // During 'debounce': '<S362>:265'
      if (localDW->db_cnt_oc >= rtp_OC_DB_CNT) {
        // Transition: '<S362>:263'
        localDW->bitsForTID1.is_OVERCURRENT = MX_Gateway_IN_error;

        // Entry 'error': '<S362>:266'
        *rty_oc_state = OVERCURRENT;
      } else if ((rtu_ifbk <= rtp_IFBK_MAX) || (!rtu_diag_enable)) {
        // Transition: '<S362>:262'
        localDW->bitsForTID1.is_OVERCURRENT = MX_Gateway_IN_NORMAL;

        // Entry 'NORMAL': '<S362>:264'
        *rty_oc_state = NORMAL;
        localDW->db_cnt_oc = 0U;
      } else {
        localDW->db_cnt_oc = (uint16_T)(int32_T)((int32_T)localDW->db_cnt_oc + 1);
      }
      break;

     default:
      *rty_oc_state = OVERCURRENT;

      // During 'error': '<S362>:266'
      *rty_hs_cmd = 0U;
      *rty_ls_cmd = ((int32_T)INACTIVE != 0);
      break;
    }
  }

  // End of Chart: '<S361>/Fault monitor'
}

//
//  System initialize for atomic system:
//     '<S328>/hc_pair_ClosedLoop_v5'
//     '<S329>/hc_pair_ClosedLoop_v5'
//     '<S409>/hc_pair_ClosedLoop_v5'
//     '<S514>/hc_pair_ClosedLoop_v5'
//     '<S515>/hc_pair_ClosedLoop_v5'

void MX_G_hc_pair_ClosedLoop_v5_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_ClosedLoop_v5_MX_G *localDW)
{
  // InitializeConditions for UnitDelay: '<S351>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S351>/Unit Delay'
  localDW->UnitDelay_DSTATE = false;

  // SystemInitialize for Enabled SubSystem: '<S351>/control_loop'
  MX_Gateway_control_loop_Init(&localDW->control_loop);

  // End of SystemInitialize for SubSystem: '<S351>/control_loop'

  // SystemInitialize for Atomic SubSystem: '<S351>/hc_pair_OpenLoop'
  MX_Gatewa_hc_pair_OpenLoop_Init(rty_hs_cmd, rty_ls_cmd, rty_oc_state,
    rty_diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemInitialize for SubSystem: '<S351>/hc_pair_OpenLoop'
}

//
//  System reset for atomic system:
//     '<S328>/hc_pair_ClosedLoop_v5'
//     '<S329>/hc_pair_ClosedLoop_v5'
//     '<S409>/hc_pair_ClosedLoop_v5'
//     '<S514>/hc_pair_ClosedLoop_v5'
//     '<S515>/hc_pair_ClosedLoop_v5'

void MX__hc_pair_ClosedLoop_v5_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_ClosedLoop_v5_MX_G *localDW)
{
  // InitializeConditions for UnitDelay: '<S351>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S351>/Unit Delay'
  localDW->UnitDelay_DSTATE = false;

  // SystemReset for Atomic SubSystem: '<S351>/hc_pair_OpenLoop'
  MX_Gatew_hc_pair_OpenLoop_Reset(rty_hs_cmd, rty_ls_cmd, rty_oc_state,
    rty_diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemReset for SubSystem: '<S351>/hc_pair_OpenLoop'
}

//
//  Disable for atomic system:
//     '<S328>/hc_pair_ClosedLoop_v5'
//     '<S329>/hc_pair_ClosedLoop_v5'
//     '<S409>/hc_pair_ClosedLoop_v5'
//     '<S514>/hc_pair_ClosedLoop_v5'
//     '<S515>/hc_pair_ClosedLoop_v5'

void M_hc_pair_ClosedLoop_v5_Disable(int16_T *rty_error,
  rtB_hc_pair_ClosedLoop_v5_MX_Ga *localB, rtDW_hc_pair_ClosedLoop_v5_MX_G
  *localDW)
{
  // Disable for Enabled SubSystem: '<S351>/control_loop'
  if (localDW->control_loop.control_loop_MODE) {
    MX_Gateway_control_loop_Disable(rty_error, &localB->DataTypeConversion,
      &localB->control_loop, &localDW->control_loop);
  }

  // End of Disable for SubSystem: '<S351>/control_loop'
}

//
//  Output and update for atomic system:
//     '<S328>/hc_pair_ClosedLoop_v5'
//     '<S329>/hc_pair_ClosedLoop_v5'
//     '<S409>/hc_pair_ClosedLoop_v5'
//     '<S514>/hc_pair_ClosedLoop_v5'
//     '<S515>/hc_pair_ClosedLoop_v5'

void MX_Gatewa_hc_pair_ClosedLoop_v5(uint16_T rtu_i_cmd, boolean_T
  rtu_enable_LoSide, boolean_T rtu_diag_enable, uint16_T rtu_afbk, uint16_T
  rtu_Vbatt, uint16_T rtu_i_fbk, uint8_T rtu_ocstg_check, uint16_T *rty_hs_cmd,
  boolean_T *rty_ls_cmd, uint8_T *rty_oc_state, uint8_T *rty_diag_state, int16_T
  *rty_error, rtB_hc_pair_ClosedLoop_v5_MX_Ga *localB,
  rtDW_hc_pair_ClosedLoop_v5_MX_G *localDW, uint16_T rtp_KP, uint16_T rtp_KI,
  uint16_T rtp_IFBK_MAX, uint16_T rtp_NZ_DUTY, uint16_T rtp_NZ_IFBK, uint16_T
  rtp_OC_DB_CNT, uint16_T rtp_OPEN_DB_CNT, uint16_T rtp_OSTG_DB_CNT, uint16_T
  rtp_STB_DB_CNT, uint16_T rtp_STG_DB_CNT, uint8_T rtp_BIDIRECTIONAL_CTRL)
{
  boolean_T rtb_HiddenBuf_InsertedFor_contr;

  // SignalConversion: '<S351>/HiddenBuf_InsertedFor_control_loop_at_inport_2' incorporates:
  //   Constant: '<S351>/Constant'
  //   Constant: '<S356>/Constant'
  //   Constant: '<S357>/Constant'
  //   Constant: '<S358>/Constant'
  //   Logic: '<S351>/Logical Operator'
  //   Logic: '<S351>/Logical Operator1'
  //   RelationalOperator: '<S356>/Compare'
  //   RelationalOperator: '<S357>/Compare'
  //   RelationalOperator: '<S358>/Compare'
  //   UnitDelay: '<S351>/Unit Delay'
  //   UnitDelay: '<S351>/Unit Delay1'

  rtb_HiddenBuf_InsertedFor_contr = (localDW->UnitDelay_DSTATE &&
    (localDW->UnitDelay1_DSTATE == NORMAL) && rtu_enable_LoSide &&
    rtu_diag_enable && ((rtu_i_cmd > ((uint16_T)0U)) || (rtp_BIDIRECTIONAL_CTRL
    != NON_FUNCTIONAL)));

  // Outputs for Enabled SubSystem: '<S351>/control_loop'
  MX_Gateway_control_loop(rtb_HiddenBuf_InsertedFor_contr, rtu_i_cmd, rtu_i_fbk,
    rty_error, &localB->DataTypeConversion, &localB->control_loop,
    &localDW->control_loop, rtp_KP, rtp_KI);

  // End of Outputs for SubSystem: '<S351>/control_loop'

  // Outputs for Atomic SubSystem: '<S351>/hc_pair_OpenLoop'
  MX_Gateway_hc_pair_OpenLoop(localB->DataTypeConversion, rtu_enable_LoSide,
    rtu_diag_enable, rtu_afbk, rtu_Vbatt, rtu_i_fbk, rtu_ocstg_check, rty_hs_cmd,
    rty_ls_cmd, rty_oc_state, rty_diag_state, &localDW->hc_pair_OpenLoop,
    rtp_IFBK_MAX, rtp_NZ_DUTY, rtp_NZ_IFBK, rtp_OC_DB_CNT, rtp_OPEN_DB_CNT,
    rtp_OSTG_DB_CNT, rtp_STB_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S351>/hc_pair_OpenLoop'

  // Update for UnitDelay: '<S351>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = *rty_diag_state;

  // Update for UnitDelay: '<S351>/Unit Delay'
  localDW->UnitDelay_DSTATE = *rty_ls_cmd;
}

//
//  System initialize for atomic system:
//     '<S328>/oc_stg_detection'
//     '<S329>/oc_stg_detection'
//     '<S389>/oc_stg_detection'
//     '<S409>/oc_stg_detection'
//     '<S457>/oc_stg_detection'
//     '<S476>/oc_stg_detection'
//     '<S514>/oc_stg_detection'
//     '<S515>/oc_stg_detection'

void MX_Gatewa_oc_stg_detection_Init(uint8_T *rty_diag_state_out, uint8_T
  *rty_ocstg_check, rtDW_oc_stg_detection_MX_Gatewa *localDW)
{
  // SystemInitialize for Chart: '<S352>/oc_operation_detection'
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID1.is_active_c5_MX_Library = 0U;
  localDW->bitsForTID1.is_c5_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_jstd;
  localDW->debounceCount = 0U;
  *rty_diag_state_out = 0U;
  *rty_ocstg_check = 0U;
}

//
//  System reset for atomic system:
//     '<S328>/oc_stg_detection'
//     '<S329>/oc_stg_detection'
//     '<S389>/oc_stg_detection'
//     '<S409>/oc_stg_detection'
//     '<S457>/oc_stg_detection'
//     '<S476>/oc_stg_detection'
//     '<S514>/oc_stg_detection'
//     '<S515>/oc_stg_detection'

void MX_Gatew_oc_stg_detection_Reset(uint8_T *rty_diag_state_out, uint8_T
  *rty_ocstg_check, rtDW_oc_stg_detection_MX_Gatewa *localDW)
{
  // SystemReset for Chart: '<S352>/oc_operation_detection'
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID1.is_active_c5_MX_Library = 0U;
  localDW->bitsForTID1.is_c5_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_jstd;
  localDW->debounceCount = 0U;
  *rty_diag_state_out = 0U;
  *rty_ocstg_check = 0U;
}

//
//  Output and update for atomic system:
//     '<S328>/oc_stg_detection'
//     '<S329>/oc_stg_detection'
//     '<S389>/oc_stg_detection'
//     '<S409>/oc_stg_detection'
//     '<S457>/oc_stg_detection'
//     '<S476>/oc_stg_detection'
//     '<S514>/oc_stg_detection'
//     '<S515>/oc_stg_detection'

void MX_Gateway_oc_stg_detection(uint8_T rtu_oc_state, uint8_T rtu_diag_state_in,
  uint8_T *rty_diag_state_out, uint8_T *rty_ocstg_check,
  rtDW_oc_stg_detection_MX_Gatewa *localDW, uint16_T rtp_OPEN_DB_CNT, uint16_T
  rtp_STG_DB_CNT)
{
  // Chart: '<S352>/oc_operation_detection'
  // Gateway: oc_stg_detection/oc_operation_detection
  if ((uint32_T)localDW->temporalCounter_i1 < 63U) {
    localDW->temporalCounter_i1 = (uint8_T)(int32_T)((int32_T)
      localDW->temporalCounter_i1 + 1);
  }

  // During: oc_stg_detection/oc_operation_detection
  if ((uint32_T)localDW->bitsForTID1.is_active_c5_MX_Library == 0U) {
    // Entry: oc_stg_detection/oc_operation_detection
    localDW->bitsForTID1.is_active_c5_MX_Library = 1U;

    // Entry Internal: oc_stg_detection/oc_operation_detection
    // Transition: '<S363>:8'
    localDW->bitsForTID1.is_c5_MX_Library = MX_Gateway_IN_NORMAL_ngcs;

    // Entry 'NORMAL': '<S363>:1'
    *rty_diag_state_out = NORMAL;
    *rty_ocstg_check = INACTIVE;
  } else {
    switch (localDW->bitsForTID1.is_c5_MX_Library) {
     case MX_Gateway_IN_DIAG_STATE_ERROR:
      *rty_ocstg_check = INACTIVE;

      // During 'DIAG_STATE_ERROR': '<S363>:5'
      break;

     case MX_Gateway_IN_NORMAL_ngcs:
      *rty_ocstg_check = INACTIVE;

      // During 'NORMAL': '<S363>:1'
      // Unable to distinguish
      // between Open or STG fault
      if (rtu_diag_state_in == OPEN_STG) {
        // Transition: '<S363>:9'
        localDW->bitsForTID1.is_c5_MX_Library = MX_Gate_IN_OPEN_STG_ERROR_RESET;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OPEN_STG_ERROR_RESET': '<S363>:3'
        *rty_diag_state_out = NORMAL;
        *rty_ocstg_check = ACTIVE;
      } else {
        // Overcurrent Fault
        if (rtu_oc_state != NORMAL) {
          // Transition: '<S363>:10'
          localDW->bitsForTID1.is_c5_MX_Library = MX_Gateway_IN_OC_STATE_ERROR;

          // Entry 'OC_STATE_ERROR': '<S363>:2'
          *rty_diag_state_out = rtu_oc_state;
        } else {
          // STB, STG or Open Circuit Fault
          if ((rtu_diag_state_in == SHORT_TO_GROUND) || (rtu_diag_state_in ==
               SHORT_TO_BATTERY) || (rtu_diag_state_in == OPEN_CIRCUIT)) {
            // Transition: '<S363>:12'
            localDW->bitsForTID1.is_c5_MX_Library =
              MX_Gateway_IN_DIAG_STATE_ERROR;

            // Entry 'DIAG_STATE_ERROR': '<S363>:5'
            *rty_diag_state_out = rtu_diag_state_in;
          }
        }
      }
      break;

     case MX_Gateway_IN_OC_STATE_ERROR:
      *rty_ocstg_check = INACTIVE;

      // During 'OC_STATE_ERROR': '<S363>:2'
      break;

     case MX_Gatew_IN_OPEN_STG_DIAG_STATE:
      *rty_ocstg_check = INACTIVE;

      // During 'OPEN_STG_DIAG_STATE': '<S363>:6'
      if ((int32_T)localDW->temporalCounter_i1 >= 5) {
        // Transition: '<S363>:11'
        localDW->bitsForTID1.is_c5_MX_Library = MX_Gateway_IN_OPEN_STG_ERROR;

        // Entry 'OPEN_STG_ERROR': '<S363>:4'
        localDW->debounceCount = 0U;
      }
      break;

     case MX_Gateway_IN_OPEN_STG_ERROR:
      *rty_ocstg_check = INACTIVE;

      // During 'OPEN_STG_ERROR': '<S363>:4'
      if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)((int32_T)
            rtp_OPEN_DB_CNT + (int32_T)rtp_STG_DB_CNT) + 100)) {
        // Transition: '<S363>:15'
        localDW->bitsForTID1.is_c5_MX_Library = MX_Gateway_IN_OPEN_STG_RESET;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OPEN_STG_RESET': '<S363>:7'
        *rty_ocstg_check = RESET;
      } else {
        *rty_diag_state_out = rtu_diag_state_in;

        // Transition: '<S363>:17'
        if (rtu_diag_state_in == NORMAL) {
          // Transition: '<S363>:16'
          localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
            localDW->debounceCount + 1);
        }
      }
      break;

     case MX_Gate_IN_OPEN_STG_ERROR_RESET:
      *rty_ocstg_check = ACTIVE;

      // During 'OPEN_STG_ERROR_RESET': '<S363>:3'
      if ((int32_T)localDW->temporalCounter_i1 >= 5) {
        // Transition: '<S363>:13'
        localDW->bitsForTID1.is_c5_MX_Library = MX_Gatew_IN_OPEN_STG_DIAG_STATE;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OPEN_STG_DIAG_STATE': '<S363>:6'
        *rty_ocstg_check = INACTIVE;
      }
      break;

     default:
      *rty_ocstg_check = RESET;

      // During 'OPEN_STG_RESET': '<S363>:7'
      if ((int32_T)localDW->temporalCounter_i1 >= 50) {
        // Transition: '<S363>:14'
        localDW->bitsForTID1.is_c5_MX_Library = MX_Gateway_IN_NORMAL_ngcs;

        // Entry 'NORMAL': '<S363>:1'
        *rty_diag_state_out = NORMAL;
        *rty_ocstg_check = INACTIVE;
      }
      break;
    }
  }

  // End of Chart: '<S352>/oc_operation_detection'
}

//
//  System initialize for atomic system:
//     '<S321>/hc_pair_control'
//     '<S321>/hc_pair_control1'
//     '<S406>/hc_pair_control'
//     '<S507>/hc_pair_control'
//     '<S507>/hc_pair_control1'

void MX__output_pair_ClosedLoop_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_ClosedLoop_MX_G *localB,
  rtDW_output_pair_ClosedLoop_MX_ *localDW)
{
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S328>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S328>/Unit Delay4'
  localDW->UnitDelay4_DSTATE = ((uint8_T)0U);

  // SystemInitialize for Atomic SubSystem: '<S349>/LP_Filter_Adj_Gain'
  MX_Gate_LP_Filter_Adj_Gain_Init(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemInitialize for SubSystem: '<S349>/LP_Filter_Adj_Gain'

  // SystemInitialize for Atomic SubSystem: '<S328>/oc_stg_detection'
  MX_Gatewa_oc_stg_detection_Init(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemInitialize for SubSystem: '<S328>/oc_stg_detection'

  // SystemInitialize for Chart: '<S328>/control'
  localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_active_c39_MX_Library = 0U;
  localDW->bitsForTID1.is_c39_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  localB->icmd_Out = 0U;
  localB->enable_LoSide = false;

  // SystemInitialize for Atomic SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
  MX_G_hc_pair_ClosedLoop_v5_Init(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_ClosedLoop_v5);

  // End of SystemInitialize for SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
}

//
//  System reset for atomic system:
//     '<S321>/hc_pair_control'
//     '<S321>/hc_pair_control1'
//     '<S406>/hc_pair_control'
//     '<S507>/hc_pair_control'
//     '<S507>/hc_pair_control1'

void MX_output_pair_ClosedLoop_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_ClosedLoop_MX_G *localB,
  rtDW_output_pair_ClosedLoop_MX_ *localDW)
{
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S328>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S328>/Unit Delay4'
  localDW->UnitDelay4_DSTATE = ((uint8_T)0U);

  // SystemReset for Atomic SubSystem: '<S349>/LP_Filter_Adj_Gain'
  MX_Gat_LP_Filter_Adj_Gain_Reset(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemReset for SubSystem: '<S349>/LP_Filter_Adj_Gain'

  // SystemReset for Atomic SubSystem: '<S328>/oc_stg_detection'
  MX_Gatew_oc_stg_detection_Reset(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemReset for SubSystem: '<S328>/oc_stg_detection'

  // SystemReset for Chart: '<S328>/control'
  localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID1.is_active_c39_MX_Library = 0U;
  localDW->bitsForTID1.is_c39_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  localB->icmd_Out = 0U;
  localB->enable_LoSide = false;

  // SystemReset for Atomic SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
  MX__hc_pair_ClosedLoop_v5_Reset(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_ClosedLoop_v5);

  // End of SystemReset for SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
}

//
//  Disable for atomic system:
//     '<S321>/hc_pair_control'
//     '<S321>/hc_pair_control1'
//     '<S406>/hc_pair_control'
//     '<S507>/hc_pair_control'
//     '<S507>/hc_pair_control1'

void output_pair_ClosedLoop_Disable(int16_T *rty_errorCC,
  rtB_output_pair_ClosedLoop_MX_G *localB, rtDW_output_pair_ClosedLoop_MX_
  *localDW)
{
  // Disable for Atomic SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
  M_hc_pair_ClosedLoop_v5_Disable(rty_errorCC, &localB->hc_pair_ClosedLoop_v5,
    &localDW->hc_pair_ClosedLoop_v5);

  // End of Disable for SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
}

//
//  Output and update for atomic system:
//     '<S321>/hc_pair_control'
//     '<S321>/hc_pair_control1'
//     '<S406>/hc_pair_control'
//     '<S507>/hc_pair_control'
//     '<S507>/hc_pair_control1'

void MX_Gatew_output_pair_ClosedLoop(uint16_T rtu_i_cmd, boolean_T
  rtu_enable_STGOffDiag, uint16_T rtu_afbk_A2D, uint16_T rtu_ifbk_A2D, uint8_T
  rtu_state_Vbattery, uint8_T rtu_state_Engine, uint16_T rtu_calc_Vbattery,
  uint16_T rtu_ain_PrecRef, uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd, int16_T
  *rty_errorCC, uint16_T *rty_calc_ifbk, uint8_T *rty_state_Output,
  rtB_output_pair_ClosedLoop_MX_G *localB, rtDW_output_pair_ClosedLoop_MX_
  *localDW, uint16_T rtp_OPEN_DB_CNT, uint16_T rtp_STG_DB_CNT, uint16_T rtp_KP,
  uint16_T rtp_KI, uint16_T rtp_IFBK_MAX, uint16_T rtp_NZ_DUTY, uint16_T
  rtp_NZ_IFBK, uint16_T rtp_OC_DB_CNT, uint16_T rtp_OSTG_DB_CNT, uint16_T
  rtp_STB_DB_CNT, uint8_T rtp_BIDIRECTIONAL_CTRL, uint16_T rtp_AFBK_GAIN,
  uint16_T rtp_IFBK_GAIN)
{
  uint16_T rtb_DataTypeConversion1_kha5;
  uint8_T rtb_ocstg_check;
  boolean_T rtb_LogicalOperator2_d2ht;
  int16_T rtb_DataTypeConversion_mxva;
  uint8_T rtb_UnitDelay1_dj5h;
  uint8_T rtb_UnitDelay4;
  uint16_T rtb_Gain_ftue;
  uint32_T tmp;

  // Gain: '<S328>/Gain'
  tmp = (uint32_T)((uint32_T)rtp_AFBK_GAIN * (uint32_T)rtu_afbk_A2D);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Gain_ftue = (uint16_T)tmp;

  // End of Gain: '<S328>/Gain'

  // Logic: '<S328>/Logical Operator2' incorporates:
  //   Constant: '<S347>/Constant'
  //   Constant: '<S348>/Constant'
  //   RelationalOperator: '<S347>/Compare'
  //   RelationalOperator: '<S348>/Compare'

  rtb_LogicalOperator2_d2ht = ((rtu_state_Vbattery != OORL) && (rtu_state_Engine
    != ENGINE_CRANKING));

  // UnitDelay: '<S328>/Unit Delay1'
  rtb_UnitDelay1_dj5h = localDW->UnitDelay1_DSTATE;

  // UnitDelay: '<S328>/Unit Delay4'
  rtb_UnitDelay4 = localDW->UnitDelay4_DSTATE;

  // DataTypeConversion: '<S349>/Data Type Conversion'
  rtb_DataTypeConversion_mxva = (int16_T)rtu_ain_PrecRef;

  // Outputs for Atomic SubSystem: '<S349>/LP_Filter_Adj_Gain'

  // Constant: '<S349>/Constant'
  MX_Gateway_LP_Filter_Adj_Gain(((uint8_T)6U), rtb_DataTypeConversion_mxva,
    &localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of Outputs for SubSystem: '<S349>/LP_Filter_Adj_Gain'

  // DataTypeConversion: '<S349>/Data Type Conversion1'
  rtb_DataTypeConversion1_kha5 = (uint16_T)(int32_T)(localB->Output >> 16);

  // Switch: '<S349>/Switch' incorporates:
  //   Constant: '<S349>/Constant1'
  //   Constant: '<S353>/Lower Limit'
  //   Constant: '<S353>/Upper Limit'
  //   Logic: '<S353>/AND'
  //   RelationalOperator: '<S353>/Lower Test'
  //   RelationalOperator: '<S353>/Upper Test'

  if ((((uint16_T)465U) < rtb_DataTypeConversion1_kha5) &&
      (rtb_DataTypeConversion1_kha5 < ((uint16_T)569U))) {
  } else {
    rtb_DataTypeConversion1_kha5 = CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE;
  }

  // End of Switch: '<S349>/Switch'

  // Gain: '<S328>/Gain1'
  tmp = (uint32_T)((uint32_T)((uint32_T)rtp_IFBK_GAIN * (uint32_T)rtu_ifbk_A2D) >>
                   4);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  // Product: '<S349>/Divide' incorporates:
  //   Constant: '<S349>/Constant1'
  //   Gain: '<S328>/Gain1'
  //   Product: '<S349>/Divide1'

  *rty_calc_ifbk = (uint16_T)(uint32_T)((uint32_T)(tmp * (uint32_T)(uint16_T)
    ((uint32_T)rtb_DataTypeConversion1_kha5 == 0U ? MAX_uint32_T : (uint32_T)
     ((uint32_T)((uint32_T)CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE << 15) /
      (uint32_T)rtb_DataTypeConversion1_kha5))) >> 15);

  // Outputs for Atomic SubSystem: '<S328>/oc_stg_detection'
  MX_Gateway_oc_stg_detection(rtb_UnitDelay1_dj5h, rtb_UnitDelay4,
    &localB->diag_state_out, &rtb_ocstg_check, &localDW->oc_stg_detection,
    rtp_OPEN_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S328>/oc_stg_detection'

  // Chart: '<S328>/control'
  // Gateway: output_pair_ClosedLoop/control
  // During: output_pair_ClosedLoop/control
  if ((uint32_T)localDW->bitsForTID1.is_active_c39_MX_Library == 0U) {
    // Entry: output_pair_ClosedLoop/control
    localDW->bitsForTID1.is_active_c39_MX_Library = 1U;

    // Entry Internal: output_pair_ClosedLoop/control
    // Transition: '<S350>:28'
    localDW->bitsForTID1.is_c39_MX_Library = MX_Gateway_IN_FUNCTIONAL;

    // Entry Internal 'FUNCTIONAL': '<S350>:11'
    // Transition: '<S350>:26'
    localDW->bitsForTID1.is_FUNCTIONAL = MX_Gatewa_IN_STGOFF_DIAG_ACTIVE;

    // Entry 'STGOFF_DIAG_ACTIVE': '<S350>:1'
    localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
    *rty_state_Output = INACTIVE;

    // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S350>:1'
    // Transition: '<S350>:37'
    localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC;

    // Entry 'Test_OC': '<S350>:8'
    localDW->debounceCount = 0U;
    localB->enable_LoSide = ((int32_T)ACTIVE != 0);
  } else {
    switch (localDW->bitsForTID1.is_c39_MX_Library) {
     case MX_Gateway_IN_DIAG_CHECK:
      // During 'DIAG_CHECK': '<S350>:4'
      // Couldn't find a fault, so go back to working
      // ?? should this condition really be recoverable??
      if (rtb_ocstg_check == RESET) {
        // Transition: '<S350>:18'
        // Exit Internal 'DIAG_CHECK': '<S350>:4'
        localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
        localDW->bitsForTID1.is_c39_MX_Library = MX_Gateway_IN_FUNCTIONAL;

        // Entry Internal 'FUNCTIONAL': '<S350>:11'
        // Transition: '<S350>:26'
        localDW->bitsForTID1.is_FUNCTIONAL = MX_Gatewa_IN_STGOFF_DIAG_ACTIVE;

        // Entry 'STGOFF_DIAG_ACTIVE': '<S350>:1'
        localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
        *rty_state_Output = INACTIVE;

        // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S350>:1'
        // Transition: '<S350>:37'
        localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC;

        // Entry 'Test_OC': '<S350>:8'
        localDW->debounceCount = 0U;
        localB->enable_LoSide = ((int32_T)ACTIVE != 0);
      } else {
        // Fault Detected
        if (localB->diag_state_out != NORMAL) {
          // Transition: '<S350>:29'
          // Exit Internal 'DIAG_CHECK': '<S350>:4'
          localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
          localDW->bitsForTID1.is_c39_MX_Library = MX_Gateway_IN_ERROR;

          // Entry 'ERROR': '<S350>:12'
          localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
          localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          *rty_state_Output = localB->diag_state_out;
        } else if (localDW->bitsForTID1.is_DIAG_CHECK ==
                   MX_Gateway_IN_ENABLE_OFF) {
          // During 'ENABLE_OFF': '<S350>:6'
        } else {
          // During 'ENABLE_ON': '<S350>:5'
          // Give it some time to ensure low side is on
          // and detect open circuit
          if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
               rtp_OPEN_DB_CNT + 100)) {
            // Transition: '<S350>:24'
            localDW->bitsForTID1.is_DIAG_CHECK = MX_Gateway_IN_ENABLE_OFF;

            // Entry 'ENABLE_OFF': '<S350>:6'
            localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          } else {
            localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
              localDW->debounceCount + 1);
          }
        }
      }
      break;

     case MX_Gateway_IN_ERROR:
      // During 'ERROR': '<S350>:12'
      break;

     default:
      // During 'FUNCTIONAL': '<S350>:11'
      // Fault Detected
      if (localB->diag_state_out != NORMAL) {
        // Transition: '<S350>:30'
        // Exit Internal 'FUNCTIONAL': '<S350>:11'
        // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S350>:1'
        localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
          MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
        localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;

        // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S350>:2'
        localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
          MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
        localDW->bitsForTID1.is_c39_MX_Library = MX_Gateway_IN_ERROR;

        // Entry 'ERROR': '<S350>:12'
        localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
        localB->enable_LoSide = ((int32_T)INACTIVE != 0);
        *rty_state_Output = localB->diag_state_out;
      } else {
        // Open or STG Fault detected
        // while output is on
        if (rtb_ocstg_check == ACTIVE) {
          // Transition: '<S350>:25'
          // Exit Internal 'FUNCTIONAL': '<S350>:11'
          // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S350>:1'
          localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
          localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_jgad;

          // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S350>:2'
          localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
          localDW->bitsForTID1.is_c39_MX_Library = MX_Gateway_IN_DIAG_CHECK;

          // Entry 'DIAG_CHECK': '<S350>:4'
          localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);

          // Entry Internal 'DIAG_CHECK': '<S350>:4'
          // Transition: '<S350>:23'
          localDW->bitsForTID1.is_DIAG_CHECK = MX_Gateway_IN_ENABLE_ON;

          // Entry 'ENABLE_ON': '<S350>:5'
          localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          localDW->debounceCount = 0U;
        } else if (localDW->bitsForTID1.is_FUNCTIONAL ==
                   MX_Gatewa_IN_STGOFF_DIAG_ACTIVE) {
          // During 'STGOFF_DIAG_ACTIVE': '<S350>:1'
          if (!rtu_enable_STGOffDiag) {
            // Transition: '<S350>:19'
            // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S350>:1'
            localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
              MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
            localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_STGOFF_DIAG_INACTIVE;

            // Entry 'STGOFF_DIAG_INACTIVE': '<S350>:2'
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);

            // Entry Internal 'STGOFF_DIAG_INACTIVE': '<S350>:2'
            // Transition: '<S350>:21'
            localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
              MX_Gateway_IN_ACTIVE_OFF;

            // Entry 'ACTIVE_OFF': '<S350>:13'
            localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
            *rty_state_Output = INACTIVE;
          } else if (localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE ==
                     MX_Gateway_IN_Test_OC) {
            // During 'Test_OC': '<S350>:8'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_OPEN_DB_CNT + 100)) {
              // Transition: '<S350>:36'
              localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
                MX_Gateway_IN_Test_STG;

              // Entry 'Test_STG': '<S350>:9'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)INACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          } else {
            // During 'Test_STG': '<S350>:9'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_STG_DB_CNT + 100)) {
              // Transition: '<S350>:35'
              localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC;

              // Entry 'Test_OC': '<S350>:8'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)ACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          }
        } else {
          // During 'STGOFF_DIAG_INACTIVE': '<S350>:2'
          if (rtu_enable_STGOffDiag) {
            // Transition: '<S350>:20'
            // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S350>:2'
            localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
              MX_Gate_IN_NO_ACTIVE_CHILD_jgad;
            localDW->bitsForTID1.is_FUNCTIONAL = MX_Gatewa_IN_STGOFF_DIAG_ACTIVE;

            // Entry 'STGOFF_DIAG_ACTIVE': '<S350>:1'
            localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
            *rty_state_Output = INACTIVE;

            // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S350>:1'
            // Transition: '<S350>:37'
            localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC;

            // Entry 'Test_OC': '<S350>:8'
            localDW->debounceCount = 0U;
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          } else if (localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE ==
                     MX_Gateway_IN_ACTIVE_OFF) {
            // During 'ACTIVE_OFF': '<S350>:13'
            if ((int32_T)rtu_i_cmd > 0) {
              // Transition: '<S350>:50'
              localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
                MX_Gateway_IN_ACTIVE_ON;

              // Entry 'ACTIVE_ON': '<S350>:3'
              localB->icmd_Out = rtu_i_cmd;
              *rty_state_Output = ACTIVE;
            }
          } else {
            // During 'ACTIVE_ON': '<S350>:3'
            if ((int32_T)rtu_i_cmd == 0) {
              // Transition: '<S350>:22'
              localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
                MX_Gateway_IN_ACTIVE_OFF;

              // Entry 'ACTIVE_OFF': '<S350>:13'
              localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
              *rty_state_Output = INACTIVE;
            } else {
              localB->icmd_Out = rtu_i_cmd;
            }
          }
        }
      }
      break;
    }
  }

  // End of Chart: '<S328>/control'

  // Outputs for Atomic SubSystem: '<S328>/hc_pair_ClosedLoop_v5'
  MX_Gatewa_hc_pair_ClosedLoop_v5(localB->icmd_Out, localB->enable_LoSide,
    rtb_LogicalOperator2_d2ht, rtb_Gain_ftue, rtu_calc_Vbattery, *rty_calc_ifbk,
    rtb_ocstg_check, rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, rty_errorCC, &localB->hc_pair_ClosedLoop_v5,
    &localDW->hc_pair_ClosedLoop_v5, rtp_KP, rtp_KI, rtp_IFBK_MAX, rtp_NZ_DUTY,
    rtp_NZ_IFBK, rtp_OC_DB_CNT, rtp_OPEN_DB_CNT, rtp_OSTG_DB_CNT, rtp_STB_DB_CNT,
    rtp_STG_DB_CNT, rtp_BIDIRECTIONAL_CTRL);

  // End of Outputs for SubSystem: '<S328>/hc_pair_ClosedLoop_v5'

  // Update for UnitDelay: '<S328>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = localB->oc_state;

  // Update for UnitDelay: '<S328>/Unit Delay4'
  localDW->UnitDelay4_DSTATE = localB->diag_state;
}

//
//  Output and update for atomic system:
//     '<S389>/Voltage_Limiter'
//     '<S457>/Voltage_Limiter'
//     '<S476>/Voltage_Limiter'
//     '<S583>/Voltage_Limiter'

void MX_Gateway_Voltage_Limiter(uint16_T rtu_calc_VBattery, uint16_T rtu_duty_in,
  uint16_T *rty_duty_out, uint16_T rtp_MAX_VOLTS)
{
  uint16_T rtb_Saturation_bsq0;
  uint32_T tmp;

  // Product: '<S393>/Divide' incorporates:
  //   Constant: '<S393>/FunctionState2'

  tmp = (uint32_T)rtu_calc_VBattery == 0U ? MAX_uint32_T : (uint32_T)((uint32_T)
    ((uint32_T)rtp_MAX_VOLTS << 12) / (uint32_T)rtu_calc_VBattery);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Saturation_bsq0 = (uint16_T)tmp;

  // Saturate: '<S393>/Saturation' incorporates:
  //   Product: '<S393>/Divide'

  if ((uint16_T)tmp < ((uint16_T)4096U)) {
  } else {
    rtb_Saturation_bsq0 = ((uint16_T)4096U);
  }

  // End of Saturate: '<S393>/Saturation'

  // Product: '<S393>/Divide1'
  tmp = (uint32_T)((uint32_T)((uint32_T)rtu_duty_in * (uint32_T)
    rtb_Saturation_bsq0) >> 12);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  *rty_duty_out = (uint16_T)tmp;

  // End of Product: '<S393>/Divide1'
}

//
//  System initialize for atomic system:
//     '<S386>/output_pair_open_loop'
//     '<S454>/output_pair_open_loop'
//     '<S473>/output_pair_open_loop'

void MX_Ga_output_pair_OpenLoop_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_OpenLoop_MX_Gat *localB,
  rtDW_output_pair_OpenLoop_MX_Ga *localDW)
{
  uint16_T rtb_duty_Output;
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S389>/Unit Delay2'
  localDW->UnitDelay2_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S389>/Unit Delay3'
  localDW->UnitDelay3_DSTATE = ((uint8_T)0U);

  // SystemInitialize for Atomic SubSystem: '<S389>/oc_stg_detection'
  MX_Gatewa_oc_stg_detection_Init(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemInitialize for SubSystem: '<S389>/oc_stg_detection'

  // SystemInitialize for Chart: '<S389>/control'
  localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_active_c51_MX_Library = 0U;
  localDW->bitsForTID1.is_c51_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  rtb_duty_Output = 0U;
  localB->enable_LoSide = false;

  // SystemInitialize for Atomic SubSystem: '<S394>/LP_Filter_Adj_Gain'
  MX_Gate_LP_Filter_Adj_Gain_Init(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemInitialize for SubSystem: '<S394>/LP_Filter_Adj_Gain'

  // SystemInitialize for Atomic SubSystem: '<S389>/hc_pair_OpenLoop'
  MX_Gatewa_hc_pair_OpenLoop_Init(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemInitialize for SubSystem: '<S389>/hc_pair_OpenLoop'
}

//
//  System reset for atomic system:
//     '<S386>/output_pair_open_loop'
//     '<S454>/output_pair_open_loop'
//     '<S473>/output_pair_open_loop'

void MX_G_output_pair_OpenLoop_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_OpenLoop_MX_Gat *localB,
  rtDW_output_pair_OpenLoop_MX_Ga *localDW)
{
  uint16_T rtb_duty_Output;
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S389>/Unit Delay2'
  localDW->UnitDelay2_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S389>/Unit Delay3'
  localDW->UnitDelay3_DSTATE = ((uint8_T)0U);

  // SystemReset for Atomic SubSystem: '<S389>/oc_stg_detection'
  MX_Gatew_oc_stg_detection_Reset(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemReset for SubSystem: '<S389>/oc_stg_detection'

  // SystemReset for Chart: '<S389>/control'
  localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID1.is_active_c51_MX_Library = 0U;
  localDW->bitsForTID1.is_c51_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  rtb_duty_Output = 0U;
  localB->enable_LoSide = false;

  // SystemReset for Atomic SubSystem: '<S394>/LP_Filter_Adj_Gain'
  MX_Gat_LP_Filter_Adj_Gain_Reset(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemReset for SubSystem: '<S394>/LP_Filter_Adj_Gain'

  // SystemReset for Atomic SubSystem: '<S389>/hc_pair_OpenLoop'
  MX_Gatew_hc_pair_OpenLoop_Reset(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemReset for SubSystem: '<S389>/hc_pair_OpenLoop'
}

//
//  Output and update for atomic system:
//     '<S386>/output_pair_open_loop'
//     '<S454>/output_pair_open_loop'
//     '<S473>/output_pair_open_loop'

void MX_Gateway_output_pair_OpenLoop(boolean_T rtu_cmd_Output, boolean_T
  rtu_enable_STGOffDiag, uint8_T rtu_state_Engine, uint16_T rtu_afbk_A2D,
  uint16_T rtu_ifbk_A2D, uint8_T rtu_state_VBattery, uint16_T rtu_calc_VBattery,
  uint16_T rtu_ain_PrecRef, uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd, uint8_T
  *rty_state_Output, rtB_output_pair_OpenLoop_MX_Gat *localB,
  rtDW_output_pair_OpenLoop_MX_Ga *localDW, uint16_T rtp_MAX_VOLTS, uint16_T
  rtp_OPEN_DB_CNT, uint16_T rtp_STG_DB_CNT, uint16_T rtp_IFBK_MAX, uint16_T
  rtp_NZ_DUTY, uint16_T rtp_NZ_IFBK, uint16_T rtp_OC_DB_CNT, uint16_T
  rtp_OSTG_DB_CNT, uint16_T rtp_STB_DB_CNT, uint8_T rtp_FEEDBACK_ENABLE,
  uint16_T rtp_AFBK_GAIN, uint16_T rtp_IFBK_GAIN)
{
  uint16_T rtb_DataTypeConversion1_ptgy;
  uint16_T rtb_duty_Output;
  uint8_T rtb_ocstg_check;
  boolean_T rtb_LogicalOperator1_kyfp;
  int16_T rtb_DataTypeConversion_cdc3;
  uint8_T rtb_oc_state;
  uint8_T rtb_diag_state;
  uint16_T rtb_Gain2;
  uint16_T rtb_Divide_if5c;
  uint16_T rtb_Divide1_hbnh;
  uint32_T tmp;

  // Gain: '<S389>/Gain2'
  tmp = (uint32_T)((uint32_T)rtp_AFBK_GAIN * (uint32_T)rtu_afbk_A2D);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Gain2 = (uint16_T)tmp;

  // End of Gain: '<S389>/Gain2'

  // Logic: '<S389>/Logical Operator1' incorporates:
  //   Constant: '<S389>/FunctionState1'
  //   Constant: '<S390>/Constant'
  //   Constant: '<S391>/Constant'
  //   Constant: '<S392>/Constant'
  //   RelationalOperator: '<S390>/Compare'
  //   RelationalOperator: '<S391>/Compare'
  //   RelationalOperator: '<S392>/Compare'

  rtb_LogicalOperator1_kyfp = ((rtp_FEEDBACK_ENABLE != NON_FUNCTIONAL) &&
    (rtu_state_VBattery != OORL) && (rtu_state_Engine != ENGINE_CRANKING));

  // UnitDelay: '<S389>/Unit Delay2'
  rtb_oc_state = localDW->UnitDelay2_DSTATE;

  // UnitDelay: '<S389>/Unit Delay3'
  rtb_diag_state = localDW->UnitDelay3_DSTATE;

  // Outputs for Atomic SubSystem: '<S389>/oc_stg_detection'
  MX_Gateway_oc_stg_detection(rtb_oc_state, rtb_diag_state,
    &localB->diag_state_out, &rtb_ocstg_check, &localDW->oc_stg_detection,
    rtp_OPEN_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S389>/oc_stg_detection'

  // Chart: '<S389>/control'
  // Gateway: output_pair_OpenLoop/control
  // During: output_pair_OpenLoop/control
  if ((uint32_T)localDW->bitsForTID1.is_active_c51_MX_Library == 0U) {
    // Entry: output_pair_OpenLoop/control
    localDW->bitsForTID1.is_active_c51_MX_Library = 1U;

    // Entry Internal: output_pair_OpenLoop/control
    // Transition: '<S395>:28'
    localDW->bitsForTID1.is_c51_MX_Library = MX_Gateway_IN_FUNCTIONAL_blpp;

    // Entry Internal 'FUNCTIONAL': '<S395>:11'
    // Transition: '<S395>:26'
    localDW->bitsForTID1.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

    // Entry 'STGOFF_DIAG_ACTIVE': '<S395>:1'
    rtb_duty_Output = 0U;
    *rty_state_Output = INACTIVE;

    // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
    // Transition: '<S395>:37'
    localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC_dpgv;

    // Entry 'Test_OC': '<S395>:8'
    localDW->debounceCount = 0U;
    localB->enable_LoSide = ((int32_T)ACTIVE != 0);
  } else {
    switch (localDW->bitsForTID1.is_c51_MX_Library) {
     case MX_Gateway_IN_DIAG_CHECK_gfxy:
      rtb_duty_Output = 0U;

      // During 'DIAG_CHECK': '<S395>:4'
      // Couldn't find a fault, so go back to working
      // ?? should this condition really be recoverable??
      if (rtb_ocstg_check == RESET) {
        // Transition: '<S395>:18'
        // Exit Internal 'DIAG_CHECK': '<S395>:4'
        localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
        localDW->bitsForTID1.is_c51_MX_Library = MX_Gateway_IN_FUNCTIONAL_blpp;

        // Entry Internal 'FUNCTIONAL': '<S395>:11'
        // Transition: '<S395>:26'
        localDW->bitsForTID1.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

        // Entry 'STGOFF_DIAG_ACTIVE': '<S395>:1'
        *rty_state_Output = INACTIVE;

        // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
        // Transition: '<S395>:37'
        localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC_dpgv;

        // Entry 'Test_OC': '<S395>:8'
        localDW->debounceCount = 0U;
        localB->enable_LoSide = ((int32_T)ACTIVE != 0);
      } else {
        // Fault Detected
        if (localB->diag_state_out != NORMAL) {
          // Transition: '<S395>:29'
          // Exit Internal 'DIAG_CHECK': '<S395>:4'
          localDW->bitsForTID1.is_DIAG_CHECK = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
          localDW->bitsForTID1.is_c51_MX_Library = MX_Gateway_IN_ERROR_jnvd;

          // Entry 'ERROR': '<S395>:12'
          localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          *rty_state_Output = localB->diag_state_out;
        } else if (localDW->bitsForTID1.is_DIAG_CHECK ==
                   MX_Gateway_IN_ENABLE_OFF_ifnc) {
          // During 'ENABLE_OFF': '<S395>:6'
        } else {
          // During 'ENABLE_ON': '<S395>:5'
          // Give it some time to ensure low side is on
          // and detect open circuit
          if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
               rtp_OPEN_DB_CNT + 100)) {
            // Transition: '<S395>:24'
            localDW->bitsForTID1.is_DIAG_CHECK = MX_Gateway_IN_ENABLE_OFF_ifnc;

            // Entry 'ENABLE_OFF': '<S395>:6'
            localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          } else {
            localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
              localDW->debounceCount + 1);
          }
        }
      }
      break;

     case MX_Gateway_IN_ERROR_jnvd:
      rtb_duty_Output = 0U;

      // During 'ERROR': '<S395>:12'
      if (localB->diag_state_out == NORMAL) {
        // Transition: '<S395>:127'
        localDW->bitsForTID1.is_c51_MX_Library = MX_Gateway_IN_FUNCTIONAL_blpp;

        // Entry Internal 'FUNCTIONAL': '<S395>:11'
        // Transition: '<S395>:26'
        localDW->bitsForTID1.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

        // Entry 'STGOFF_DIAG_ACTIVE': '<S395>:1'
        *rty_state_Output = INACTIVE;

        // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
        // Transition: '<S395>:37'
        localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE = MX_Gateway_IN_Test_OC_dpgv;

        // Entry 'Test_OC': '<S395>:8'
        localDW->debounceCount = 0U;
        localB->enable_LoSide = ((int32_T)ACTIVE != 0);
      }
      break;

     default:
      // During 'FUNCTIONAL': '<S395>:11'
      // Fault Detected
      if (localB->diag_state_out != NORMAL) {
        // Transition: '<S395>:30'
        // Exit Internal 'FUNCTIONAL': '<S395>:11'
        // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
        localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
          MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
        localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;

        // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S395>:2'
        localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
          MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
        localDW->bitsForTID1.is_c51_MX_Library = MX_Gateway_IN_ERROR_jnvd;

        // Entry 'ERROR': '<S395>:12'
        rtb_duty_Output = 0U;
        localB->enable_LoSide = ((int32_T)INACTIVE != 0);
        *rty_state_Output = localB->diag_state_out;
      } else {
        // Open or STG Fault detected
        // while output is on
        if (rtb_ocstg_check == ACTIVE) {
          // Transition: '<S395>:25'
          // Exit Internal 'FUNCTIONAL': '<S395>:11'
          // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
          localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
          localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_eulg;

          // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S395>:2'
          localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
            MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
          localDW->bitsForTID1.is_c51_MX_Library = MX_Gateway_IN_DIAG_CHECK_gfxy;

          // Entry 'DIAG_CHECK': '<S395>:4'
          rtb_duty_Output = 0U;

          // Entry Internal 'DIAG_CHECK': '<S395>:4'
          // Transition: '<S395>:23'
          localDW->bitsForTID1.is_DIAG_CHECK = MX_Gateway_IN_ENABLE_ON_p4th;

          // Entry 'ENABLE_ON': '<S395>:5'
          localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          localDW->debounceCount = 0U;
        } else if (localDW->bitsForTID1.is_FUNCTIONAL ==
                   MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz) {
          rtb_duty_Output = 0U;

          // During 'STGOFF_DIAG_ACTIVE': '<S395>:1'
          if (!rtu_enable_STGOffDiag) {
            // Transition: '<S395>:19'
            // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
            localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
              MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
            localDW->bitsForTID1.is_FUNCTIONAL = MX_IN_STGOFF_DIAG_INACTIVE_o1ij;

            // Entry 'STGOFF_DIAG_INACTIVE': '<S395>:2'
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);

            // Entry Internal 'STGOFF_DIAG_INACTIVE': '<S395>:2'
            // Transition: '<S395>:21'
            localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
              MX_Gateway_IN_ACTIVE_OFF_o5z1;

            // Entry 'ACTIVE_OFF': '<S395>:13'
            *rty_state_Output = INACTIVE;
          } else if (localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE ==
                     MX_Gateway_IN_Test_OC_dpgv) {
            // During 'Test_OC': '<S395>:8'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_OPEN_DB_CNT + 100)) {
              // Transition: '<S395>:36'
              localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
                MX_Gateway_IN_Test_STG_a1mc;

              // Entry 'Test_STG': '<S395>:9'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)INACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          } else {
            // During 'Test_STG': '<S395>:9'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_STG_DB_CNT + 100)) {
              // Transition: '<S395>:35'
              localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
                MX_Gateway_IN_Test_OC_dpgv;

              // Entry 'Test_OC': '<S395>:8'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)ACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          }
        } else {
          // During 'STGOFF_DIAG_INACTIVE': '<S395>:2'
          if (rtu_enable_STGOffDiag) {
            // Transition: '<S395>:20'
            // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S395>:2'
            localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
              MX_Gate_IN_NO_ACTIVE_CHILD_eulg;
            localDW->bitsForTID1.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

            // Entry 'STGOFF_DIAG_ACTIVE': '<S395>:1'
            rtb_duty_Output = 0U;
            *rty_state_Output = INACTIVE;

            // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S395>:1'
            // Transition: '<S395>:37'
            localDW->bitsForTID1.is_STGOFF_DIAG_ACTIVE =
              MX_Gateway_IN_Test_OC_dpgv;

            // Entry 'Test_OC': '<S395>:8'
            localDW->debounceCount = 0U;
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          } else if (localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE ==
                     MX_Gateway_IN_ACTIVE_OFF_o5z1) {
            rtb_duty_Output = 0U;

            // During 'ACTIVE_OFF': '<S395>:13'
            if (rtu_cmd_Output == (int32_T)ACTIVE) {
              // Transition: '<S395>:50'
              localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
                MX_Gateway_IN_ACTIVE_ON_aqdk;

              // Entry 'ACTIVE_ON': '<S395>:3'
              rtb_duty_Output = FULL_ON;
              *rty_state_Output = ACTIVE;
            }
          } else {
            rtb_duty_Output = FULL_ON;

            // During 'ACTIVE_ON': '<S395>:3'
            if (rtu_cmd_Output != (int32_T)ACTIVE) {
              // Transition: '<S395>:22'
              localDW->bitsForTID1.is_STGOFF_DIAG_INACTIVE =
                MX_Gateway_IN_ACTIVE_OFF_o5z1;

              // Entry 'ACTIVE_OFF': '<S395>:13'
              rtb_duty_Output = 0U;
              *rty_state_Output = INACTIVE;
            }
          }
        }
      }
      break;
    }
  }

  // End of Chart: '<S389>/control'

  // Outputs for Atomic SubSystem: '<S389>/Voltage_Limiter'
  MX_Gateway_Voltage_Limiter(rtu_calc_VBattery, rtb_duty_Output,
    &rtb_Divide1_hbnh, rtp_MAX_VOLTS);

  // End of Outputs for SubSystem: '<S389>/Voltage_Limiter'

  // DataTypeConversion: '<S394>/Data Type Conversion'
  rtb_DataTypeConversion_cdc3 = (int16_T)rtu_ain_PrecRef;

  // Outputs for Atomic SubSystem: '<S394>/LP_Filter_Adj_Gain'

  // Constant: '<S394>/Constant'
  MX_Gateway_LP_Filter_Adj_Gain(((uint8_T)6U), rtb_DataTypeConversion_cdc3,
    &localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of Outputs for SubSystem: '<S394>/LP_Filter_Adj_Gain'

  // DataTypeConversion: '<S394>/Data Type Conversion1'
  rtb_DataTypeConversion1_ptgy = (uint16_T)(int32_T)(localB->Output >> 16);

  // Switch: '<S394>/Switch' incorporates:
  //   Constant: '<S394>/Constant1'
  //   Constant: '<S398>/Lower Limit'
  //   Constant: '<S398>/Upper Limit'
  //   Logic: '<S398>/AND'
  //   RelationalOperator: '<S398>/Lower Test'
  //   RelationalOperator: '<S398>/Upper Test'

  if ((((uint16_T)465U) < rtb_DataTypeConversion1_ptgy) &&
      (rtb_DataTypeConversion1_ptgy < ((uint16_T)569U))) {
  } else {
    rtb_DataTypeConversion1_ptgy = CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE;
  }

  // End of Switch: '<S394>/Switch'

  // Gain: '<S389>/Gain3'
  tmp = (uint32_T)((uint32_T)((uint32_T)rtp_IFBK_GAIN * (uint32_T)rtu_ifbk_A2D) >>
                   4);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  // Product: '<S394>/Divide' incorporates:
  //   Constant: '<S394>/Constant1'
  //   Gain: '<S389>/Gain3'
  //   Product: '<S394>/Divide1'

  rtb_Divide_if5c = (uint16_T)(uint32_T)((uint32_T)(tmp * (uint32_T)(uint16_T)
    ((uint32_T)rtb_DataTypeConversion1_ptgy == 0U ? MAX_uint32_T : (uint32_T)
     ((uint32_T)((uint32_T)CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE << 15) /
      (uint32_T)rtb_DataTypeConversion1_ptgy))) >> 15);

  // Outputs for Atomic SubSystem: '<S389>/hc_pair_OpenLoop'
  MX_Gateway_hc_pair_OpenLoop(rtb_Divide1_hbnh, localB->enable_LoSide,
    rtb_LogicalOperator1_kyfp, rtb_Gain2, rtu_calc_VBattery, rtb_Divide_if5c,
    rtb_ocstg_check, rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_OpenLoop, rtp_IFBK_MAX, rtp_NZ_DUTY,
    rtp_NZ_IFBK, rtp_OC_DB_CNT, rtp_OPEN_DB_CNT, rtp_OSTG_DB_CNT, rtp_STB_DB_CNT,
    rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S389>/hc_pair_OpenLoop'

  // Update for UnitDelay: '<S389>/Unit Delay2'
  localDW->UnitDelay2_DSTATE = localB->oc_state;

  // Update for UnitDelay: '<S389>/Unit Delay3'
  localDW->UnitDelay3_DSTATE = localB->diag_state;
}

//
//  System initialize for enable system:
//     '<S427>/relay_oc'
//     '<S310>/relay_oc'
//     '<S314>/relay_oc'
//     '<S316>/relay_oc'
//     '<S317>/relay_oc'
//     '<S319>/relay_oc'

void MX_Gateway_relay_oc_Init(uint8_T *rty_state_Output, uint8_T
  *rty_state_Relay, rtB_relay_oc_MX_Gateway *localB, rtDW_relay_oc_MX_Gateway
  *localDW)
{
  // SystemInitialize for Chart: '<S432>/relay_error_state'
  localDW->bitsForTID1.is_STATE_OUTPUT = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_OUTPUT = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_ERROR_OFF_cild = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_ERROR_ON_lmya = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_FAILURE = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_NORMAL_food = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_STATE_RELAY = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_RELAY = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_ERROR_OFF = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_ERROR_ON = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_NORMAL = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID1.is_active_c3_MX_Library = 0U;
  localDW->debounceOutput = 0U;
  localDW->debounceRelay = 0U;
  localB->state_Relay = 0U;
  localB->state_Output = 0U;

  // SystemInitialize for Outport: '<S432>/state_Output'
  *rty_state_Output = ((uint8_T)8U);

  // SystemInitialize for Outport: '<S432>/state_Relay'
  *rty_state_Relay = ((uint8_T)8U);
}

//
//  Disable for enable system:
//     '<S427>/relay_oc'
//     '<S310>/relay_oc'
//     '<S314>/relay_oc'
//     '<S316>/relay_oc'
//     '<S317>/relay_oc'
//     '<S319>/relay_oc'

void MX_Gateway_relay_oc_Disable(uint8_T *rty_state_Output, uint8_T
  *rty_state_Relay, rtDW_relay_oc_MX_Gateway *localDW)
{
  // Outputs for Enabled SubSystem: '<S427>/relay_oc' incorporates:
  //   EnablePort: '<S432>/Enable'

  // Disable for Outport: '<S432>/state_Output'
  *rty_state_Output = ((uint8_T)8U);

  // Disable for Outport: '<S432>/state_Relay'
  *rty_state_Relay = ((uint8_T)8U);

  // End of Outputs for SubSystem: '<S427>/relay_oc'
  localDW->relay_oc_MODE = false;
}

//
//  Output and update for enable system:
//     '<S427>/relay_oc'
//     '<S310>/relay_oc'
//     '<S314>/relay_oc'
//     '<S316>/relay_oc'
//     '<S317>/relay_oc'
//     '<S319>/relay_oc'

void MX_Gateway_relay_oc(boolean_T rtu_Enable, boolean_T rtu_cmd, boolean_T
  rtu_dfbk, boolean_T rtu_din, uint8_T *rty_state_Output, uint8_T
  *rty_state_Relay, rtB_relay_oc_MX_Gateway *localB, rtDW_relay_oc_MX_Gateway
  *localDW, uint16_T rtp_ERROR_OFF_DB_CNT, uint16_T rtp_ERROR_ON_DB_CNT,
  uint16_T rtp_NORMAL_DB_CNT)
{
  // Outputs for Enabled SubSystem: '<S427>/relay_oc' incorporates:
  //   EnablePort: '<S432>/Enable'

  if (rtu_Enable) {
    if (!localDW->relay_oc_MODE) {
      localDW->relay_oc_MODE = true;
    }

    // Chart: '<S432>/relay_error_state'
    // Gateway: relay_oc/relay_error_state
    // During: relay_oc/relay_error_state
    if ((uint32_T)localDW->bitsForTID1.is_active_c3_MX_Library == 0U) {
      // Entry: relay_oc/relay_error_state
      localDW->bitsForTID1.is_active_c3_MX_Library = 1U;

      // Entry Internal: relay_oc/relay_error_state
      // Entry Internal 'STATE_OUTPUT': '<S433>:30'
      // Transition: '<S433>:121'
      localDW->bitsForTID1.is_STATE_OUTPUT = MX_Gateway_IN_OUTPUT;

      // Entry Internal 'OUTPUT': '<S433>:82'
      // Transition: '<S433>:31'
      localB->state_Output = NORMAL;
      localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_NORMAL_pqen;

      // Entry Internal 'NORMAL': '<S433>:36'
      // Transition: '<S433>:49'
      localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_DEBOUNCE_mmz1;

      // Entry 'DEBOUNCE': '<S433>:48'
      localDW->debounceOutput = 0U;

      // Entry Internal 'STATE_RELAY': '<S433>:124'
      // Transition: '<S433>:125'
      localDW->bitsForTID1.is_STATE_RELAY = MX_Gateway_IN_RELAY;

      // Entry Internal 'RELAY': '<S433>:128'
      // Transition: '<S433>:131'
      localB->state_Relay = NORMAL;
      localDW->bitsForTID1.is_RELAY = MX_Gateway_IN_NORMAL_pqenz;

      // Entry Internal 'NORMAL': '<S433>:148'
      // Transition: '<S433>:149'
      localDW->bitsForTID1.is_NORMAL = MX_Gateway_IN_DEBOUNCE_mmz1;

      // Entry 'DEBOUNCE': '<S433>:151'
      localDW->debounceRelay = 0U;
    } else {
      // During 'STATE_OUTPUT': '<S433>:30'
      if (localDW->bitsForTID1.is_STATE_OUTPUT == MX_Gateway_IN_OUTPUT) {
        // During 'OUTPUT': '<S433>:82'
        if ((localB->state_Relay != NORMAL) && (localB->state_Output == NORMAL))
        {
          // Transition: '<S433>:120'
          // Exit Internal 'OUTPUT': '<S433>:82'
          // Exit Internal 'ERROR_OFF': '<S433>:52'
          localDW->bitsForTID1.is_ERROR_OFF_cild =
            MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID1.is_OUTPUT = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'ERROR_ON': '<S433>:42'
          localDW->bitsForTID1.is_ERROR_ON_lmya =
            MX_Gate_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'FAILURE': '<S433>:64'
          localDW->bitsForTID1.is_FAILURE = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'NORMAL': '<S433>:36'
          localDW->bitsForTID1.is_NORMAL_food = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'OPEN_CIRCUIT': '<S433>:57'
          localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID1.is_STATE_OUTPUT = MX_Gateway_IN_RELAY;
        } else {
          switch (localDW->bitsForTID1.is_OUTPUT) {
           case MX_Gateway_IN_ERROR_OFF:
            // During 'ERROR_OFF': '<S433>:52'
            if (((!rtu_cmd) || rtu_dfbk || rtu_din) && ((localB->state_Output ==
                  NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S433>:76'
              // Exit Internal 'ERROR_OFF': '<S433>:52'
              localDW->bitsForTID1.is_ERROR_OFF_cild =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S433>:36'
              // Transition: '<S433>:49'
              localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID1.is_ERROR_OFF_cild ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:55'
              if ((localDW->debounceOutput >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Output == ERROR_OFF)) {
                // Transition: '<S433>:54'
                localDW->bitsForTID1.is_ERROR_OFF_cild =
                  MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:56'
                localB->state_Output = ERROR_OFF;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S433>:56'
            }
            break;

           case MX_Gateway_IN_ERROR_ON:
            // During 'ERROR_ON': '<S433>:42'
            if ((rtu_cmd || (!rtu_dfbk) || (!rtu_din)) && ((localB->state_Output
                  == NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S433>:71'
              // Exit Internal 'ERROR_ON': '<S433>:42'
              localDW->bitsForTID1.is_ERROR_ON_lmya =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S433>:36'
              // Transition: '<S433>:49'
              localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID1.is_ERROR_ON_lmya ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:43'
              if ((localDW->debounceOutput >= rtp_ERROR_ON_DB_CNT) ||
                  (localB->state_Output == ERROR_ON)) {
                // Transition: '<S433>:46'
                localDW->bitsForTID1.is_ERROR_ON_lmya = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:45'
                localB->state_Output = ERROR_ON;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S433>:45'
            }
            break;

           case MX_Gateway_IN_FAILURE:
            // During 'FAILURE': '<S433>:64'
            if (((!rtu_cmd) || rtu_dfbk || (!rtu_din)) && ((localB->state_Output
                  == NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S433>:73'
              // Exit Internal 'FAILURE': '<S433>:64'
              localDW->bitsForTID1.is_FAILURE = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S433>:36'
              // Transition: '<S433>:49'
              localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID1.is_FAILURE ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:67'
              if ((localDW->debounceOutput >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Output == FAILURE)) {
                // Transition: '<S433>:66'
                localDW->bitsForTID1.is_FAILURE = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:68'
                localB->state_Output = FAILURE;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S433>:68'
            }
            break;

           case MX_Gateway_IN_NORMAL_pqen:
            // During 'NORMAL': '<S433>:36'
            if ((!rtu_cmd) && rtu_dfbk && rtu_din) {
              // Transition: '<S433>:70'
              // Exit Internal 'NORMAL': '<S433>:36'
              localDW->bitsForTID1.is_NORMAL_food =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_ERROR_ON;

              // Entry Internal 'ERROR_ON': '<S433>:42'
              // Transition: '<S433>:44'
              localDW->bitsForTID1.is_ERROR_ON_lmya =
                MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:43'
              localDW->debounceOutput = 0U;
            } else if (rtu_cmd && (!rtu_dfbk) && rtu_din) {
              // Transition: '<S433>:72'
              // Exit Internal 'NORMAL': '<S433>:36'
              localDW->bitsForTID1.is_NORMAL_food =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_FAILURE;

              // Entry Internal 'FAILURE': '<S433>:64'
              // Transition: '<S433>:65'
              localDW->bitsForTID1.is_FAILURE = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:67'
              localDW->debounceOutput = 0U;
            } else if (rtu_cmd && (!rtu_dfbk)) {
              // Transition: '<S433>:75'
              // && !(din) for coverage
              // Exit Internal 'NORMAL': '<S433>:36'
              localDW->bitsForTID1.is_NORMAL_food =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_ERROR_OFF;

              // Entry Internal 'ERROR_OFF': '<S433>:52'
              // Transition: '<S433>:53'
              localDW->bitsForTID1.is_ERROR_OFF_cild =
                MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:55'
              localDW->debounceOutput = 0U;
            } else if ((!rtu_cmd) && rtu_dfbk) {
              // Transition: '<S433>:77'
              // && !(din) for coverage
              // Exit Internal 'NORMAL': '<S433>:36'
              localDW->bitsForTID1.is_NORMAL_food =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_OPEN_CIRCUIT_pa2m;

              // Entry Internal 'OPEN_CIRCUIT': '<S433>:57'
              // Transition: '<S433>:58'
              localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:60'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID1.is_NORMAL_food ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:48'
              if ((localDW->debounceOutput >= rtp_NORMAL_DB_CNT) ||
                  (localB->state_Output == NORMAL)) {
                // Transition: '<S433>:51'
                localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:50'
                localB->state_Output = NORMAL;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S433>:50'
            }
            break;

           default:
            // During 'OPEN_CIRCUIT': '<S433>:57'
            if ((rtu_cmd || (!rtu_dfbk) || rtu_din) && ((localB->state_Output ==
                  NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S433>:78'
              // Exit Internal 'OPEN_CIRCUIT': '<S433>:57'
              localDW->bitsForTID1.is_OPEN_CIRCUIT =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S433>:36'
              // Transition: '<S433>:49'
              localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID1.is_OPEN_CIRCUIT ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:60'
              if ((localDW->debounceOutput >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Output == OPEN_CIRCUIT)) {
                // Transition: '<S433>:59'
                localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:61'
                localB->state_Output = OPEN_CIRCUIT;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S433>:61'
            }
            break;
          }
        }
      } else {
        // During 'RELAY': '<S433>:119'
        if (localB->state_Relay == NORMAL) {
          // Transition: '<S433>:122'
          localDW->bitsForTID1.is_STATE_OUTPUT = MX_Gateway_IN_OUTPUT;

          // Entry Internal 'OUTPUT': '<S433>:82'
          // Transition: '<S433>:31'
          localB->state_Output = NORMAL;
          localDW->bitsForTID1.is_OUTPUT = MX_Gateway_IN_NORMAL_pqen;

          // Entry Internal 'NORMAL': '<S433>:36'
          // Transition: '<S433>:49'
          localDW->bitsForTID1.is_NORMAL_food = MX_Gateway_IN_DEBOUNCE_mmz1;

          // Entry 'DEBOUNCE': '<S433>:48'
          localDW->debounceOutput = 0U;
        }
      }

      // During 'STATE_RELAY': '<S433>:124'
      if (localDW->bitsForTID1.is_STATE_RELAY == MX_Gateway_IN_OUTPUT) {
        // During 'OUTPUT': '<S433>:163'
        if ((localB->state_Output == NORMAL) || (localB->state_Output == FAILURE))
        {
          // Transition: '<S433>:127'
          localDW->bitsForTID1.is_STATE_RELAY = MX_Gateway_IN_RELAY;

          // Entry Internal 'RELAY': '<S433>:128'
          // Transition: '<S433>:131'
          localB->state_Relay = NORMAL;
          localDW->bitsForTID1.is_RELAY = MX_Gateway_IN_NORMAL_pqenz;

          // Entry Internal 'NORMAL': '<S433>:148'
          // Transition: '<S433>:149'
          localDW->bitsForTID1.is_NORMAL = MX_Gateway_IN_DEBOUNCE_mmz1;

          // Entry 'DEBOUNCE': '<S433>:151'
          localDW->debounceRelay = 0U;
        }
      } else {
        // During 'RELAY': '<S433>:128'
        if ((localB->state_Output != NORMAL) && (localB->state_Output != FAILURE)
            && (localB->state_Relay == NORMAL)) {
          // Transition: '<S433>:126'
          // Exit Internal 'RELAY': '<S433>:128'
          // Exit Internal 'ERROR_OFF': '<S433>:158'
          localDW->bitsForTID1.is_ERROR_OFF = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID1.is_RELAY = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'ERROR_ON': '<S433>:138'
          localDW->bitsForTID1.is_ERROR_ON = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'NORMAL': '<S433>:148'
          localDW->bitsForTID1.is_NORMAL = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID1.is_STATE_RELAY = MX_Gateway_IN_OUTPUT;
        } else {
          switch (localDW->bitsForTID1.is_RELAY) {
           case MX_Gateway_IN_ERROR_OFF:
            // During 'ERROR_OFF': '<S433>:158'
            if (((!rtu_cmd) || ((!rtu_dfbk) && (localB->state_Output != FAILURE))
                 || rtu_din) && ((localB->state_Relay == NORMAL) ||
                                 (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S433>:136'
              // Exit Internal 'ERROR_OFF': '<S433>:158'
              localDW->bitsForTID1.is_ERROR_OFF =
                MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_RELAY = MX_Gateway_IN_NORMAL_pqenz;

              // Entry Internal 'NORMAL': '<S433>:148'
              // Transition: '<S433>:149'
              localDW->bitsForTID1.is_NORMAL = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:151'
              localDW->debounceRelay = 0U;
            } else if (localDW->bitsForTID1.is_ERROR_OFF ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:161'
              if ((localDW->debounceRelay >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Relay == ERROR_OFF)) {
                // Transition: '<S433>:160'
                localDW->bitsForTID1.is_ERROR_OFF = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:162'
                localB->state_Relay = ERROR_OFF;
              } else {
                localDW->debounceRelay = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceRelay + 1);
              }
            } else {
              // During 'FAULT': '<S433>:162'
            }
            break;

           case MX_Gateway_IN_ERROR_ON:
            // During 'ERROR_ON': '<S433>:138'
            if ((rtu_cmd || rtu_dfbk || (!rtu_din)) && ((localB->state_Relay ==
                  NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S433>:130'
              // Exit Internal 'ERROR_ON': '<S433>:138'
              localDW->bitsForTID1.is_ERROR_ON = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_RELAY = MX_Gateway_IN_NORMAL_pqenz;

              // Entry Internal 'NORMAL': '<S433>:148'
              // Transition: '<S433>:149'
              localDW->bitsForTID1.is_NORMAL = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:151'
              localDW->debounceRelay = 0U;
            } else if (localDW->bitsForTID1.is_ERROR_ON ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:141'
              if ((localDW->debounceRelay >= rtp_ERROR_ON_DB_CNT) ||
                  (localB->state_Relay == ERROR_ON)) {
                // Transition: '<S433>:140'
                localDW->bitsForTID1.is_ERROR_ON = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:142'
                localB->state_Relay = ERROR_ON;
              } else {
                localDW->debounceRelay = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceRelay + 1);
              }
            } else {
              // During 'FAULT': '<S433>:142'
            }
            break;

           default:
            // During 'NORMAL': '<S433>:148'
            if ((!rtu_cmd) && (!rtu_dfbk) && rtu_din) {
              // Transition: '<S433>:129'
              // Exit Internal 'NORMAL': '<S433>:148'
              localDW->bitsForTID1.is_NORMAL = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_RELAY = MX_Gateway_IN_ERROR_ON;

              // Entry Internal 'ERROR_ON': '<S433>:138'
              // Transition: '<S433>:139'
              localDW->bitsForTID1.is_ERROR_ON = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:141'
              localDW->debounceRelay = 0U;
            } else if (rtu_cmd && (rtu_dfbk || (localB->state_Output == FAILURE))
                       && (!rtu_din)) {
              // Transition: '<S433>:137'
              // Exit Internal 'NORMAL': '<S433>:148'
              localDW->bitsForTID1.is_NORMAL = MX_Gate_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID1.is_RELAY = MX_Gateway_IN_ERROR_OFF;

              // Entry Internal 'ERROR_OFF': '<S433>:158'
              // Transition: '<S433>:159'
              localDW->bitsForTID1.is_ERROR_OFF = MX_Gateway_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S433>:161'
              localDW->debounceRelay = 0U;
            } else if (localDW->bitsForTID1.is_NORMAL ==
                       MX_Gateway_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S433>:151'
              if ((localDW->debounceRelay >= rtp_NORMAL_DB_CNT) ||
                  (localB->state_Relay == NORMAL)) {
                // Transition: '<S433>:150'
                localDW->bitsForTID1.is_NORMAL = MX_Gateway_IN_FAULT_pyte;

                // Entry 'FAULT': '<S433>:152'
                localB->state_Relay = NORMAL;
              } else {
                localDW->debounceRelay = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceRelay + 1);
              }
            } else {
              // During 'FAULT': '<S433>:152'
            }
            break;
          }
        }
      }
    }

    // End of Chart: '<S432>/relay_error_state'

    // SignalConversion: '<S432>/OutportBufferForstate_Output'
    *rty_state_Output = localB->state_Output;

    // SignalConversion: '<S432>/OutportBufferForstate_Relay'
    *rty_state_Relay = localB->state_Relay;
  } else {
    if (localDW->relay_oc_MODE) {
      MX_Gateway_relay_oc_Disable(rty_state_Output, rty_state_Relay, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S427>/relay_oc'
}

//
//  System initialize for enable system:
//     '<S308>/hc_hsd'
//     '<S583>/hc_hsd'

void MX_Gateway_hc_hsd_Init(uint8_T *rty_state, rtB_hc_hsd_MX_Gateway *localB,
  rtDW_hc_hsd_MX_Gateway *localDW)
{
  // SystemInitialize for Chart: '<S443>/Fault monitor'
  localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID1.is_active_c4_MX_Library = 0U;
  localDW->bitsForTID1.is_c4_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->db_cnt = 0U;
  localB->state = 0U;

  // SystemInitialize for Outport: '<S443>/state'
  *rty_state = ((uint8_T)8U);
}

//
//  System reset for enable system:
//     '<S308>/hc_hsd'
//     '<S583>/hc_hsd'

void MX_Gateway_hc_hsd_Reset(rtB_hc_hsd_MX_Gateway *localB,
  rtDW_hc_hsd_MX_Gateway *localDW)
{
  // SystemReset for Chart: '<S443>/Fault monitor'
  localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID1.is_active_c4_MX_Library = 0U;
  localDW->bitsForTID1.is_c4_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
  localDW->db_cnt = 0U;
  localB->state = 0U;
}

//
//  Disable for enable system:
//     '<S308>/hc_hsd'
//     '<S583>/hc_hsd'

void MX_Gateway_hc_hsd_Disable(uint8_T *rty_state, rtDW_hc_hsd_MX_Gateway
  *localDW)
{
  // Outputs for Enabled SubSystem: '<S308>/hc_hsd' incorporates:
  //   EnablePort: '<S443>/Enable'

  // Disable for Outport: '<S443>/state'
  *rty_state = ((uint8_T)8U);

  // End of Outputs for SubSystem: '<S308>/hc_hsd'
  localDW->hc_hsd_MODE = false;
}

//
//  Output and update for enable system:
//     '<S308>/hc_hsd'
//     '<S583>/hc_hsd'

void MX_Gateway_hc_hsd(boolean_T rtu_Enable, uint16_T rtu_duty, uint16_T
  rtu_afbk, uint16_T rtu_Vbatt, uint8_T *rty_state, rtB_hc_hsd_MX_Gateway
  *localB, rtDW_hc_hsd_MX_Gateway *localDW, uint16_T rtp_OPEN_DB_CNT, uint16_T
  rtp_STB_DB_CNT, uint16_T rtp_STG_DB_CNT)
{
  int16_T rtb_afbk_ratio;

  // Outputs for Enabled SubSystem: '<S308>/hc_hsd' incorporates:
  //   EnablePort: '<S443>/Enable'

  if (rtu_Enable) {
    if (!localDW->hc_hsd_MODE) {
      MX_Gateway_hc_hsd_Reset(localB, localDW);
      localDW->hc_hsd_MODE = true;
    }

    // Product: '<S443>/Divide'
    rtb_afbk_ratio = div_s16u32((uint32_T)((uint32_T)rtu_afbk << 8), (uint32_T)
      rtu_Vbatt);

    // Chart: '<S443>/Fault monitor'
    // Gateway: hc_hsd/Fault monitor
    // During: hc_hsd/Fault monitor
    if ((uint32_T)localDW->bitsForTID1.is_active_c4_MX_Library == 0U) {
      // Entry: hc_hsd/Fault monitor
      localDW->bitsForTID1.is_active_c4_MX_Library = 1U;

      // Entry Internal: hc_hsd/Fault monitor
      // Transition: '<S444>:155'
      localDW->bitsForTID1.is_c4_MX_Library = MX_Gateway_IN_NORMAL_l0jr;

      // Entry 'NORMAL': '<S444>:145'
      localDW->db_cnt = (uint16_T)INACTIVE;
      localB->state = NORMAL;
    } else {
      switch (localDW->bitsForTID1.is_c4_MX_Library) {
       case MX_Gateway_IN_NORMAL_l0jr:
        localB->state = NORMAL;

        // During 'NORMAL': '<S444>:145'
        if (((uint32_T)rtu_duty == (uint32_T)((uint32_T)INACTIVE << 16)) &&
            ((int32_T)rtb_afbk_ratio > 205) && (rtp_STB_DB_CNT != UNLIMITED)) {
          // Transition: '<S444>:149'
          localDW->bitsForTID1.is_c4_MX_Library =
            MX_Gat_IN_SHORT_TO_BATTERY_mp5u;

          // Entry Internal 'SHORT_TO_BATTERY': '<S444>:146'
          // Transition: '<S444>:158'
          localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gateway_IN_DEBOUNCE_mxcs;

          // Entry 'DEBOUNCE': '<S444>:156'
          localDW->db_cnt = 0U;
        } else if (((int32_T)rtu_duty == 0) && ((int32_T)rtb_afbk_ratio > 64) &&
                   ((int32_T)rtb_afbk_ratio < 192) && (rtp_OPEN_DB_CNT !=
                    UNLIMITED)) {
          // Transition: '<S444>:151'
          localDW->bitsForTID1.is_c4_MX_Library =
            MX_Gateway_IN_OPEN_CIRCUIT_iupo;

          // Entry Internal 'OPEN_CIRCUIT': '<S444>:148'
          // Transition: '<S444>:162'
          localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gateway_IN_DEBOUNCE_mxcs;

          // Entry 'DEBOUNCE': '<S444>:161'
          localDW->db_cnt = 0U;
        } else {
          if (((int32_T)rtu_duty >= 64225) && ((int32_T)rtb_afbk_ratio < 51) &&
              (rtp_STG_DB_CNT != UNLIMITED)) {
            // Transition: '<S444>:153'
            localDW->bitsForTID1.is_c4_MX_Library =
              MX_Gate_IN_SHORT_TO_GROUND_e2rb;

            // Entry Internal 'SHORT_TO_GROUND': '<S444>:147'
            // Transition: '<S444>:166'
            localDW->bitsForTID1.is_SHORT_TO_GROUND =
              MX_Gateway_IN_DEBOUNCE_mxcs;

            // Entry 'DEBOUNCE': '<S444>:165'
            localDW->db_cnt = 0U;
          }
        }
        break;

       case MX_Gateway_IN_OPEN_CIRCUIT_iupo:
        // During 'OPEN_CIRCUIT': '<S444>:148'
        if ((localB->state == NORMAL) && (((uint32_T)rtu_duty != (uint32_T)
              ((uint32_T)INACTIVE << 16)) || ((int32_T)rtb_afbk_ratio <= 64) ||
             ((int32_T)rtb_afbk_ratio >= 192))) {
          // Transition: '<S444>:152'
          // Exit Internal 'OPEN_CIRCUIT': '<S444>:148'
          localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
          localDW->bitsForTID1.is_c4_MX_Library = MX_Gateway_IN_NORMAL_l0jr;

          // Entry 'NORMAL': '<S444>:145'
          localDW->db_cnt = (uint16_T)INACTIVE;
          localB->state = NORMAL;
        } else if (localDW->bitsForTID1.is_OPEN_CIRCUIT ==
                   MX_Gateway_IN_DEBOUNCE_mxcs) {
          // During 'DEBOUNCE': '<S444>:161'
          if (localDW->db_cnt >= rtp_OPEN_DB_CNT) {
            // Transition: '<S444>:164'
            localDW->bitsForTID1.is_OPEN_CIRCUIT = MX_Gateway_IN_FAULT_k5qe;

            // Entry 'FAULT': '<S444>:163'
            localB->state = OPEN_CIRCUIT;
          } else {
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          }
        } else {
          localB->state = OPEN_CIRCUIT;

          // During 'FAULT': '<S444>:163'
        }
        break;

       case MX_Gat_IN_SHORT_TO_BATTERY_mp5u:
        // During 'SHORT_TO_BATTERY': '<S444>:146'
        if ((localB->state == NORMAL) && (((uint32_T)rtu_duty != (uint32_T)
              ((uint32_T)INACTIVE << 16)) || ((int32_T)rtb_afbk_ratio <= 205)))
        {
          // Transition: '<S444>:150'
          // Exit Internal 'SHORT_TO_BATTERY': '<S444>:146'
          localDW->bitsForTID1.is_SHORT_TO_BATTERY =
            MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
          localDW->bitsForTID1.is_c4_MX_Library = MX_Gateway_IN_NORMAL_l0jr;

          // Entry 'NORMAL': '<S444>:145'
          localDW->db_cnt = (uint16_T)INACTIVE;
          localB->state = NORMAL;
        } else if (localDW->bitsForTID1.is_SHORT_TO_BATTERY ==
                   MX_Gateway_IN_DEBOUNCE_mxcs) {
          // During 'DEBOUNCE': '<S444>:156'
          if (localDW->db_cnt >= rtp_STB_DB_CNT) {
            // Transition: '<S444>:160'
            localDW->bitsForTID1.is_SHORT_TO_BATTERY = MX_Gateway_IN_FAULT_k5qe;

            // Entry 'FAULT': '<S444>:159'
            localB->state = SHORT_TO_BATTERY;
          } else {
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          }
        } else {
          localB->state = SHORT_TO_BATTERY;

          // During 'FAULT': '<S444>:159'
        }
        break;

       default:
        // During 'SHORT_TO_GROUND': '<S444>:147'
        if ((localB->state == NORMAL) && (((int32_T)rtu_duty < 64225) ||
             ((int32_T)rtb_afbk_ratio >= 51))) {
          // Transition: '<S444>:154'
          // Exit Internal 'SHORT_TO_GROUND': '<S444>:147'
          localDW->bitsForTID1.is_SHORT_TO_GROUND =
            MX_Gate_IN_NO_ACTIVE_CHILD_bes5;
          localDW->bitsForTID1.is_c4_MX_Library = MX_Gateway_IN_NORMAL_l0jr;

          // Entry 'NORMAL': '<S444>:145'
          localDW->db_cnt = (uint16_T)INACTIVE;
          localB->state = NORMAL;
        } else if (localDW->bitsForTID1.is_SHORT_TO_GROUND ==
                   MX_Gateway_IN_DEBOUNCE_mxcs) {
          // During 'DEBOUNCE': '<S444>:165'
          if (localDW->db_cnt >= rtp_STG_DB_CNT) {
            // Transition: '<S444>:168'
            localDW->bitsForTID1.is_SHORT_TO_GROUND = MX_Gateway_IN_FAULT_k5qe;

            // Entry 'FAULT': '<S444>:167'
            localB->state = SHORT_TO_GROUND;
          } else {
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          }
        } else {
          localB->state = SHORT_TO_GROUND;

          // During 'FAULT': '<S444>:167'
        }
        break;
      }
    }

    // End of Chart: '<S443>/Fault monitor'

    // SignalConversion: '<S443>/OutportBufferForstate'
    *rty_state = localB->state;
  } else {
    if (localDW->hc_hsd_MODE) {
      MX_Gateway_hc_hsd_Disable(rty_state, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S308>/hc_hsd'
}

// System initialize for atomic system: '<S579>/hc_Output'
void MX__output_single_OpenLoop_Init(uint8_T *rty_state,
  rtB_output_single_OpenLoop_MX_G *localB, rtDW_output_single_OpenLoop_MX_
  *localDW)
{
  // InitializeConditions for UnitDelay: '<S583>/Unit Delay'
  localDW->UnitDelay_DSTATE = ((uint8_T)0U);

  // SystemInitialize for Chart: '<S583>/control'
  localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_opa5;
  localDW->bitsForTID1.is_active_c41_MX_Library = 0U;
  localDW->bitsForTID1.is_c41_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_opa5;
  localB->duty_Output = 0U;
  *rty_state = 0U;

  // SystemInitialize for Enabled SubSystem: '<S583>/hc_hsd'
  MX_Gateway_hc_hsd_Init(&localB->state, &localB->hc_hsd, &localDW->hc_hsd);

  // End of SystemInitialize for SubSystem: '<S583>/hc_hsd'
}

// System reset for atomic system: '<S579>/hc_Output'
void MX_output_single_OpenLoop_Reset(uint8_T *rty_state,
  rtB_output_single_OpenLoop_MX_G *localB, rtDW_output_single_OpenLoop_MX_
  *localDW)
{
  // InitializeConditions for UnitDelay: '<S583>/Unit Delay'
  localDW->UnitDelay_DSTATE = ((uint8_T)0U);

  // SystemReset for Chart: '<S583>/control'
  localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_opa5;
  localDW->bitsForTID1.is_active_c41_MX_Library = 0U;
  localDW->bitsForTID1.is_c41_MX_Library = MX_Gate_IN_NO_ACTIVE_CHILD_opa5;
  localB->duty_Output = 0U;
  *rty_state = 0U;
}

// Disable for atomic system: '<S579>/hc_Output'
void output_single_OpenLoop_Disable(rtB_output_single_OpenLoop_MX_G *localB,
  rtDW_output_single_OpenLoop_MX_ *localDW)
{
  // Disable for Enabled SubSystem: '<S583>/hc_hsd'
  if (localDW->hc_hsd.hc_hsd_MODE) {
    MX_Gateway_hc_hsd_Disable(&localB->state, &localDW->hc_hsd);
  }

  // End of Disable for SubSystem: '<S583>/hc_hsd'
}

// Output and update for atomic system: '<S579>/hc_Output'
void MX_Gatew_output_single_OpenLoop(uint16_T rtu_cmd, uint8_T
  rtu_state_Vbattery, uint16_T rtu_calc_VBattery, uint16_T rtu_afbk_A2D, uint8_T
  *rty_state, uint16_T *rty_duty_Output, rtB_output_single_OpenLoop_MX_G *localB,
  rtDW_output_single_OpenLoop_MX_ *localDW, uint16_T rtp_MAX_VOLTS, uint16_T
  rtp_OPEN_DB_CNT, uint16_T rtp_STB_DB_CNT, uint16_T rtp_STG_DB_CNT, uint8_T
  rtp_FUNCTION, uint16_T rtp_AFBK_GAIN)
{
  boolean_T rtb_HiddenBuf_InsertedFor__ou0l;
  uint16_T rtb_Gain_huj2;
  uint32_T tmp;

  // Gain: '<S583>/Gain'
  tmp = (uint32_T)((uint32_T)rtp_AFBK_GAIN * (uint32_T)rtu_afbk_A2D);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Gain_huj2 = (uint16_T)tmp;

  // End of Gain: '<S583>/Gain'

  // SignalConversion: '<S583>/HiddenBuf_InsertedFor_hc_hsd_at_inport_3' incorporates:
  //   Constant: '<S583>/FunctionState'
  //   Constant: '<S586>/Constant'
  //   Constant: '<S587>/Constant'
  //   Logic: '<S583>/Logical Operator'
  //   RelationalOperator: '<S586>/Compare'
  //   RelationalOperator: '<S587>/Compare'

  rtb_HiddenBuf_InsertedFor__ou0l = ((rtp_FUNCTION != NON_FUNCTIONAL) &&
    (rtu_state_Vbattery != OORL));

  // Chart: '<S583>/control' incorporates:
  //   UnitDelay: '<S583>/Unit Delay'

  // Gateway: output_single_OpenLoop/control
  // During: output_single_OpenLoop/control
  if ((uint32_T)localDW->bitsForTID1.is_active_c41_MX_Library == 0U) {
    // Entry: output_single_OpenLoop/control
    localDW->bitsForTID1.is_active_c41_MX_Library = 1U;

    // Entry Internal: output_single_OpenLoop/control
    // Transition: '<S589>:54'
    localDW->bitsForTID1.is_c41_MX_Library = MX_Gateway_IN_FUNCTIONAL_gxam;

    // Entry 'FUNCTIONAL': '<S589>:21'
    localB->duty_Output = rtu_cmd;

    // Entry Internal 'FUNCTIONAL': '<S589>:21'
    // Transition: '<S589>:62'
    localDW->bitsForTID1.is_FUNCTIONAL = MX_Gateway_IN_INACTIVE_l135;

    // Entry 'INACTIVE': '<S589>:2'
    *rty_state = INACTIVE;
  } else if (localDW->bitsForTID1.is_c41_MX_Library == MX_Gateway_IN_ERROR_l2ny)
  {
    // During 'ERROR': '<S589>:22'
    if (localDW->UnitDelay_DSTATE == NORMAL) {
      // Transition: '<S589>:64'
      localDW->bitsForTID1.is_c41_MX_Library = MX_Gateway_IN_FUNCTIONAL_gxam;

      // Entry 'FUNCTIONAL': '<S589>:21'
      localB->duty_Output = rtu_cmd;

      // Entry Internal 'FUNCTIONAL': '<S589>:21'
      // Transition: '<S589>:62'
      localDW->bitsForTID1.is_FUNCTIONAL = MX_Gateway_IN_INACTIVE_l135;

      // Entry 'INACTIVE': '<S589>:2'
      *rty_state = INACTIVE;
    }
  } else {
    // During 'FUNCTIONAL': '<S589>:21'
    if (localDW->UnitDelay_DSTATE != NORMAL) {
      // Transition: '<S589>:63'
      // Exit Internal 'FUNCTIONAL': '<S589>:21'
      localDW->bitsForTID1.is_FUNCTIONAL = MX_Gate_IN_NO_ACTIVE_CHILD_opa5;
      localDW->bitsForTID1.is_c41_MX_Library = MX_Gateway_IN_ERROR_l2ny;

      // Entry 'ERROR': '<S589>:22'
      localB->duty_Output = 0U;
      *rty_state = localDW->UnitDelay_DSTATE;
    } else {
      localB->duty_Output = rtu_cmd;
      if (localDW->bitsForTID1.is_FUNCTIONAL == MX_Gateway_IN_ACTIVE_itwh) {
        // During 'ACTIVE': '<S589>:1'
        if ((uint32_T)rtu_cmd == (uint32_T)((uint32_T)INACTIVE << 16)) {
          // Transition: '<S589>:37'
          localDW->bitsForTID1.is_FUNCTIONAL = MX_Gateway_IN_INACTIVE_l135;

          // Entry 'INACTIVE': '<S589>:2'
          *rty_state = INACTIVE;
        }
      } else {
        // During 'INACTIVE': '<S589>:2'
        if ((uint32_T)rtu_cmd != (uint32_T)((uint32_T)INACTIVE << 16)) {
          // Transition: '<S589>:35'
          localDW->bitsForTID1.is_FUNCTIONAL = MX_Gateway_IN_ACTIVE_itwh;

          // Entry 'ACTIVE': '<S589>:1'
          *rty_state = ACTIVE;
        }
      }
    }
  }

  // End of Chart: '<S583>/control'

  // Outputs for Atomic SubSystem: '<S583>/Voltage_Limiter'
  MX_Gateway_Voltage_Limiter(rtu_calc_VBattery, localB->duty_Output,
    rty_duty_Output, rtp_MAX_VOLTS);

  // End of Outputs for SubSystem: '<S583>/Voltage_Limiter'

  // Outputs for Enabled SubSystem: '<S583>/hc_hsd'
  MX_Gateway_hc_hsd(rtb_HiddenBuf_InsertedFor__ou0l, *rty_duty_Output,
                    rtb_Gain_huj2, rtu_calc_VBattery, &localB->state,
                    &localB->hc_hsd, &localDW->hc_hsd, rtp_OPEN_DB_CNT,
                    rtp_STB_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S583>/hc_hsd'

  // Update for UnitDelay: '<S583>/Unit Delay'
  localDW->UnitDelay_DSTATE = localB->state;
}

//
//  [EOF]

