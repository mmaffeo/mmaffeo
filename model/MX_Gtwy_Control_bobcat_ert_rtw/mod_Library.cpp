//
//  Copyright (c) 2009 Bobcat Company as an unpublished work.
//  All Rights Reserved.
//
//  The information contained herein is confidential property of Bobcat Company.
//  The use, copying, transfer or disclosure of such information is prohibited except
//  by express written agreement with Bobcat Company.
//
//  Code Generated by Simulink Real-Time Workshop
//
//  Simulink model                       : MX_Gtwy_Control


#include "mod_Library.h"

// Include model header file for global data
#include "MX_Gtwy_Control.h"
#include "MX_Gtwy_Control_private.h"

// Named constants for Chart: '<S155>/LP_Filter_Adj_Gain'
#define MX_Gtwy_Cont_IN_NO_ACTIVE_CHILD ((uint8_T)0U)
#define MX_Gtwy_Control_IN_INITIAL     ((uint8_T)1U)
#define MX_Gtwy_Control_IN_LP_FILTER   ((uint8_T)2U)

// Named constants for Chart: '<S201>/LP_Filter_Adj_Gain'
#define MX_Gtwy_Contr_IN_LP_FILTER_hzab ((uint8_T)2U)
#define MX_Gtwy_Control_IN_INITIAL_aowf ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_p1y5 ((uint8_T)0U)

// Named constants for Chart: '<S219>/LP_Fitler_Adj_Gain'
#define MX_Gtwy_Contr_IN_LP_FILTER_nfsi ((uint8_T)2U)
#define MX_Gtwy_Control_IN_INITIAL_obic ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_lpib ((uint8_T)0U)

// Named constants for Chart: '<S339>/Fault monitor'
#define MX_Gtwy_Con_IN_SHORT_TO_BATTERY ((uint8_T)4U)
#define MX_Gtwy_Cont_IN_SHORT_TO_GROUND ((uint8_T)5U)
#define MX_Gtwy_Control_IN_ACTIVE      ((uint8_T)1U)
#define MX_Gtwy_Control_IN_DEBOUNCE    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_FAULT       ((uint8_T)2U)
#define MX_Gtwy_Control_IN_INACTIVE    ((uint8_T)2U)
#define MX_Gtwy_Control_IN_NORMAL      ((uint8_T)1U)
#define MX_Gtwy_Control_IN_OC_STG      ((uint8_T)2U)
#define MX_Gtwy_Control_IN_OFF         ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ON          ((uint8_T)2U)
#define MX_Gtwy_Control_IN_OPEN_CIRCUIT ((uint8_T)3U)
#define MX_Gtwy_Control_IN_TURNING_OFF ((uint8_T)3U)
#define MX_Gtwy_Control_IN_TURNING_ON  ((uint8_T)4U)
#define MX_Gtwy_Control_IN_debounce    ((uint8_T)2U)
#define MX_Gtwy_Control_IN_error       ((uint8_T)3U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w ((uint8_T)0U)

// Named constants for Chart: '<S330>/oc_operation_detection'
#define MX_Gtwy_Con_IN_DIAG_STATE_ERROR ((uint8_T)1U)
#define MX_Gtwy_Contr_IN_OC_STATE_ERROR ((uint8_T)3U)
#define MX_Gtwy_Contr_IN_OPEN_STG_ERROR ((uint8_T)5U)
#define MX_Gtwy_Contr_IN_OPEN_STG_RESET ((uint8_T)7U)
#define MX_Gtwy_Control_IN_NORMAL_ngcs ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_jstd ((uint8_T)0U)
#define MX_Gtwy_IN_OPEN_STG_ERROR_RESET ((uint8_T)6U)
#define MX_Gtwy__IN_OPEN_STG_DIAG_STATE ((uint8_T)4U)

// Named constants for Chart: '<S306>/control'
#define MX_Gtwy_C_IN_STGOFF_DIAG_ACTIVE ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ACTIVE_OFF  ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ACTIVE_ON   ((uint8_T)2U)
#define MX_Gtwy_Control_IN_DIAG_CHECK  ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ENABLE_OFF  ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ENABLE_ON   ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ERROR       ((uint8_T)2U)
#define MX_Gtwy_Control_IN_FUNCTIONAL  ((uint8_T)3U)
#define MX_Gtwy_Control_IN_Test_OC     ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Test_STG    ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad ((uint8_T)0U)
#define MX_Gtwy_IN_STGOFF_DIAG_INACTIVE ((uint8_T)2U)

// Named constants for Chart: '<S367>/control'
#define MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz ((uint8_T)1U)
#define MX_Gtwy_Cont_IN_ACTIVE_OFF_o5z1 ((uint8_T)1U)
#define MX_Gtwy_Cont_IN_DIAG_CHECK_gfxy ((uint8_T)1U)
#define MX_Gtwy_Cont_IN_ENABLE_OFF_ifnc ((uint8_T)1U)
#define MX_Gtwy_Cont_IN_FUNCTIONAL_blpp ((uint8_T)3U)
#define MX_Gtwy_Contr_IN_ACTIVE_ON_aqdk ((uint8_T)2U)
#define MX_Gtwy_Contr_IN_ENABLE_ON_p4th ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_Test_STG_a1mc ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ERROR_jnvd  ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Test_OC_dpgv ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg ((uint8_T)0U)
#define MX_IN_STGOFF_DIAG_INACTIVE_o1ij ((uint8_T)2U)

// Named constants for Chart: '<S410>/relay_error_state'
#define MX_Gtwy_Co_IN_OPEN_CIRCUIT_pa2m ((uint8_T)5U)
#define MX_Gtwy_Contro_IN_DEBOUNCE_mmz1 ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ERROR_OFF   ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ERROR_ON    ((uint8_T)2U)
#define MX_Gtwy_Control_IN_FAILURE     ((uint8_T)3U)
#define MX_Gtwy_Control_IN_FAULT_pyte  ((uint8_T)2U)
#define MX_Gtwy_Control_IN_NORMAL_pqen ((uint8_T)4U)
#define MX_Gtwy_Control_IN_NORMAL_pqenz ((uint8_T)3U)
#define MX_Gtwy_Control_IN_OUTPUT      ((uint8_T)1U)
#define MX_Gtwy_Control_IN_RELAY       ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan ((uint8_T)0U)

// Named constants for Chart: '<S421>/Fault monitor'
#define MX_Gtw_IN_SHORT_TO_BATTERY_mp5u ((uint8_T)3U)
#define MX_Gtwy_Co_IN_OPEN_CIRCUIT_iupo ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_DEBOUNCE_mxcs ((uint8_T)1U)
#define MX_Gtwy_Control_IN_FAULT_k5qe  ((uint8_T)2U)
#define MX_Gtwy_Control_IN_NORMAL_l0jr ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5 ((uint8_T)0U)
#define MX_Gtwy_IN_SHORT_TO_GROUND_e2rb ((uint8_T)4U)

// Named constants for Chart: '<S565>/control'
#define MX_Gtwy_Cont_IN_FUNCTIONAL_gxam ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_INACTIVE_l135 ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_itwh ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ERROR_l2ny  ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_opa5 ((uint8_T)0U)

//
//  Output and update for atomic system:
//     '<S2>/ErrorCode'
//     '<S2>/ErrorCode1'
//     '<S2>/ErrorCode10'
//     '<S2>/ErrorCode11'
//     '<S2>/ErrorCode12'
//     '<S2>/ErrorCode13'
//     '<S2>/ErrorCode14'
//     '<S2>/ErrorCode15'
//     '<S2>/ErrorCode16'
//     '<S2>/ErrorCode17'
//     ...

void MX_Gtwy_Control_ErrorCode(uint8_T rtu_failure, uint16_T *rty_ecode,
  uint16_T rtp_FUNCTION)
{
  // Sum: '<S7>/Sum' incorporates:
  //   Constant: '<S7>/Constant'
  //   Constant: '<S7>/Constant1'
  //   Product: '<S7>/Product'

  *rty_ecode = (uint16_T)(uint32_T)((uint32_T)rtu_failure + (uint32_T)(uint16_T)
    (uint32_T)((uint32_T)rtp_FUNCTION * (uint32_T)((uint16_T)256U)));
}

// System initialize for atomic system: '<S74>/LP_Filter'
void MX_Gtwy_Control_LP_Filter_Init(rtDW_LP_Filter_MX_Gtwy_Control *localDW)
{
  // InitializeConditions for UnitDelay: '<S149>/FixPt Unit Delay2'
  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)1U);
}

// Output and update for atomic system: '<S74>/LP_Filter'
void MX_Gtwy_Control_LP_Filter(int16_T rtu_In, int16_T *rty_Out,
  rtDW_LP_Filter_MX_Gtwy_Control *localDW)
{
  int16_T rtb_DataTypeConversion1_gw3m;
  int16_T rtb_Init;
  int32_T tmp;

  // DataTypeConversion: '<S147>/Data Type Conversion1'
  rtb_DataTypeConversion1_gw3m = (int16_T)(int32_T)((int32_T)rtu_In << 5);

  // Switch: '<S149>/Init' incorporates:
  //   UnitDelay: '<S149>/FixPt Unit Delay1'
  //   UnitDelay: '<S149>/FixPt Unit Delay2'

  if ((int32_T)localDW->FixPtUnitDelay2_DSTATE != 0) {
    rtb_Init = rtb_DataTypeConversion1_gw3m;
  } else {
    rtb_Init = localDW->FixPtUnitDelay1_DSTATE;
  }

  // End of Switch: '<S149>/Init'

  // Sum: '<S147>/Sum'
  tmp = (int32_T)((int32_T)rtb_DataTypeConversion1_gw3m - (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  // Sum: '<S147>/Sum1' incorporates:
  //   ArithShift: '<S147>/Shift Arithmetic'
  //   Sum: '<S147>/Sum'

  tmp = (int32_T)((int32_T)(tmp >> 3) + (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  *rty_Out = (int16_T)tmp;

  // End of Sum: '<S147>/Sum1'

  // Update for UnitDelay: '<S149>/FixPt Unit Delay2' incorporates:
  //   Constant: '<S149>/FixPt Constant'

  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)0U);

  // Update for UnitDelay: '<S149>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = *rty_Out;
}

//
//  Output and update for atomic system:
//     '<S74>/Ratiometric_Converter'
//     '<S151>/Ratiometric_Converter'
//     '<S179>/Ratiometric_Converter'
//     '<S83>/Ratiometric_Converter'
//     '<S217>/Ratiometric_Converter'
//     '<S265>/Ratiometric_Converter'

void MX_Gtwy_C_Ratiometric_Converter(uint16_T rtu_SensorInput, uint16_T
  rtu_SensorSupply, uint16_T *rty_Ratiometric, uint16_T rtp_multiplier)
{
  uint16_T u0;

  // DataTypeConversion: '<S148>/Data Type Conversion' incorporates:
  //   Constant: '<S148>/RATIOMETRIC_MULTIPLIER'
  //   Product: '<S148>/Divide'
  //   Product: '<S148>/Product'

  u0 = (uint16_T)((uint32_T)rtu_SensorSupply == 0U ? MAX_uint32_T : (uint32_T)
                  ((uint32_T)((uint32_T)rtu_SensorInput * (uint32_T)
    rtp_multiplier) / (uint32_T)rtu_SensorSupply));

  // Saturate: '<S148>/Saturation'
  if (u0 < ((uint16_T)2047U)) {
    *rty_Ratiometric = u0;
  } else {
    *rty_Ratiometric = ((uint16_T)2047U);
  }

  // End of Saturate: '<S148>/Saturation'
}

//
//  System initialize for atomic system:
//     '<S151>/LP_Filter'
//     '<S182>/LP_Filter'
//     '<S217>/LP_Filter'

void MX_Gtwy_Con_LP_Filter_as2q_Init(rtDW_LP_Filter_MX_Gtwy_Con_ntkm *localDW)
{
  // InitializeConditions for UnitDelay: '<S158>/FixPt Unit Delay2'
  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)1U);

  // InitializeConditions for UnitDelay: '<S158>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = 0;
}

//
//  System reset for atomic system:
//     '<S151>/LP_Filter'
//     '<S182>/LP_Filter'
//     '<S217>/LP_Filter'

void MX_Gtwy_Co_LP_Filter_j43b_Reset(rtDW_LP_Filter_MX_Gtwy_Con_ntkm *localDW)
{
  // InitializeConditions for UnitDelay: '<S158>/FixPt Unit Delay2'
  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)1U);

  // InitializeConditions for UnitDelay: '<S158>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = 0;
}

//
//  Output and update for atomic system:
//     '<S151>/LP_Filter'
//     '<S182>/LP_Filter'
//     '<S217>/LP_Filter'

void MX_Gtwy_Control_LP_Filter_dijo(uint16_T rtu_In, int16_T *rty_Out,
  rtDW_LP_Filter_MX_Gtwy_Con_ntkm *localDW)
{
  int16_T rtb_DataTypeConversion1_p2e3;
  int16_T rtb_Init;
  int32_T tmp;

  // DataTypeConversion: '<S154>/Data Type Conversion1'
  rtb_DataTypeConversion1_p2e3 = (int16_T)(int32_T)((int32_T)(int16_T)rtu_In <<
    5);

  // Switch: '<S158>/Init' incorporates:
  //   UnitDelay: '<S158>/FixPt Unit Delay1'
  //   UnitDelay: '<S158>/FixPt Unit Delay2'

  if ((int32_T)localDW->FixPtUnitDelay2_DSTATE != 0) {
    rtb_Init = rtb_DataTypeConversion1_p2e3;
  } else {
    rtb_Init = localDW->FixPtUnitDelay1_DSTATE;
  }

  // End of Switch: '<S158>/Init'

  // Sum: '<S154>/Sum'
  tmp = (int32_T)((int32_T)rtb_DataTypeConversion1_p2e3 - (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  // Sum: '<S154>/Sum1' incorporates:
  //   ArithShift: '<S154>/Shift Arithmetic'
  //   Sum: '<S154>/Sum'

  tmp = (int32_T)((int32_T)(tmp >> 3) + (int32_T)rtb_Init);
  if (tmp > 32767) {
    tmp = 32767;
  } else {
    if (tmp < -32768) {
      tmp = -32768;
    }
  }

  *rty_Out = (int16_T)tmp;

  // End of Sum: '<S154>/Sum1'

  // Update for UnitDelay: '<S158>/FixPt Unit Delay2' incorporates:
  //   Constant: '<S158>/FixPt Constant'

  localDW->FixPtUnitDelay2_DSTATE = ((uint8_T)0U);

  // Update for UnitDelay: '<S158>/FixPt Unit Delay1'
  localDW->FixPtUnitDelay1_DSTATE = *rty_Out;
}

//
//  System initialize for atomic system:
//     '<S151>/LP_Filter_Adj_Gain'
//     '<S182>/LP_Filter_Adj_Gain'
//     '<S83>/LP_Filter_Adj_Gain1'
//     '<S89>/LP_Filter_Adj_Gain'
//     '<S90>/LP_Filter_Adj_Gain'
//     '<S265>/LP_Filter_Adj_Gain'
//     '<S265>/LP_Filter_Adj_Gain1'
//     '<S327>/LP_Filter_Adj_Gain'
//     '<S344>/LP_Filter_Adj_Gain'
//     '<S372>/LP_Filter_Adj_Gain'
//     ...

void MX_Gtwy_LP_Filter_Adj_Gain_Init(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_Gain_MX_Gtwy *localDW)
{
  // SystemInitialize for Chart: '<S155>/LP_Filter_Adj_Gain'
  localDW->bitsForTID1.is_active_c1_MX_Library = 0U;
  localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_Cont_IN_NO_ACTIVE_CHILD;
  *rty_Output = 0;
}

//
//  System reset for atomic system:
//     '<S151>/LP_Filter_Adj_Gain'
//     '<S182>/LP_Filter_Adj_Gain'
//     '<S83>/LP_Filter_Adj_Gain1'
//     '<S89>/LP_Filter_Adj_Gain'
//     '<S90>/LP_Filter_Adj_Gain'
//     '<S265>/LP_Filter_Adj_Gain'
//     '<S265>/LP_Filter_Adj_Gain1'
//     '<S327>/LP_Filter_Adj_Gain'
//     '<S344>/LP_Filter_Adj_Gain'
//     '<S372>/LP_Filter_Adj_Gain'
//     ...

void MX_Gtw_LP_Filter_Adj_Gain_Reset(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_Gain_MX_Gtwy *localDW)
{
  // SystemReset for Chart: '<S155>/LP_Filter_Adj_Gain'
  localDW->bitsForTID1.is_active_c1_MX_Library = 0U;
  localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_Cont_IN_NO_ACTIVE_CHILD;
  *rty_Output = 0;
}

//
//  Output and update for atomic system:
//     '<S151>/LP_Filter_Adj_Gain'
//     '<S182>/LP_Filter_Adj_Gain'
//     '<S83>/LP_Filter_Adj_Gain1'
//     '<S89>/LP_Filter_Adj_Gain'
//     '<S90>/LP_Filter_Adj_Gain'
//     '<S265>/LP_Filter_Adj_Gain'
//     '<S265>/LP_Filter_Adj_Gain1'
//     '<S327>/LP_Filter_Adj_Gain'
//     '<S344>/LP_Filter_Adj_Gain'
//     '<S372>/LP_Filter_Adj_Gain'
//     ...

void MX_Gtwy_Cont_LP_Filter_Adj_Gain(uint8_T rtu_Gain, int16_T rtu_Input,
  int32_T *rty_Output, rtDW_LP_Filter_Adj_Gain_MX_Gtwy *localDW)
{
  // Chart: '<S155>/LP_Filter_Adj_Gain'
  // Gateway: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  // During: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  if ((uint32_T)localDW->bitsForTID1.is_active_c1_MX_Library == 0U) {
    // Entry: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    localDW->bitsForTID1.is_active_c1_MX_Library = 1U;

    // Entry Internal: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    // Transition: '<S159>:3'
    localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_Control_IN_INITIAL;

    // Entry 'INITIAL': '<S159>:1'
    *rty_Output = (int32_T)((int32_T)rtu_Input << 16);
  } else if (localDW->bitsForTID1.is_c1_MX_Library == MX_Gtwy_Control_IN_INITIAL)
  {
    // During 'INITIAL': '<S159>:1'
    // Transition: '<S159>:4'
    localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_Control_IN_LP_FILTER;
  } else {
    // During 'LP_FILTER': '<S159>:2'
    *rty_Output += div_s32((int32_T)((int32_T)((int32_T)rtu_Input << 16) -
      *rty_Output), (int32_T)(1 << (int32_T)rtu_Gain));
  }

  // End of Chart: '<S155>/LP_Filter_Adj_Gain'
}

//
//  System initialize for atomic system:
//     '<S151>/Remove_OOR_Levels'
//     '<S182>/Remove_OOR_Levels'
//     '<S83>/Remove_OOR_Levels'
//     '<S217>/Remove_OOR_Levels'
//     '<S265>/Remove_OOR_Levels'

void MX_Gtwy__Remove_OOR_Levels_Init(uint16_T *rty_fltValue_out,
  rtDW_Remove_OOR_Levels_MX_Gtwy_ *localDW)
{
  // SystemInitialize for Chart: '<S157>/RemoveOORLevels'
  localDW->fltValue_old = 0U;
  *rty_fltValue_out = 0U;
}

//
//  System reset for atomic system:
//     '<S151>/Remove_OOR_Levels'
//     '<S182>/Remove_OOR_Levels'
//     '<S83>/Remove_OOR_Levels'
//     '<S217>/Remove_OOR_Levels'
//     '<S265>/Remove_OOR_Levels'

void MX_Gtwy_Remove_OOR_Levels_Reset(uint16_T *rty_fltValue_out,
  rtDW_Remove_OOR_Levels_MX_Gtwy_ *localDW)
{
  // SystemReset for Chart: '<S157>/RemoveOORLevels'
  localDW->fltValue_old = 0U;
  *rty_fltValue_out = 0U;
}

//
//  Output and update for atomic system:
//     '<S151>/Remove_OOR_Levels'
//     '<S182>/Remove_OOR_Levels'
//     '<S83>/Remove_OOR_Levels'
//     '<S217>/Remove_OOR_Levels'
//     '<S265>/Remove_OOR_Levels'

void MX_Gtwy_Contr_Remove_OOR_Levels(uint16_T rtu_fltValue_in, uint16_T
  *rty_fltValue_out, rtDW_Remove_OOR_Levels_MX_Gtwy_ *localDW, uint16_T
  rtp_OORH_LEVEL, uint16_T rtp_OORL_LEVEL)
{
  // Chart: '<S157>/RemoveOORLevels'
  // Gateway: Remove_OOR_Levels/RemoveOORLevels
  // During: Remove_OOR_Levels/RemoveOORLevels
  // Entry Internal: Remove_OOR_Levels/RemoveOORLevels
  // Transition: '<S160>:1'
  if ((rtu_fltValue_in > rtp_OORL_LEVEL) && (rtu_fltValue_in < rtp_OORH_LEVEL))
  {
    // Transition: '<S160>:2'
    // Transition: '<S160>:3'
    *rty_fltValue_out = rtu_fltValue_in;
    localDW->fltValue_old = rtu_fltValue_in;

    // Transition: '<S160>:4'
  } else {
    // Transition: '<S160>:5'
    *rty_fltValue_out = localDW->fltValue_old;
  }

  // End of Chart: '<S157>/RemoveOORLevels'
}

// System initialize for atomic system: '<S83>/LP_Filter_Adj_Gain'
void MX_LP_Filter_Adj_Gain_gfud_Init(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_Gain_MX_j5ng *localDW)
{
  // SystemInitialize for Chart: '<S201>/LP_Filter_Adj_Gain'
  localDW->bitsForTID1.is_active_c1_MX_Library = 0U;
  localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_p1y5;
  *rty_Output = 0;
}

// Output and update for atomic system: '<S83>/LP_Filter_Adj_Gain'
void MX_Gtwy_LP_Filter_Adj_Gain_hwrc(uint8_T rtu_Gain, int16_T rtu_Input,
  int32_T *rty_Output, rtDW_LP_Filter_Adj_Gain_MX_j5ng *localDW)
{
  // Chart: '<S201>/LP_Filter_Adj_Gain'
  // Gateway: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  // During: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
  if ((uint32_T)localDW->bitsForTID1.is_active_c1_MX_Library == 0U) {
    // Entry: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    localDW->bitsForTID1.is_active_c1_MX_Library = 1U;

    // Entry Internal: LP_Filter_Adj_Gain/LP_Filter_Adj_Gain
    // Transition: '<S206>:3'
    localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_Control_IN_INITIAL_aowf;

    // Entry 'INITIAL': '<S206>:1'
    *rty_Output = (int32_T)((int32_T)rtu_Input << 16);
  } else if (localDW->bitsForTID1.is_c1_MX_Library ==
             MX_Gtwy_Control_IN_INITIAL_aowf) {
    // During 'INITIAL': '<S206>:1'
    // Transition: '<S206>:4'
    localDW->bitsForTID1.is_c1_MX_Library = MX_Gtwy_Contr_IN_LP_FILTER_hzab;
  } else {
    // During 'LP_FILTER': '<S206>:2'
    *rty_Output += div_s32((int32_T)((int32_T)((int32_T)rtu_Input << 16) -
      *rty_Output), (int32_T)(1 << (int32_T)rtu_Gain));
  }

  // End of Chart: '<S201>/LP_Filter_Adj_Gain'
}

// System initialize for atomic system: '<S217>/LP_Filter_Adj_System'
void MX_Gt_LP_Filter_Adj_System_Init(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_System_MX_Gt *localDW)
{
  // SystemInitialize for Chart: '<S219>/LP_Fitler_Adj_Gain'
  localDW->bitsForTID1.is_active_c2_MX_Library = 0U;
  localDW->bitsForTID1.is_c2_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_lpib;
  *rty_Output = 0;
}

// System reset for atomic system: '<S217>/LP_Filter_Adj_System'
void MX_G_LP_Filter_Adj_System_Reset(int32_T *rty_Output,
  rtDW_LP_Filter_Adj_System_MX_Gt *localDW)
{
  // SystemReset for Chart: '<S219>/LP_Fitler_Adj_Gain'
  localDW->bitsForTID1.is_active_c2_MX_Library = 0U;
  localDW->bitsForTID1.is_c2_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_lpib;
  *rty_Output = 0;
}

// Output and update for atomic system: '<S217>/LP_Filter_Adj_System'
void MX_Gtwy_Co_LP_Filter_Adj_System(uint8_T rtu_Gain, int16_T rtu_Input,
  uint8_T rtu_state_System, int32_T *rty_Output, rtDW_LP_Filter_Adj_System_MX_Gt
  *localDW)
{
  // Chart: '<S219>/LP_Fitler_Adj_Gain'
  // Gateway: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
  // During: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
  if ((uint32_T)localDW->bitsForTID1.is_active_c2_MX_Library == 0U) {
    // Entry: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
    localDW->bitsForTID1.is_active_c2_MX_Library = 1U;

    // Entry Internal: LP_Filter_Adj_System/LP_Fitler_Adj_Gain
    // Transition: '<S223>:3'
    localDW->bitsForTID1.is_c2_MX_Library = MX_Gtwy_Control_IN_INITIAL_obic;

    // Entry 'INITIAL': '<S223>:1'
    *rty_Output = (int32_T)((int32_T)rtu_Input << 16);
  } else if (localDW->bitsForTID1.is_c2_MX_Library ==
             MX_Gtwy_Control_IN_INITIAL_obic) {
    // During 'INITIAL': '<S223>:1'
    if ((int32_T)rtu_state_System == 1) {
      // Transition: '<S223>:4'
      localDW->bitsForTID1.is_c2_MX_Library = MX_Gtwy_Contr_IN_LP_FILTER_nfsi;
    }
  } else {
    // During 'LP_FILTER': '<S223>:2'
    *rty_Output += div_s32((int32_T)((int32_T)((int32_T)rtu_Input << 16) -
      *rty_Output), (int32_T)(1 << (int32_T)rtu_Gain));
  }

  // End of Chart: '<S219>/LP_Fitler_Adj_Gain'
}

//
//  System initialize for enable system:
//     '<S329>/control_loop'
//     '<S346>/control_loop'
//     '<S392>/control_loop'
//     '<S502>/control_loop'
//     '<S519>/control_loop'

void MX_Gtwy_Contr_control_loop_Init(rtDW_control_loop_MX_Gtwy_Contr *localDW)
{
  // InitializeConditions for DiscreteIntegrator: '<S337>/Discrete-Time Integrator' 
  localDW->DiscreteTimeIntegrator_DSTATE = 0;
}

//
//  System reset for enable system:
//     '<S329>/control_loop'
//     '<S346>/control_loop'
//     '<S392>/control_loop'
//     '<S502>/control_loop'
//     '<S519>/control_loop'

void MX_Gtwy_Cont_control_loop_Reset(rtDW_control_loop_MX_Gtwy_Contr *localDW)
{
  // InitializeConditions for DiscreteIntegrator: '<S337>/Discrete-Time Integrator' 
  localDW->DiscreteTimeIntegrator_DSTATE = 0;
}

//
//  Disable for enable system:
//     '<S329>/control_loop'
//     '<S346>/control_loop'
//     '<S392>/control_loop'
//     '<S502>/control_loop'
//     '<S519>/control_loop'

void MX_Gtwy_Co_control_loop_Disable(int16_T *rty_error, uint16_T *rty_duty,
  rtB_control_loop_MX_Gtwy_Contro *localB, rtDW_control_loop_MX_Gtwy_Contr
  *localDW)
{
  // Disable for DiscreteIntegrator: '<S337>/Discrete-Time Integrator'
  localDW->DiscreteTimeIntegrator_DSTATE = localB->DiscreteTimeIntegrator;

  // Outputs for Enabled SubSystem: '<S329>/control_loop' incorporates:
  //   EnablePort: '<S337>/Enable'

  // Disable for Outport: '<S337>/error'
  *rty_error = 0;

  // Disable for Outport: '<S337>/duty'
  *rty_duty = ((uint16_T)0U);

  // End of Outputs for SubSystem: '<S329>/control_loop'
  localDW->control_loop_MODE = false;
}

//
//  Output and update for enable system:
//     '<S329>/control_loop'
//     '<S346>/control_loop'
//     '<S392>/control_loop'
//     '<S502>/control_loop'
//     '<S519>/control_loop'

void MX_Gtwy_Control_control_loop(boolean_T rtu_Enable, uint16_T rtu_i_cmd,
  uint16_T rtu_i_fbk, int16_T *rty_error, uint16_T *rty_duty,
  rtB_control_loop_MX_Gtwy_Contro *localB, rtDW_control_loop_MX_Gtwy_Contr
  *localDW, uint16_T rtp_KP, uint16_T rtp_KI)
{
  int16_T rtb_Saturation_dwkj;
  int32_T tmp;
  uint16_T tmp_0;
  uint16_T tmp_1;

  // Outputs for Enabled SubSystem: '<S329>/control_loop' incorporates:
  //   EnablePort: '<S337>/Enable'

  if (rtu_Enable) {
    if (!localDW->control_loop_MODE) {
      MX_Gtwy_Cont_control_loop_Reset(localDW);
      localDW->control_loop_MODE = true;
    }

    // Sum: '<S337>/Sum'
    tmp_0 = (uint16_T)(uint32_T)((uint32_T)(int32_T)((int32_T)rtu_i_cmd + 1) >>
      1);
    if ((int32_T)tmp_0 > 32767) {
      tmp_0 = 32767U;
    }

    tmp_1 = (uint16_T)(uint32_T)((uint32_T)(int32_T)((int32_T)rtu_i_fbk + 1) >>
      1);
    if ((int32_T)tmp_1 > 32767) {
      tmp_1 = 32767U;
    }

    *rty_error = (int16_T)(int32_T)((int32_T)tmp_0 - (int32_T)tmp_1);

    // End of Sum: '<S337>/Sum'

    // DiscreteIntegrator: '<S337>/Discrete-Time Integrator'
    localB->DiscreteTimeIntegrator = localDW->DiscreteTimeIntegrator_DSTATE;

    // Gain: '<S337>/Kp'
    tmp_0 = rtp_KP;
    if ((int32_T)rtp_KP > 32767) {
      tmp_0 = 32767U;
    }

    tmp = (int32_T)((int32_T)tmp_0 * (int32_T)*rty_error);
    tmp = (int32_T)((int32_T)(tmp >> 12) + ((int32_T)(tmp & 2048) != 0));
    if (tmp > 32767) {
      tmp = 32767;
    } else {
      if (tmp < -32768) {
        tmp = -32768;
      }
    }

    // Sum: '<S337>/Sum1' incorporates:
    //   Gain: '<S337>/Kp'

    rtb_Saturation_dwkj = (int16_T)(int32_T)(tmp + (int32_T)
      localB->DiscreteTimeIntegrator);

    // Saturate: '<S337>/Saturation'
    if ((int32_T)rtb_Saturation_dwkj > (int32_T)16384) {
      rtb_Saturation_dwkj = 16384;
    } else {
      if ((int32_T)rtb_Saturation_dwkj < (int32_T)0) {
        rtb_Saturation_dwkj = 0;
      }
    }

    // End of Saturate: '<S337>/Saturation'

    // DataTypeConversion: '<S337>/Data Type Conversion'
    if ((int32_T)rtb_Saturation_dwkj <= 0) {
      *rty_duty = 0U;
    } else if ((int32_T)rtb_Saturation_dwkj > 16383) {
      *rty_duty = MAX_uint16_T;
    } else {
      *rty_duty = (uint16_T)(int32_T)((int32_T)rtb_Saturation_dwkj << 2);
    }

    // End of DataTypeConversion: '<S337>/Data Type Conversion'

    // Gain: '<S337>/Ki'
    tmp_0 = rtp_KI;
    if ((int32_T)rtp_KI > 32767) {
      tmp_0 = 32767U;
    }

    tmp = (int32_T)((int32_T)tmp_0 * (int32_T)*rty_error);
    tmp = (int32_T)((int32_T)(tmp >> 12) + ((int32_T)(tmp & 2048) != 0));
    if (tmp > 32767) {
      tmp = 32767;
    } else {
      if (tmp < -32768) {
        tmp = -32768;
      }
    }

    // Update for DiscreteIntegrator: '<S337>/Discrete-Time Integrator' incorporates:
    //   Gain: '<S337>/Ki'

    localDW->DiscreteTimeIntegrator_DSTATE = (int16_T)(int32_T)((int32_T)
      localDW->DiscreteTimeIntegrator_DSTATE + tmp);
    if ((int32_T)localDW->DiscreteTimeIntegrator_DSTATE >= (int32_T)16384) {
      localDW->DiscreteTimeIntegrator_DSTATE = 16384;
    } else {
      if ((int32_T)localDW->DiscreteTimeIntegrator_DSTATE <= (int32_T)(-16384))
      {
        localDW->DiscreteTimeIntegrator_DSTATE = (-16384);
      }
    }

    // End of Update for DiscreteIntegrator: '<S337>/Discrete-Time Integrator'
  } else {
    if (localDW->control_loop_MODE) {
      MX_Gtwy_Co_control_loop_Disable(rty_error, rty_duty, localB, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S329>/control_loop'
}

//
//  System initialize for atomic system:
//     '<S329>/hc_pair_OpenLoop'
//     '<S346>/hc_pair_OpenLoop'
//     '<S367>/hc_pair_OpenLoop'
//     '<S392>/hc_pair_OpenLoop'
//     '<S435>/hc_pair_OpenLoop'
//     '<S454>/hc_pair_OpenLoop'
//     '<S502>/hc_pair_OpenLoop'
//     '<S519>/hc_pair_OpenLoop'

void MX_Gtwy_C_hc_pair_OpenLoop_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_OpenLoop_MX_Gtwy_C *localDW)
{
  // SystemInitialize for Chart: '<S339>/Fault monitor'
  localDW->bitsForTID0.is_FAULT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_OC_STG = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_SHORT_TO_BATTERY = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_SHORT_TO_GROUND = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID0.is_OVERCURRENT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_active_c63_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_cnt_oc = 0U;
  *rty_hs_cmd = 0U;
  *rty_ls_cmd = false;
  *rty_diag_state = 8U;
  *rty_oc_state = 0U;
}

//
//  System reset for atomic system:
//     '<S329>/hc_pair_OpenLoop'
//     '<S346>/hc_pair_OpenLoop'
//     '<S367>/hc_pair_OpenLoop'
//     '<S392>/hc_pair_OpenLoop'
//     '<S435>/hc_pair_OpenLoop'
//     '<S454>/hc_pair_OpenLoop'
//     '<S502>/hc_pair_OpenLoop'
//     '<S519>/hc_pair_OpenLoop'

void MX_Gtwy__hc_pair_OpenLoop_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_OpenLoop_MX_Gtwy_C *localDW)
{
  // SystemReset for Chart: '<S339>/Fault monitor'
  localDW->bitsForTID0.is_FAULT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_OC_STG = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_SHORT_TO_BATTERY = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_SHORT_TO_GROUND = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID0.is_OVERCURRENT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
  localDW->bitsForTID0.is_active_c63_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_cnt_oc = 0U;
  *rty_hs_cmd = 0U;
  *rty_ls_cmd = false;
  *rty_diag_state = 8U;
  *rty_oc_state = 0U;
}

//
//  Output and update for atomic system:
//     '<S329>/hc_pair_OpenLoop'
//     '<S346>/hc_pair_OpenLoop'
//     '<S367>/hc_pair_OpenLoop'
//     '<S392>/hc_pair_OpenLoop'
//     '<S435>/hc_pair_OpenLoop'
//     '<S454>/hc_pair_OpenLoop'
//     '<S502>/hc_pair_OpenLoop'
//     '<S519>/hc_pair_OpenLoop'

void MX_Gtwy_Contro_hc_pair_OpenLoop(uint16_T rtu_duty, boolean_T rtu_enable,
  boolean_T rtu_diag_enable, uint16_T rtu_afbk, uint16_T rtu_Vbatt, uint16_T
  rtu_ifbk, uint8_T rtu_ocstg_check, uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_OpenLoop_MX_Gtwy_C *localDW, uint16_T rtp_IFBK_MAX, uint16_T
  rtp_NZ_DUTY, uint16_T rtp_NZ_IFBK, uint16_T rtp_OC_DB_CNT, uint16_T
  rtp_OPEN_DB_CNT, uint16_T rtp_OSTG_DB_CNT, uint16_T rtp_STB_DB_CNT, uint16_T
  rtp_STG_DB_CNT)
{
  int16_T rtb_afbk_ratio_gqt4;

  // Product: '<S339>/Divide'
  rtb_afbk_ratio_gqt4 = div_s16u32((uint32_T)((uint32_T)rtu_afbk << 8),
    (uint32_T)rtu_Vbatt);

  // Chart: '<S339>/Fault monitor'
  // Gateway: hc_pair_OpenLoop/Open_Loop/Fault monitor
  if ((uint32_T)localDW->temporalCounter_i1 < 63U) {
    localDW->temporalCounter_i1 = (uint8_T)(int32_T)((int32_T)
      localDW->temporalCounter_i1 + 1);
  }

  // During: hc_pair_OpenLoop/Open_Loop/Fault monitor
  if ((uint32_T)localDW->bitsForTID0.is_active_c63_MX_Library == 0U) {
    // Entry: hc_pair_OpenLoop/Open_Loop/Fault monitor
    localDW->bitsForTID0.is_active_c63_MX_Library = 1U;

    // Entry Internal: hc_pair_OpenLoop/Open_Loop/Fault monitor
    // Entry Internal 'OUTPUT': '<S340>:246'
    // Transition: '<S340>:248'
    localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_OFF;
    localDW->temporalCounter_i1 = 0U;

    // Entry 'OFF': '<S340>:255'
    *rty_hs_cmd = 0U;
    *rty_ls_cmd = ((int32_T)INACTIVE != 0);

    // Entry Internal 'FAULT': '<S340>:245'
    // Transition: '<S340>:27'
    localDW->bitsForTID0.is_FAULT = MX_Gtwy_Control_IN_INACTIVE;

    // Entry 'INACTIVE': '<S340>:11'
    *rty_diag_state = NORMAL;

    // Entry Internal 'OVERCURRENT': '<S340>:259'
    // Transition: '<S340>:260'
    localDW->bitsForTID0.is_OVERCURRENT = MX_Gtwy_Control_IN_NORMAL;

    // Entry 'NORMAL': '<S340>:264'
    *rty_oc_state = NORMAL;
    localDW->db_cnt_oc = 0U;
  } else {
    // During 'OUTPUT': '<S340>:246'
    switch (localDW->bitsForTID0.is_OUTPUT) {
     case MX_Gtwy_Control_IN_OFF:
      // During 'OFF': '<S340>:255'
      if (((int32_T)localDW->temporalCounter_i1 >= 50) && ((rtu_enable ==
            (int32_T)ACTIVE) && (*rty_oc_state == NORMAL) && (rtu_diag_enable ==
            (int32_T)ACTIVE))) {
        // Transition: '<S340>:299'
        // Transition: '<S340>:252'
        localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_TURNING_ON;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'TURNING_ON': '<S340>:257'
        *rty_ls_cmd = ((int32_T)ACTIVE != 0);
      }
      break;

     case MX_Gtwy_Control_IN_ON:
      // During 'ON': '<S340>:258'
      if ((rtu_enable == (int32_T)INACTIVE) || (rtu_diag_enable == (int32_T)
           INACTIVE)) {
        // Transition: '<S340>:253'
        localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_TURNING_OFF;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'TURNING_OFF': '<S340>:256'
        *rty_hs_cmd = 0U;
      } else if (*rty_oc_state == OVERCURRENT) {
        // Transition: '<S340>:249'
        localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_OFF;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OFF': '<S340>:255'
        *rty_hs_cmd = 0U;
        *rty_ls_cmd = ((int32_T)INACTIVE != 0);
      } else {
        *rty_hs_cmd = rtu_duty;
      }
      break;

     case MX_Gtwy_Control_IN_TURNING_OFF:
      // During 'TURNING_OFF': '<S340>:256'
      if ((int32_T)localDW->temporalCounter_i1 >= 2) {
        // Transition: '<S340>:251'
        localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_OFF;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OFF': '<S340>:255'
        *rty_hs_cmd = 0U;
        *rty_ls_cmd = ((int32_T)INACTIVE != 0);
      }
      break;

     default:
      // During 'TURNING_ON': '<S340>:257'
      if ((int32_T)localDW->temporalCounter_i1 >= 2) {
        // Transition: '<S340>:254'
        localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_ON;
      }
      break;
    }

    // During 'FAULT': '<S340>:245'
    if (localDW->bitsForTID0.is_FAULT == MX_Gtwy_Control_IN_ACTIVE) {
      // During 'ACTIVE': '<S340>:10'
      if (rtu_ocstg_check == ACTIVE) {
        // Transition: '<S340>:29'
        // Exit Internal 'ACTIVE': '<S340>:10'
        localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'OC_STG': '<S340>:225'
        localDW->bitsForTID0.is_OC_STG = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'OPEN_CIRCUIT': '<S340>:210'
        localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'SHORT_TO_BATTERY': '<S340>:220'
        localDW->bitsForTID0.is_SHORT_TO_BATTERY =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;

        // Exit Internal 'SHORT_TO_GROUND': '<S340>:215'
        localDW->bitsForTID0.is_SHORT_TO_GROUND =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
        localDW->bitsForTID0.is_FAULT = MX_Gtwy_Control_IN_INACTIVE;

        // Entry 'INACTIVE': '<S340>:11'
        *rty_diag_state = NORMAL;
      } else {
        switch (localDW->bitsForTID0.is_ACTIVE) {
         case MX_Gtwy_Control_IN_NORMAL:
          *rty_diag_state = NORMAL;

          // During 'NORMAL': '<S340>:208'
          if (((uint32_T)*rty_hs_cmd == (uint32_T)((uint32_T)INACTIVE << 16)) &&
              ((int32_T)rtb_afbk_ratio_gqt4 > 205) && rtu_diag_enable) {
            // Transition: '<S340>:233'
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Con_IN_SHORT_TO_BATTERY;

            // Entry Internal 'SHORT_TO_BATTERY': '<S340>:220'
            // Transition: '<S340>:221'
            localDW->bitsForTID0.is_SHORT_TO_BATTERY =
              MX_Gtwy_Control_IN_DEBOUNCE;

            // Entry 'DEBOUNCE': '<S340>:223'
            localDW->db_cnt = 0U;
          } else if ((*rty_ls_cmd) && (*rty_hs_cmd > rtp_NZ_DUTY) && (rtu_ifbk <=
                      rtp_NZ_IFBK) && rtu_diag_enable) {
            // Transition: '<S340>:234'
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_OC_STG;

            // Entry Internal 'OC_STG': '<S340>:225'
            // Transition: '<S340>:226'
            localDW->bitsForTID0.is_OC_STG = MX_Gtwy_Control_IN_DEBOUNCE;

            // Entry 'DEBOUNCE': '<S340>:228'
            localDW->db_cnt = 0U;
          } else if (((uint32_T)*rty_hs_cmd == (uint32_T)((uint32_T)INACTIVE <<
                       16)) && (*rty_ls_cmd) && ((int32_T)rtb_afbk_ratio_gqt4 >
                      64) && ((int32_T)rtb_afbk_ratio_gqt4 < 192) &&
                     rtu_diag_enable) {
            // Transition: '<S340>:236'
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_OPEN_CIRCUIT;

            // Entry Internal 'OPEN_CIRCUIT': '<S340>:210'
            // Transition: '<S340>:212'
            localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_Control_IN_DEBOUNCE;

            // Entry 'DEBOUNCE': '<S340>:211'
            localDW->db_cnt = 0U;
          } else {
            if ((!*rty_ls_cmd) && ((int32_T)rtb_afbk_ratio_gqt4 < 51) &&
                rtu_diag_enable) {
              // Transition: '<S340>:238'
              localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Cont_IN_SHORT_TO_GROUND;

              // Entry Internal 'SHORT_TO_GROUND': '<S340>:215'
              // Transition: '<S340>:216'
              localDW->bitsForTID0.is_SHORT_TO_GROUND =
                MX_Gtwy_Control_IN_DEBOUNCE;

              // Entry 'DEBOUNCE': '<S340>:218'
              localDW->db_cnt = 0U;
            }
          }
          break;

         case MX_Gtwy_Control_IN_OC_STG:
          // During 'OC_STG': '<S340>:225'
          if ((*rty_diag_state == NORMAL) && ((!*rty_ls_cmd) || (*rty_hs_cmd <=
                rtp_NZ_DUTY) || (rtu_ifbk > rtp_NZ_IFBK) || (!rtu_diag_enable)))
          {
            // Transition: '<S340>:235'
            // Exit Internal 'OC_STG': '<S340>:225'
            localDW->bitsForTID0.is_OC_STG = MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_NORMAL;

            // Entry 'NORMAL': '<S340>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID0.is_OC_STG ==
                     MX_Gtwy_Control_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S340>:228'
            if (localDW->db_cnt >= rtp_OSTG_DB_CNT) {
              // Transition: '<S340>:227'
              localDW->bitsForTID0.is_OC_STG = MX_Gtwy_Control_IN_FAULT;

              // Entry 'FAULT': '<S340>:229'
              *rty_diag_state = OPEN_STG;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = OPEN_STG;

            // During 'FAULT': '<S340>:229'
          }
          break;

         case MX_Gtwy_Control_IN_OPEN_CIRCUIT:
          // During 'OPEN_CIRCUIT': '<S340>:210'
          if ((*rty_diag_state == NORMAL) && (((uint32_T)*rty_hs_cmd !=
                (uint32_T)((uint32_T)INACTIVE << 16)) || (!*rty_ls_cmd) ||
               ((int32_T)rtb_afbk_ratio_gqt4 <= 64) || ((int32_T)
                rtb_afbk_ratio_gqt4 >= 192) || (!rtu_diag_enable))) {
            // Transition: '<S340>:237'
            // Exit Internal 'OPEN_CIRCUIT': '<S340>:210'
            localDW->bitsForTID0.is_OPEN_CIRCUIT =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_NORMAL;

            // Entry 'NORMAL': '<S340>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID0.is_OPEN_CIRCUIT ==
                     MX_Gtwy_Control_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S340>:211'
            if (localDW->db_cnt >= rtp_OPEN_DB_CNT) {
              // Transition: '<S340>:214'
              localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_Control_IN_FAULT;

              // Entry 'FAULT': '<S340>:213'
              *rty_diag_state = OPEN_CIRCUIT;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = OPEN_CIRCUIT;

            // During 'FAULT': '<S340>:213'
          }
          break;

         case MX_Gtwy_Con_IN_SHORT_TO_BATTERY:
          // During 'SHORT_TO_BATTERY': '<S340>:220'
          if ((*rty_diag_state == NORMAL) && (((uint32_T)*rty_hs_cmd !=
                (uint32_T)((uint32_T)INACTIVE << 16)) || ((int32_T)
                rtb_afbk_ratio_gqt4 <= 205) || (!rtu_diag_enable))) {
            // Transition: '<S340>:232'
            // Exit Internal 'SHORT_TO_BATTERY': '<S340>:220'
            localDW->bitsForTID0.is_SHORT_TO_BATTERY =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_NORMAL;

            // Entry 'NORMAL': '<S340>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID0.is_SHORT_TO_BATTERY ==
                     MX_Gtwy_Control_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S340>:223'
            if (localDW->db_cnt >= rtp_STB_DB_CNT) {
              // Transition: '<S340>:222'
              localDW->bitsForTID0.is_SHORT_TO_BATTERY =
                MX_Gtwy_Control_IN_FAULT;

              // Entry 'FAULT': '<S340>:224'
              *rty_diag_state = SHORT_TO_BATTERY;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = SHORT_TO_BATTERY;

            // During 'FAULT': '<S340>:224'
          }
          break;

         default:
          // During 'SHORT_TO_GROUND': '<S340>:215'
          if ((*rty_diag_state == NORMAL) && ((*rty_ls_cmd) || ((int32_T)
                rtb_afbk_ratio_gqt4 >= 51) || (!rtu_diag_enable))) {
            // Transition: '<S340>:239'
            // Exit Internal 'SHORT_TO_GROUND': '<S340>:215'
            localDW->bitsForTID0.is_SHORT_TO_GROUND =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_gc4w;
            localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_NORMAL;

            // Entry 'NORMAL': '<S340>:208'
            *rty_diag_state = NORMAL;
            localDW->db_cnt = 0U;
          } else if (localDW->bitsForTID0.is_SHORT_TO_GROUND ==
                     MX_Gtwy_Control_IN_DEBOUNCE) {
            // During 'DEBOUNCE': '<S340>:218'
            if (localDW->db_cnt >= rtp_STG_DB_CNT) {
              // Transition: '<S340>:217'
              localDW->bitsForTID0.is_SHORT_TO_GROUND = MX_Gtwy_Control_IN_FAULT;

              // Entry 'FAULT': '<S340>:219'
              *rty_diag_state = SHORT_TO_GROUND;
            } else {
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            }
          } else {
            *rty_diag_state = SHORT_TO_GROUND;

            // During 'FAULT': '<S340>:219'
          }
          break;
        }
      }
    } else {
      *rty_diag_state = NORMAL;

      // During 'INACTIVE': '<S340>:11'
      if (rtu_ocstg_check != ACTIVE) {
        // Transition: '<S340>:28'
        localDW->bitsForTID0.is_FAULT = MX_Gtwy_Control_IN_ACTIVE;

        // Entry Internal 'ACTIVE': '<S340>:10'
        // Transition: '<S340>:231'
        localDW->bitsForTID0.is_ACTIVE = MX_Gtwy_Control_IN_NORMAL;

        // Entry 'NORMAL': '<S340>:208'
        localDW->db_cnt = 0U;
      }
    }

    // During 'OVERCURRENT': '<S340>:259'
    switch (localDW->bitsForTID0.is_OVERCURRENT) {
     case MX_Gtwy_Control_IN_NORMAL:
      *rty_oc_state = NORMAL;

      // During 'NORMAL': '<S340>:264'
      if ((rtu_ifbk > rtp_IFBK_MAX) && rtu_diag_enable) {
        // Transition: '<S340>:261'
        localDW->db_cnt_oc = (uint16_T)(int32_T)((int32_T)localDW->db_cnt_oc + 1);
        localDW->bitsForTID0.is_OVERCURRENT = MX_Gtwy_Control_IN_debounce;
      }
      break;

     case MX_Gtwy_Control_IN_debounce:
      // During 'debounce': '<S340>:265'
      if (localDW->db_cnt_oc >= rtp_OC_DB_CNT) {
        // Transition: '<S340>:263'
        localDW->bitsForTID0.is_OVERCURRENT = MX_Gtwy_Control_IN_error;

        // Entry 'error': '<S340>:266'
        *rty_oc_state = OVERCURRENT;
      } else if ((rtu_ifbk <= rtp_IFBK_MAX) || (!rtu_diag_enable)) {
        // Transition: '<S340>:262'
        localDW->bitsForTID0.is_OVERCURRENT = MX_Gtwy_Control_IN_NORMAL;

        // Entry 'NORMAL': '<S340>:264'
        *rty_oc_state = NORMAL;
        localDW->db_cnt_oc = 0U;
      } else {
        localDW->db_cnt_oc = (uint16_T)(int32_T)((int32_T)localDW->db_cnt_oc + 1);
      }
      break;

     default:
      *rty_oc_state = OVERCURRENT;

      // During 'error': '<S340>:266'
      *rty_hs_cmd = 0U;
      *rty_ls_cmd = ((int32_T)INACTIVE != 0);
      break;
    }
  }

  // End of Chart: '<S339>/Fault monitor'
}

//
//  System initialize for atomic system:
//     '<S306>/hc_pair_ClosedLoop_v5'
//     '<S307>/hc_pair_ClosedLoop_v5'
//     '<S387>/hc_pair_ClosedLoop_v5'
//     '<S492>/hc_pair_ClosedLoop_v5'
//     '<S493>/hc_pair_ClosedLoop_v5'

void MX_G_hc_pair_ClosedLoop_v5_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_ClosedLoop_v5_MX_G *localDW)
{
  // InitializeConditions for UnitDelay: '<S329>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S329>/Unit Delay'
  localDW->UnitDelay_DSTATE = false;

  // SystemInitialize for Enabled SubSystem: '<S329>/control_loop'
  MX_Gtwy_Contr_control_loop_Init(&localDW->control_loop);

  // End of SystemInitialize for SubSystem: '<S329>/control_loop'

  // SystemInitialize for Atomic SubSystem: '<S329>/hc_pair_OpenLoop'
  MX_Gtwy_C_hc_pair_OpenLoop_Init(rty_hs_cmd, rty_ls_cmd, rty_oc_state,
    rty_diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemInitialize for SubSystem: '<S329>/hc_pair_OpenLoop'
}

//
//  System reset for atomic system:
//     '<S306>/hc_pair_ClosedLoop_v5'
//     '<S307>/hc_pair_ClosedLoop_v5'
//     '<S387>/hc_pair_ClosedLoop_v5'
//     '<S492>/hc_pair_ClosedLoop_v5'
//     '<S493>/hc_pair_ClosedLoop_v5'

void MX__hc_pair_ClosedLoop_v5_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_oc_state, uint8_T *rty_diag_state,
  rtDW_hc_pair_ClosedLoop_v5_MX_G *localDW)
{
  // InitializeConditions for UnitDelay: '<S329>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S329>/Unit Delay'
  localDW->UnitDelay_DSTATE = false;

  // SystemReset for Atomic SubSystem: '<S329>/hc_pair_OpenLoop'
  MX_Gtwy__hc_pair_OpenLoop_Reset(rty_hs_cmd, rty_ls_cmd, rty_oc_state,
    rty_diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemReset for SubSystem: '<S329>/hc_pair_OpenLoop'
}

//
//  Disable for atomic system:
//     '<S306>/hc_pair_ClosedLoop_v5'
//     '<S307>/hc_pair_ClosedLoop_v5'
//     '<S387>/hc_pair_ClosedLoop_v5'
//     '<S492>/hc_pair_ClosedLoop_v5'
//     '<S493>/hc_pair_ClosedLoop_v5'

void M_hc_pair_ClosedLoop_v5_Disable(int16_T *rty_error,
  rtB_hc_pair_ClosedLoop_v5_MX_Gt *localB, rtDW_hc_pair_ClosedLoop_v5_MX_G
  *localDW)
{
  // Disable for Enabled SubSystem: '<S329>/control_loop'
  if (localDW->control_loop.control_loop_MODE) {
    MX_Gtwy_Co_control_loop_Disable(rty_error, &localB->DataTypeConversion,
      &localB->control_loop, &localDW->control_loop);
  }

  // End of Disable for SubSystem: '<S329>/control_loop'
}

//
//  Output and update for atomic system:
//     '<S306>/hc_pair_ClosedLoop_v5'
//     '<S307>/hc_pair_ClosedLoop_v5'
//     '<S387>/hc_pair_ClosedLoop_v5'
//     '<S492>/hc_pair_ClosedLoop_v5'
//     '<S493>/hc_pair_ClosedLoop_v5'

void MX_Gtwy_C_hc_pair_ClosedLoop_v5(uint16_T rtu_i_cmd, boolean_T
  rtu_enable_LoSide, boolean_T rtu_diag_enable, uint16_T rtu_afbk, uint16_T
  rtu_Vbatt, uint16_T rtu_i_fbk, uint8_T rtu_ocstg_check, uint16_T *rty_hs_cmd,
  boolean_T *rty_ls_cmd, uint8_T *rty_oc_state, uint8_T *rty_diag_state, int16_T
  *rty_error, rtB_hc_pair_ClosedLoop_v5_MX_Gt *localB,
  rtDW_hc_pair_ClosedLoop_v5_MX_G *localDW, uint16_T rtp_KP, uint16_T rtp_KI,
  uint16_T rtp_IFBK_MAX, uint16_T rtp_NZ_DUTY, uint16_T rtp_NZ_IFBK, uint16_T
  rtp_OC_DB_CNT, uint16_T rtp_OPEN_DB_CNT, uint16_T rtp_OSTG_DB_CNT, uint16_T
  rtp_STB_DB_CNT, uint16_T rtp_STG_DB_CNT, uint8_T rtp_BIDIRECTIONAL_CTRL)
{
  boolean_T rtb_HiddenBuf_InsertedFor_contr;

  // SignalConversion: '<S329>/HiddenBuf_InsertedFor_control_loop_at_inport_2' incorporates:
  //   Constant: '<S329>/Constant'
  //   Constant: '<S334>/Constant'
  //   Constant: '<S335>/Constant'
  //   Constant: '<S336>/Constant'
  //   Logic: '<S329>/Logical Operator'
  //   Logic: '<S329>/Logical Operator1'
  //   RelationalOperator: '<S334>/Compare'
  //   RelationalOperator: '<S335>/Compare'
  //   RelationalOperator: '<S336>/Compare'
  //   UnitDelay: '<S329>/Unit Delay'
  //   UnitDelay: '<S329>/Unit Delay1'

  rtb_HiddenBuf_InsertedFor_contr = (localDW->UnitDelay_DSTATE &&
    (localDW->UnitDelay1_DSTATE == NORMAL) && rtu_enable_LoSide &&
    rtu_diag_enable && ((rtu_i_cmd > ((uint16_T)0U)) || (rtp_BIDIRECTIONAL_CTRL
    != NON_FUNCTIONAL)));

  // Outputs for Enabled SubSystem: '<S329>/control_loop'
  MX_Gtwy_Control_control_loop(rtb_HiddenBuf_InsertedFor_contr, rtu_i_cmd,
    rtu_i_fbk, rty_error, &localB->DataTypeConversion, &localB->control_loop,
    &localDW->control_loop, rtp_KP, rtp_KI);

  // End of Outputs for SubSystem: '<S329>/control_loop'

  // Outputs for Atomic SubSystem: '<S329>/hc_pair_OpenLoop'
  MX_Gtwy_Contro_hc_pair_OpenLoop(localB->DataTypeConversion, rtu_enable_LoSide,
    rtu_diag_enable, rtu_afbk, rtu_Vbatt, rtu_i_fbk, rtu_ocstg_check, rty_hs_cmd,
    rty_ls_cmd, rty_oc_state, rty_diag_state, &localDW->hc_pair_OpenLoop,
    rtp_IFBK_MAX, rtp_NZ_DUTY, rtp_NZ_IFBK, rtp_OC_DB_CNT, rtp_OPEN_DB_CNT,
    rtp_OSTG_DB_CNT, rtp_STB_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S329>/hc_pair_OpenLoop'

  // Update for UnitDelay: '<S329>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = *rty_diag_state;

  // Update for UnitDelay: '<S329>/Unit Delay'
  localDW->UnitDelay_DSTATE = *rty_ls_cmd;
}

//
//  System initialize for atomic system:
//     '<S306>/oc_stg_detection'
//     '<S307>/oc_stg_detection'
//     '<S367>/oc_stg_detection'
//     '<S387>/oc_stg_detection'
//     '<S435>/oc_stg_detection'
//     '<S454>/oc_stg_detection'
//     '<S492>/oc_stg_detection'
//     '<S493>/oc_stg_detection'

void MX_Gtwy_C_oc_stg_detection_Init(uint8_T *rty_diag_state_out, uint8_T
  *rty_ocstg_check, rtDW_oc_stg_detection_MX_Gtwy_C *localDW)
{
  // SystemInitialize for Chart: '<S330>/oc_operation_detection'
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID0.is_active_c5_MX_Library = 0U;
  localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_jstd;
  localDW->debounceCount = 0U;
  *rty_diag_state_out = 0U;
  *rty_ocstg_check = 0U;
}

//
//  System reset for atomic system:
//     '<S306>/oc_stg_detection'
//     '<S307>/oc_stg_detection'
//     '<S367>/oc_stg_detection'
//     '<S387>/oc_stg_detection'
//     '<S435>/oc_stg_detection'
//     '<S454>/oc_stg_detection'
//     '<S492>/oc_stg_detection'
//     '<S493>/oc_stg_detection'

void MX_Gtwy__oc_stg_detection_Reset(uint8_T *rty_diag_state_out, uint8_T
  *rty_ocstg_check, rtDW_oc_stg_detection_MX_Gtwy_C *localDW)
{
  // SystemReset for Chart: '<S330>/oc_operation_detection'
  localDW->temporalCounter_i1 = 0U;
  localDW->bitsForTID0.is_active_c5_MX_Library = 0U;
  localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_jstd;
  localDW->debounceCount = 0U;
  *rty_diag_state_out = 0U;
  *rty_ocstg_check = 0U;
}

//
//  Output and update for atomic system:
//     '<S306>/oc_stg_detection'
//     '<S307>/oc_stg_detection'
//     '<S367>/oc_stg_detection'
//     '<S387>/oc_stg_detection'
//     '<S435>/oc_stg_detection'
//     '<S454>/oc_stg_detection'
//     '<S492>/oc_stg_detection'
//     '<S493>/oc_stg_detection'

void MX_Gtwy_Contro_oc_stg_detection(uint8_T rtu_oc_state, uint8_T
  rtu_diag_state_in, uint8_T *rty_diag_state_out, uint8_T *rty_ocstg_check,
  rtDW_oc_stg_detection_MX_Gtwy_C *localDW, uint16_T rtp_OPEN_DB_CNT, uint16_T
  rtp_STG_DB_CNT)
{
  // Chart: '<S330>/oc_operation_detection'
  // Gateway: oc_stg_detection/oc_operation_detection
  if ((uint32_T)localDW->temporalCounter_i1 < 63U) {
    localDW->temporalCounter_i1 = (uint8_T)(int32_T)((int32_T)
      localDW->temporalCounter_i1 + 1);
  }

  // During: oc_stg_detection/oc_operation_detection
  if ((uint32_T)localDW->bitsForTID0.is_active_c5_MX_Library == 0U) {
    // Entry: oc_stg_detection/oc_operation_detection
    localDW->bitsForTID0.is_active_c5_MX_Library = 1U;

    // Entry Internal: oc_stg_detection/oc_operation_detection
    // Transition: '<S341>:8'
    localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_Control_IN_NORMAL_ngcs;

    // Entry 'NORMAL': '<S341>:1'
    *rty_diag_state_out = NORMAL;
    *rty_ocstg_check = INACTIVE;
  } else {
    switch (localDW->bitsForTID0.is_c5_MX_Library) {
     case MX_Gtwy_Con_IN_DIAG_STATE_ERROR:
      *rty_ocstg_check = INACTIVE;

      // During 'DIAG_STATE_ERROR': '<S341>:5'
      break;

     case MX_Gtwy_Control_IN_NORMAL_ngcs:
      *rty_ocstg_check = INACTIVE;

      // During 'NORMAL': '<S341>:1'
      // Unable to distinguish
      // between Open or STG fault
      if (rtu_diag_state_in == OPEN_STG) {
        // Transition: '<S341>:9'
        localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_IN_OPEN_STG_ERROR_RESET;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OPEN_STG_ERROR_RESET': '<S341>:3'
        *rty_diag_state_out = NORMAL;
        *rty_ocstg_check = ACTIVE;
      } else {
        // Overcurrent Fault
        if (rtu_oc_state != NORMAL) {
          // Transition: '<S341>:10'
          localDW->bitsForTID0.is_c5_MX_Library =
            MX_Gtwy_Contr_IN_OC_STATE_ERROR;

          // Entry 'OC_STATE_ERROR': '<S341>:2'
          *rty_diag_state_out = rtu_oc_state;
        } else {
          // STB, STG or Open Circuit Fault
          if ((rtu_diag_state_in == SHORT_TO_GROUND) || (rtu_diag_state_in ==
               SHORT_TO_BATTERY) || (rtu_diag_state_in == OPEN_CIRCUIT)) {
            // Transition: '<S341>:12'
            localDW->bitsForTID0.is_c5_MX_Library =
              MX_Gtwy_Con_IN_DIAG_STATE_ERROR;

            // Entry 'DIAG_STATE_ERROR': '<S341>:5'
            *rty_diag_state_out = rtu_diag_state_in;
          }
        }
      }
      break;

     case MX_Gtwy_Contr_IN_OC_STATE_ERROR:
      *rty_ocstg_check = INACTIVE;

      // During 'OC_STATE_ERROR': '<S341>:2'
      break;

     case MX_Gtwy__IN_OPEN_STG_DIAG_STATE:
      *rty_ocstg_check = INACTIVE;

      // During 'OPEN_STG_DIAG_STATE': '<S341>:6'
      if ((int32_T)localDW->temporalCounter_i1 >= 5) {
        // Transition: '<S341>:11'
        localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_Contr_IN_OPEN_STG_ERROR;

        // Entry 'OPEN_STG_ERROR': '<S341>:4'
        localDW->debounceCount = 0U;
      }
      break;

     case MX_Gtwy_Contr_IN_OPEN_STG_ERROR:
      *rty_ocstg_check = INACTIVE;

      // During 'OPEN_STG_ERROR': '<S341>:4'
      if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)((int32_T)
            rtp_OPEN_DB_CNT + (int32_T)rtp_STG_DB_CNT) + 100)) {
        // Transition: '<S341>:15'
        localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_Contr_IN_OPEN_STG_RESET;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OPEN_STG_RESET': '<S341>:7'
        *rty_ocstg_check = RESET;
      } else {
        *rty_diag_state_out = rtu_diag_state_in;

        // Transition: '<S341>:17'
        if (rtu_diag_state_in == NORMAL) {
          // Transition: '<S341>:16'
          localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
            localDW->debounceCount + 1);
        }
      }
      break;

     case MX_Gtwy_IN_OPEN_STG_ERROR_RESET:
      *rty_ocstg_check = ACTIVE;

      // During 'OPEN_STG_ERROR_RESET': '<S341>:3'
      if ((int32_T)localDW->temporalCounter_i1 >= 5) {
        // Transition: '<S341>:13'
        localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy__IN_OPEN_STG_DIAG_STATE;
        localDW->temporalCounter_i1 = 0U;

        // Entry 'OPEN_STG_DIAG_STATE': '<S341>:6'
        *rty_ocstg_check = INACTIVE;
      }
      break;

     default:
      *rty_ocstg_check = RESET;

      // During 'OPEN_STG_RESET': '<S341>:7'
      if ((int32_T)localDW->temporalCounter_i1 >= 50) {
        // Transition: '<S341>:14'
        localDW->bitsForTID0.is_c5_MX_Library = MX_Gtwy_Control_IN_NORMAL_ngcs;

        // Entry 'NORMAL': '<S341>:1'
        *rty_diag_state_out = NORMAL;
        *rty_ocstg_check = INACTIVE;
      }
      break;
    }
  }

  // End of Chart: '<S330>/oc_operation_detection'
}

//
//  System initialize for atomic system:
//     '<S299>/hc_pair_control'
//     '<S299>/hc_pair_control1'
//     '<S384>/hc_pair_control'
//     '<S485>/hc_pair_control'
//     '<S485>/hc_pair_control1'

void MX__output_pair_ClosedLoop_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_ClosedLoop_MX_G *localB,
  rtDW_output_pair_ClosedLoop_MX_ *localDW)
{
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S306>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S306>/Unit Delay4'
  localDW->UnitDelay4_DSTATE = ((uint8_T)0U);

  // SystemInitialize for Atomic SubSystem: '<S327>/LP_Filter_Adj_Gain'
  MX_Gtwy_LP_Filter_Adj_Gain_Init(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemInitialize for SubSystem: '<S327>/LP_Filter_Adj_Gain'

  // SystemInitialize for Atomic SubSystem: '<S306>/oc_stg_detection'
  MX_Gtwy_C_oc_stg_detection_Init(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemInitialize for SubSystem: '<S306>/oc_stg_detection'

  // SystemInitialize for Chart: '<S306>/control'
  localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_active_c39_MX_Library = 0U;
  localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  localB->icmd_Out = 0U;
  localB->enable_LoSide = false;

  // SystemInitialize for Atomic SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
  MX_G_hc_pair_ClosedLoop_v5_Init(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_ClosedLoop_v5);

  // End of SystemInitialize for SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
}

//
//  System reset for atomic system:
//     '<S299>/hc_pair_control'
//     '<S299>/hc_pair_control1'
//     '<S384>/hc_pair_control'
//     '<S485>/hc_pair_control'
//     '<S485>/hc_pair_control1'

void MX_output_pair_ClosedLoop_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_ClosedLoop_MX_G *localB,
  rtDW_output_pair_ClosedLoop_MX_ *localDW)
{
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S306>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S306>/Unit Delay4'
  localDW->UnitDelay4_DSTATE = ((uint8_T)0U);

  // SystemReset for Atomic SubSystem: '<S327>/LP_Filter_Adj_Gain'
  MX_Gtw_LP_Filter_Adj_Gain_Reset(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemReset for SubSystem: '<S327>/LP_Filter_Adj_Gain'

  // SystemReset for Atomic SubSystem: '<S306>/oc_stg_detection'
  MX_Gtwy__oc_stg_detection_Reset(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemReset for SubSystem: '<S306>/oc_stg_detection'

  // SystemReset for Chart: '<S306>/control'
  localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->bitsForTID0.is_active_c39_MX_Library = 0U;
  localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  localB->icmd_Out = 0U;
  localB->enable_LoSide = false;

  // SystemReset for Atomic SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
  MX__hc_pair_ClosedLoop_v5_Reset(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_ClosedLoop_v5);

  // End of SystemReset for SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
}

//
//  Disable for atomic system:
//     '<S299>/hc_pair_control'
//     '<S299>/hc_pair_control1'
//     '<S384>/hc_pair_control'
//     '<S485>/hc_pair_control'
//     '<S485>/hc_pair_control1'

void output_pair_ClosedLoop_Disable(int16_T *rty_errorCC,
  rtB_output_pair_ClosedLoop_MX_G *localB, rtDW_output_pair_ClosedLoop_MX_
  *localDW)
{
  // Disable for Atomic SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
  M_hc_pair_ClosedLoop_v5_Disable(rty_errorCC, &localB->hc_pair_ClosedLoop_v5,
    &localDW->hc_pair_ClosedLoop_v5);

  // End of Disable for SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
}

//
//  Output and update for atomic system:
//     '<S299>/hc_pair_control'
//     '<S299>/hc_pair_control1'
//     '<S384>/hc_pair_control'
//     '<S485>/hc_pair_control'
//     '<S485>/hc_pair_control1'

void MX_Gtwy__output_pair_ClosedLoop(uint16_T rtu_i_cmd, boolean_T
  rtu_enable_STGOffDiag, uint16_T rtu_afbk_A2D, uint16_T rtu_ifbk_A2D, uint8_T
  rtu_state_Vbattery, uint8_T rtu_state_Engine, uint16_T rtu_calc_Vbattery,
  uint16_T rtu_ain_PrecRef, uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd, int16_T
  *rty_errorCC, uint16_T *rty_calc_ifbk, uint8_T *rty_state_Output,
  rtB_output_pair_ClosedLoop_MX_G *localB, rtDW_output_pair_ClosedLoop_MX_
  *localDW, uint16_T rtp_OPEN_DB_CNT, uint16_T rtp_STG_DB_CNT, uint16_T rtp_KP,
  uint16_T rtp_KI, uint16_T rtp_IFBK_MAX, uint16_T rtp_NZ_DUTY, uint16_T
  rtp_NZ_IFBK, uint16_T rtp_OC_DB_CNT, uint16_T rtp_OSTG_DB_CNT, uint16_T
  rtp_STB_DB_CNT, uint8_T rtp_BIDIRECTIONAL_CTRL, uint16_T rtp_AFBK_GAIN,
  uint16_T rtp_IFBK_GAIN)
{
  uint16_T rtb_DataTypeConversion1_kha5;
  uint8_T rtb_ocstg_check;
  boolean_T rtb_LogicalOperator2_d2ht;
  int16_T rtb_DataTypeConversion_mxva;
  uint8_T rtb_UnitDelay1_dj5h;
  uint8_T rtb_UnitDelay4;
  uint16_T rtb_Gain_ftue;
  uint32_T tmp;

  // Gain: '<S306>/Gain'
  tmp = (uint32_T)((uint32_T)rtp_AFBK_GAIN * (uint32_T)rtu_afbk_A2D);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Gain_ftue = (uint16_T)tmp;

  // End of Gain: '<S306>/Gain'

  // Logic: '<S306>/Logical Operator2' incorporates:
  //   Constant: '<S325>/Constant'
  //   Constant: '<S326>/Constant'
  //   RelationalOperator: '<S325>/Compare'
  //   RelationalOperator: '<S326>/Compare'

  rtb_LogicalOperator2_d2ht = ((rtu_state_Vbattery != OORL) && (rtu_state_Engine
    != ENGINE_CRANKING));

  // UnitDelay: '<S306>/Unit Delay1'
  rtb_UnitDelay1_dj5h = localDW->UnitDelay1_DSTATE;

  // UnitDelay: '<S306>/Unit Delay4'
  rtb_UnitDelay4 = localDW->UnitDelay4_DSTATE;

  // DataTypeConversion: '<S327>/Data Type Conversion'
  rtb_DataTypeConversion_mxva = (int16_T)rtu_ain_PrecRef;

  // Outputs for Atomic SubSystem: '<S327>/LP_Filter_Adj_Gain'

  // Constant: '<S327>/Constant'
  MX_Gtwy_Cont_LP_Filter_Adj_Gain(((uint8_T)6U), rtb_DataTypeConversion_mxva,
    &localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of Outputs for SubSystem: '<S327>/LP_Filter_Adj_Gain'

  // DataTypeConversion: '<S327>/Data Type Conversion1'
  rtb_DataTypeConversion1_kha5 = (uint16_T)(int32_T)(localB->Output >> 16);

  // Switch: '<S327>/Switch' incorporates:
  //   Constant: '<S327>/Constant1'
  //   Constant: '<S331>/Lower Limit'
  //   Constant: '<S331>/Upper Limit'
  //   Logic: '<S331>/AND'
  //   RelationalOperator: '<S331>/Lower Test'
  //   RelationalOperator: '<S331>/Upper Test'

  if ((((uint16_T)465U) < rtb_DataTypeConversion1_kha5) &&
      (rtb_DataTypeConversion1_kha5 < ((uint16_T)569U))) {
  } else {
    rtb_DataTypeConversion1_kha5 = CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE;
  }

  // End of Switch: '<S327>/Switch'

  // Gain: '<S306>/Gain1'
  tmp = (uint32_T)((uint32_T)((uint32_T)rtp_IFBK_GAIN * (uint32_T)rtu_ifbk_A2D) >>
                   4);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  // Product: '<S327>/Divide' incorporates:
  //   Constant: '<S327>/Constant1'
  //   Gain: '<S306>/Gain1'
  //   Product: '<S327>/Divide1'

  *rty_calc_ifbk = (uint16_T)(uint32_T)((uint32_T)(tmp * (uint32_T)(uint16_T)
    ((uint32_T)rtb_DataTypeConversion1_kha5 == 0U ? MAX_uint32_T : (uint32_T)
     ((uint32_T)((uint32_T)CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE << 15) /
      (uint32_T)rtb_DataTypeConversion1_kha5))) >> 15);

  // Outputs for Atomic SubSystem: '<S306>/oc_stg_detection'
  MX_Gtwy_Contro_oc_stg_detection(rtb_UnitDelay1_dj5h, rtb_UnitDelay4,
    &localB->diag_state_out, &rtb_ocstg_check, &localDW->oc_stg_detection,
    rtp_OPEN_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S306>/oc_stg_detection'

  // Chart: '<S306>/control'
  // Gateway: output_pair_ClosedLoop/control
  // During: output_pair_ClosedLoop/control
  if ((uint32_T)localDW->bitsForTID0.is_active_c39_MX_Library == 0U) {
    // Entry: output_pair_ClosedLoop/control
    localDW->bitsForTID0.is_active_c39_MX_Library = 1U;

    // Entry Internal: output_pair_ClosedLoop/control
    // Transition: '<S328>:28'
    localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_Control_IN_FUNCTIONAL;

    // Entry Internal 'FUNCTIONAL': '<S328>:11'
    // Transition: '<S328>:26'
    localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_C_IN_STGOFF_DIAG_ACTIVE;

    // Entry 'STGOFF_DIAG_ACTIVE': '<S328>:1'
    localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
    *rty_state_Output = INACTIVE;

    // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S328>:1'
    // Transition: '<S328>:37'
    localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_Control_IN_Test_OC;

    // Entry 'Test_OC': '<S328>:8'
    localDW->debounceCount = 0U;
    localB->enable_LoSide = ((int32_T)ACTIVE != 0);
  } else {
    switch (localDW->bitsForTID0.is_c39_MX_Library) {
     case MX_Gtwy_Control_IN_DIAG_CHECK:
      // During 'DIAG_CHECK': '<S328>:4'
      // Couldn't find a fault, so go back to working
      // ?? should this condition really be recoverable??
      if (rtb_ocstg_check == RESET) {
        // Transition: '<S328>:18'
        // Exit Internal 'DIAG_CHECK': '<S328>:4'
        localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
        localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_Control_IN_FUNCTIONAL;

        // Entry Internal 'FUNCTIONAL': '<S328>:11'
        // Transition: '<S328>:26'
        localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_C_IN_STGOFF_DIAG_ACTIVE;

        // Entry 'STGOFF_DIAG_ACTIVE': '<S328>:1'
        localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
        *rty_state_Output = INACTIVE;

        // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S328>:1'
        // Transition: '<S328>:37'
        localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_Control_IN_Test_OC;

        // Entry 'Test_OC': '<S328>:8'
        localDW->debounceCount = 0U;
        localB->enable_LoSide = ((int32_T)ACTIVE != 0);
      } else {
        // Fault Detected
        if (localB->diag_state_out != NORMAL) {
          // Transition: '<S328>:29'
          // Exit Internal 'DIAG_CHECK': '<S328>:4'
          localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
          localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_Control_IN_ERROR;

          // Entry 'ERROR': '<S328>:12'
          localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
          localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          *rty_state_Output = localB->diag_state_out;
        } else if (localDW->bitsForTID0.is_DIAG_CHECK ==
                   MX_Gtwy_Control_IN_ENABLE_OFF) {
          // During 'ENABLE_OFF': '<S328>:6'
        } else {
          // During 'ENABLE_ON': '<S328>:5'
          // Give it some time to ensure low side is on
          // and detect open circuit
          if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
               rtp_OPEN_DB_CNT + 100)) {
            // Transition: '<S328>:24'
            localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_Control_IN_ENABLE_OFF;

            // Entry 'ENABLE_OFF': '<S328>:6'
            localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          } else {
            localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
              localDW->debounceCount + 1);
          }
        }
      }
      break;

     case MX_Gtwy_Control_IN_ERROR:
      // During 'ERROR': '<S328>:12'
      break;

     default:
      // During 'FUNCTIONAL': '<S328>:11'
      // Fault Detected
      if (localB->diag_state_out != NORMAL) {
        // Transition: '<S328>:30'
        // Exit Internal 'FUNCTIONAL': '<S328>:11'
        // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S328>:1'
        localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
        localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;

        // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S328>:2'
        localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
        localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_Control_IN_ERROR;

        // Entry 'ERROR': '<S328>:12'
        localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
        localB->enable_LoSide = ((int32_T)INACTIVE != 0);
        *rty_state_Output = localB->diag_state_out;
      } else {
        // Open or STG Fault detected
        // while output is on
        if (rtb_ocstg_check == ACTIVE) {
          // Transition: '<S328>:25'
          // Exit Internal 'FUNCTIONAL': '<S328>:11'
          // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S328>:1'
          localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
          localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;

          // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S328>:2'
          localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
          localDW->bitsForTID0.is_c39_MX_Library = MX_Gtwy_Control_IN_DIAG_CHECK;

          // Entry 'DIAG_CHECK': '<S328>:4'
          localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);

          // Entry Internal 'DIAG_CHECK': '<S328>:4'
          // Transition: '<S328>:23'
          localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_Control_IN_ENABLE_ON;

          // Entry 'ENABLE_ON': '<S328>:5'
          localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          localDW->debounceCount = 0U;
        } else if (localDW->bitsForTID0.is_FUNCTIONAL ==
                   MX_Gtwy_C_IN_STGOFF_DIAG_ACTIVE) {
          // During 'STGOFF_DIAG_ACTIVE': '<S328>:1'
          if (!rtu_enable_STGOffDiag) {
            // Transition: '<S328>:19'
            // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S328>:1'
            localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
            localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_STGOFF_DIAG_INACTIVE;

            // Entry 'STGOFF_DIAG_INACTIVE': '<S328>:2'
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);

            // Entry Internal 'STGOFF_DIAG_INACTIVE': '<S328>:2'
            // Transition: '<S328>:21'
            localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
              MX_Gtwy_Control_IN_ACTIVE_OFF;

            // Entry 'ACTIVE_OFF': '<S328>:13'
            localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
            *rty_state_Output = INACTIVE;
          } else if (localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE ==
                     MX_Gtwy_Control_IN_Test_OC) {
            // During 'Test_OC': '<S328>:8'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_OPEN_DB_CNT + 100)) {
              // Transition: '<S328>:36'
              localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
                MX_Gtwy_Control_IN_Test_STG;

              // Entry 'Test_STG': '<S328>:9'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)INACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          } else {
            // During 'Test_STG': '<S328>:9'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_STG_DB_CNT + 100)) {
              // Transition: '<S328>:35'
              localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
                MX_Gtwy_Control_IN_Test_OC;

              // Entry 'Test_OC': '<S328>:8'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)ACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          }
        } else {
          // During 'STGOFF_DIAG_INACTIVE': '<S328>:2'
          if (rtu_enable_STGOffDiag) {
            // Transition: '<S328>:20'
            // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S328>:2'
            localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_jgad;
            localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_C_IN_STGOFF_DIAG_ACTIVE;

            // Entry 'STGOFF_DIAG_ACTIVE': '<S328>:1'
            localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
            *rty_state_Output = INACTIVE;

            // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S328>:1'
            // Transition: '<S328>:37'
            localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
              MX_Gtwy_Control_IN_Test_OC;

            // Entry 'Test_OC': '<S328>:8'
            localDW->debounceCount = 0U;
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          } else if (localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE ==
                     MX_Gtwy_Control_IN_ACTIVE_OFF) {
            // During 'ACTIVE_OFF': '<S328>:13'
            if ((int32_T)rtu_i_cmd > 0) {
              // Transition: '<S328>:50'
              localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
                MX_Gtwy_Control_IN_ACTIVE_ON;

              // Entry 'ACTIVE_ON': '<S328>:3'
              localB->icmd_Out = rtu_i_cmd;
              *rty_state_Output = ACTIVE;
            }
          } else {
            // During 'ACTIVE_ON': '<S328>:3'
            if ((int32_T)rtu_i_cmd == 0) {
              // Transition: '<S328>:22'
              localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
                MX_Gtwy_Control_IN_ACTIVE_OFF;

              // Entry 'ACTIVE_OFF': '<S328>:13'
              localB->icmd_Out = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
              *rty_state_Output = INACTIVE;
            } else {
              localB->icmd_Out = rtu_i_cmd;
            }
          }
        }
      }
      break;
    }
  }

  // End of Chart: '<S306>/control'

  // Outputs for Atomic SubSystem: '<S306>/hc_pair_ClosedLoop_v5'
  MX_Gtwy_C_hc_pair_ClosedLoop_v5(localB->icmd_Out, localB->enable_LoSide,
    rtb_LogicalOperator2_d2ht, rtb_Gain_ftue, rtu_calc_Vbattery, *rty_calc_ifbk,
    rtb_ocstg_check, rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, rty_errorCC, &localB->hc_pair_ClosedLoop_v5,
    &localDW->hc_pair_ClosedLoop_v5, rtp_KP, rtp_KI, rtp_IFBK_MAX, rtp_NZ_DUTY,
    rtp_NZ_IFBK, rtp_OC_DB_CNT, rtp_OPEN_DB_CNT, rtp_OSTG_DB_CNT, rtp_STB_DB_CNT,
    rtp_STG_DB_CNT, rtp_BIDIRECTIONAL_CTRL);

  // End of Outputs for SubSystem: '<S306>/hc_pair_ClosedLoop_v5'

  // Update for UnitDelay: '<S306>/Unit Delay1'
  localDW->UnitDelay1_DSTATE = localB->oc_state;

  // Update for UnitDelay: '<S306>/Unit Delay4'
  localDW->UnitDelay4_DSTATE = localB->diag_state;
}

//
//  Output and update for atomic system:
//     '<S367>/Voltage_Limiter'
//     '<S435>/Voltage_Limiter'
//     '<S454>/Voltage_Limiter'
//     '<S565>/Voltage_Limiter'

void MX_Gtwy_Control_Voltage_Limiter(uint16_T rtu_calc_VBattery, uint16_T
  rtu_duty_in, uint16_T *rty_duty_out, uint16_T rtp_MAX_VOLTS)
{
  uint16_T rtb_Saturation_bsq0;
  uint32_T tmp;

  // Product: '<S371>/Divide' incorporates:
  //   Constant: '<S371>/FunctionState2'

  tmp = (uint32_T)rtu_calc_VBattery == 0U ? MAX_uint32_T : (uint32_T)((uint32_T)
    ((uint32_T)rtp_MAX_VOLTS << 12) / (uint32_T)rtu_calc_VBattery);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Saturation_bsq0 = (uint16_T)tmp;

  // Saturate: '<S371>/Saturation' incorporates:
  //   Product: '<S371>/Divide'

  if ((uint16_T)tmp < ((uint16_T)4096U)) {
  } else {
    rtb_Saturation_bsq0 = ((uint16_T)4096U);
  }

  // End of Saturate: '<S371>/Saturation'

  // Product: '<S371>/Divide1'
  tmp = (uint32_T)((uint32_T)((uint32_T)rtu_duty_in * (uint32_T)
    rtb_Saturation_bsq0) >> 12);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  *rty_duty_out = (uint16_T)tmp;

  // End of Product: '<S371>/Divide1'
}

//
//  System initialize for atomic system:
//     '<S364>/output_pair_open_loop'
//     '<S432>/output_pair_open_loop'
//     '<S451>/output_pair_open_loop'

void MX_Gt_output_pair_OpenLoop_Init(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_OpenLoop_MX_Gtw *localB,
  rtDW_output_pair_OpenLoop_MX_Gt *localDW)
{
  uint16_T rtb_duty_Output;
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S367>/Unit Delay2'
  localDW->UnitDelay2_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S367>/Unit Delay3'
  localDW->UnitDelay3_DSTATE = ((uint8_T)0U);

  // SystemInitialize for Atomic SubSystem: '<S367>/oc_stg_detection'
  MX_Gtwy_C_oc_stg_detection_Init(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemInitialize for SubSystem: '<S367>/oc_stg_detection'

  // SystemInitialize for Chart: '<S367>/control'
  localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_active_c51_MX_Library = 0U;
  localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  rtb_duty_Output = 0U;
  localB->enable_LoSide = false;

  // SystemInitialize for Atomic SubSystem: '<S372>/LP_Filter_Adj_Gain'
  MX_Gtwy_LP_Filter_Adj_Gain_Init(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemInitialize for SubSystem: '<S372>/LP_Filter_Adj_Gain'

  // SystemInitialize for Atomic SubSystem: '<S367>/hc_pair_OpenLoop'
  MX_Gtwy_C_hc_pair_OpenLoop_Init(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemInitialize for SubSystem: '<S367>/hc_pair_OpenLoop'
}

//
//  System reset for atomic system:
//     '<S364>/output_pair_open_loop'
//     '<S432>/output_pair_open_loop'
//     '<S451>/output_pair_open_loop'

void MX_G_output_pair_OpenLoop_Reset(uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd,
  uint8_T *rty_state_Output, rtB_output_pair_OpenLoop_MX_Gtw *localB,
  rtDW_output_pair_OpenLoop_MX_Gt *localDW)
{
  uint16_T rtb_duty_Output;
  uint8_T rtb_ocstg_check;

  // InitializeConditions for UnitDelay: '<S367>/Unit Delay2'
  localDW->UnitDelay2_DSTATE = ((uint8_T)0U);

  // InitializeConditions for UnitDelay: '<S367>/Unit Delay3'
  localDW->UnitDelay3_DSTATE = ((uint8_T)0U);

  // SystemReset for Atomic SubSystem: '<S367>/oc_stg_detection'
  MX_Gtwy__oc_stg_detection_Reset(&localB->diag_state_out, &rtb_ocstg_check,
    &localDW->oc_stg_detection);

  // End of SystemReset for SubSystem: '<S367>/oc_stg_detection'

  // SystemReset for Chart: '<S367>/control'
  localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->bitsForTID0.is_active_c51_MX_Library = 0U;
  localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
  localDW->debounceCount = 0U;
  *rty_state_Output = 0U;
  rtb_duty_Output = 0U;
  localB->enable_LoSide = false;

  // SystemReset for Atomic SubSystem: '<S372>/LP_Filter_Adj_Gain'
  MX_Gtw_LP_Filter_Adj_Gain_Reset(&localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of SystemReset for SubSystem: '<S372>/LP_Filter_Adj_Gain'

  // SystemReset for Atomic SubSystem: '<S367>/hc_pair_OpenLoop'
  MX_Gtwy__hc_pair_OpenLoop_Reset(rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_OpenLoop);

  // End of SystemReset for SubSystem: '<S367>/hc_pair_OpenLoop'
}

//
//  Output and update for atomic system:
//     '<S364>/output_pair_open_loop'
//     '<S432>/output_pair_open_loop'
//     '<S451>/output_pair_open_loop'

void MX_Gtwy_Co_output_pair_OpenLoop(boolean_T rtu_cmd_Output, boolean_T
  rtu_enable_STGOffDiag, uint8_T rtu_state_Engine, uint16_T rtu_afbk_A2D,
  uint16_T rtu_ifbk_A2D, uint8_T rtu_state_VBattery, uint16_T rtu_calc_VBattery,
  uint16_T rtu_ain_PrecRef, uint16_T *rty_hs_cmd, boolean_T *rty_ls_cmd, uint8_T
  *rty_state_Output, rtB_output_pair_OpenLoop_MX_Gtw *localB,
  rtDW_output_pair_OpenLoop_MX_Gt *localDW, uint16_T rtp_MAX_VOLTS, uint16_T
  rtp_OPEN_DB_CNT, uint16_T rtp_STG_DB_CNT, uint16_T rtp_IFBK_MAX, uint16_T
  rtp_NZ_DUTY, uint16_T rtp_NZ_IFBK, uint16_T rtp_OC_DB_CNT, uint16_T
  rtp_OSTG_DB_CNT, uint16_T rtp_STB_DB_CNT, uint8_T rtp_FEEDBACK_ENABLE,
  uint16_T rtp_AFBK_GAIN, uint16_T rtp_IFBK_GAIN)
{
  uint16_T rtb_DataTypeConversion1_ptgy;
  uint16_T rtb_duty_Output;
  uint8_T rtb_ocstg_check;
  boolean_T rtb_LogicalOperator1_kyfp;
  int16_T rtb_DataTypeConversion_cdc3;
  uint8_T rtb_oc_state;
  uint8_T rtb_diag_state;
  uint16_T rtb_Gain2;
  uint16_T rtb_Divide_if5c;
  uint16_T rtb_Divide1_hbnh;
  uint32_T tmp;

  // Gain: '<S367>/Gain2'
  tmp = (uint32_T)((uint32_T)rtp_AFBK_GAIN * (uint32_T)rtu_afbk_A2D);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Gain2 = (uint16_T)tmp;

  // End of Gain: '<S367>/Gain2'

  // Logic: '<S367>/Logical Operator1' incorporates:
  //   Constant: '<S367>/FunctionState1'
  //   Constant: '<S368>/Constant'
  //   Constant: '<S369>/Constant'
  //   Constant: '<S370>/Constant'
  //   RelationalOperator: '<S368>/Compare'
  //   RelationalOperator: '<S369>/Compare'
  //   RelationalOperator: '<S370>/Compare'

  rtb_LogicalOperator1_kyfp = ((rtp_FEEDBACK_ENABLE != NON_FUNCTIONAL) &&
    (rtu_state_VBattery != OORL) && (rtu_state_Engine != ENGINE_CRANKING));

  // UnitDelay: '<S367>/Unit Delay2'
  rtb_oc_state = localDW->UnitDelay2_DSTATE;

  // UnitDelay: '<S367>/Unit Delay3'
  rtb_diag_state = localDW->UnitDelay3_DSTATE;

  // Outputs for Atomic SubSystem: '<S367>/oc_stg_detection'
  MX_Gtwy_Contro_oc_stg_detection(rtb_oc_state, rtb_diag_state,
    &localB->diag_state_out, &rtb_ocstg_check, &localDW->oc_stg_detection,
    rtp_OPEN_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S367>/oc_stg_detection'

  // Chart: '<S367>/control'
  // Gateway: output_pair_OpenLoop/control
  // During: output_pair_OpenLoop/control
  if ((uint32_T)localDW->bitsForTID0.is_active_c51_MX_Library == 0U) {
    // Entry: output_pair_OpenLoop/control
    localDW->bitsForTID0.is_active_c51_MX_Library = 1U;

    // Entry Internal: output_pair_OpenLoop/control
    // Transition: '<S373>:28'
    localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_Cont_IN_FUNCTIONAL_blpp;

    // Entry Internal 'FUNCTIONAL': '<S373>:11'
    // Transition: '<S373>:26'
    localDW->bitsForTID0.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

    // Entry 'STGOFF_DIAG_ACTIVE': '<S373>:1'
    rtb_duty_Output = 0U;
    *rty_state_Output = INACTIVE;

    // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
    // Transition: '<S373>:37'
    localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE = MX_Gtwy_Control_IN_Test_OC_dpgv;

    // Entry 'Test_OC': '<S373>:8'
    localDW->debounceCount = 0U;
    localB->enable_LoSide = ((int32_T)ACTIVE != 0);
  } else {
    switch (localDW->bitsForTID0.is_c51_MX_Library) {
     case MX_Gtwy_Cont_IN_DIAG_CHECK_gfxy:
      rtb_duty_Output = 0U;

      // During 'DIAG_CHECK': '<S373>:4'
      // Couldn't find a fault, so go back to working
      // ?? should this condition really be recoverable??
      if (rtb_ocstg_check == RESET) {
        // Transition: '<S373>:18'
        // Exit Internal 'DIAG_CHECK': '<S373>:4'
        localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
        localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_Cont_IN_FUNCTIONAL_blpp;

        // Entry Internal 'FUNCTIONAL': '<S373>:11'
        // Transition: '<S373>:26'
        localDW->bitsForTID0.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

        // Entry 'STGOFF_DIAG_ACTIVE': '<S373>:1'
        *rty_state_Output = INACTIVE;

        // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
        // Transition: '<S373>:37'
        localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
          MX_Gtwy_Control_IN_Test_OC_dpgv;

        // Entry 'Test_OC': '<S373>:8'
        localDW->debounceCount = 0U;
        localB->enable_LoSide = ((int32_T)ACTIVE != 0);
      } else {
        // Fault Detected
        if (localB->diag_state_out != NORMAL) {
          // Transition: '<S373>:29'
          // Exit Internal 'DIAG_CHECK': '<S373>:4'
          localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
          localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_Control_IN_ERROR_jnvd;

          // Entry 'ERROR': '<S373>:12'
          localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          *rty_state_Output = localB->diag_state_out;
        } else if (localDW->bitsForTID0.is_DIAG_CHECK ==
                   MX_Gtwy_Cont_IN_ENABLE_OFF_ifnc) {
          // During 'ENABLE_OFF': '<S373>:6'
        } else {
          // During 'ENABLE_ON': '<S373>:5'
          // Give it some time to ensure low side is on
          // and detect open circuit
          if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
               rtp_OPEN_DB_CNT + 100)) {
            // Transition: '<S373>:24'
            localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_Cont_IN_ENABLE_OFF_ifnc;

            // Entry 'ENABLE_OFF': '<S373>:6'
            localB->enable_LoSide = ((int32_T)INACTIVE != 0);
          } else {
            localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
              localDW->debounceCount + 1);
          }
        }
      }
      break;

     case MX_Gtwy_Control_IN_ERROR_jnvd:
      rtb_duty_Output = 0U;

      // During 'ERROR': '<S373>:12'
      if (localB->diag_state_out == NORMAL) {
        // Transition: '<S373>:127'
        localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_Cont_IN_FUNCTIONAL_blpp;

        // Entry Internal 'FUNCTIONAL': '<S373>:11'
        // Transition: '<S373>:26'
        localDW->bitsForTID0.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

        // Entry 'STGOFF_DIAG_ACTIVE': '<S373>:1'
        *rty_state_Output = INACTIVE;

        // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
        // Transition: '<S373>:37'
        localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
          MX_Gtwy_Control_IN_Test_OC_dpgv;

        // Entry 'Test_OC': '<S373>:8'
        localDW->debounceCount = 0U;
        localB->enable_LoSide = ((int32_T)ACTIVE != 0);
      }
      break;

     default:
      // During 'FUNCTIONAL': '<S373>:11'
      // Fault Detected
      if (localB->diag_state_out != NORMAL) {
        // Transition: '<S373>:30'
        // Exit Internal 'FUNCTIONAL': '<S373>:11'
        // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
        localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
        localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;

        // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S373>:2'
        localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
        localDW->bitsForTID0.is_c51_MX_Library = MX_Gtwy_Control_IN_ERROR_jnvd;

        // Entry 'ERROR': '<S373>:12'
        rtb_duty_Output = 0U;
        localB->enable_LoSide = ((int32_T)INACTIVE != 0);
        *rty_state_Output = localB->diag_state_out;
      } else {
        // Open or STG Fault detected
        // while output is on
        if (rtb_ocstg_check == ACTIVE) {
          // Transition: '<S373>:25'
          // Exit Internal 'FUNCTIONAL': '<S373>:11'
          // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
          localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
          localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;

          // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S373>:2'
          localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
          localDW->bitsForTID0.is_c51_MX_Library =
            MX_Gtwy_Cont_IN_DIAG_CHECK_gfxy;

          // Entry 'DIAG_CHECK': '<S373>:4'
          rtb_duty_Output = 0U;

          // Entry Internal 'DIAG_CHECK': '<S373>:4'
          // Transition: '<S373>:23'
          localDW->bitsForTID0.is_DIAG_CHECK = MX_Gtwy_Contr_IN_ENABLE_ON_p4th;

          // Entry 'ENABLE_ON': '<S373>:5'
          localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          localDW->debounceCount = 0U;
        } else if (localDW->bitsForTID0.is_FUNCTIONAL ==
                   MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz) {
          rtb_duty_Output = 0U;

          // During 'STGOFF_DIAG_ACTIVE': '<S373>:1'
          if (!rtu_enable_STGOffDiag) {
            // Transition: '<S373>:19'
            // Exit Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
            localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
            localDW->bitsForTID0.is_FUNCTIONAL = MX_IN_STGOFF_DIAG_INACTIVE_o1ij;

            // Entry 'STGOFF_DIAG_INACTIVE': '<S373>:2'
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);

            // Entry Internal 'STGOFF_DIAG_INACTIVE': '<S373>:2'
            // Transition: '<S373>:21'
            localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
              MX_Gtwy_Cont_IN_ACTIVE_OFF_o5z1;

            // Entry 'ACTIVE_OFF': '<S373>:13'
            *rty_state_Output = INACTIVE;
          } else if (localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE ==
                     MX_Gtwy_Control_IN_Test_OC_dpgv) {
            // During 'Test_OC': '<S373>:8'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_OPEN_DB_CNT + 100)) {
              // Transition: '<S373>:36'
              localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
                MX_Gtwy_Contro_IN_Test_STG_a1mc;

              // Entry 'Test_STG': '<S373>:9'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)INACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          } else {
            // During 'Test_STG': '<S373>:9'
            if ((int32_T)localDW->debounceCount >= (int32_T)((int32_T)
                 rtp_STG_DB_CNT + 100)) {
              // Transition: '<S373>:35'
              localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
                MX_Gtwy_Control_IN_Test_OC_dpgv;

              // Entry 'Test_OC': '<S373>:8'
              localDW->debounceCount = 0U;
              localB->enable_LoSide = ((int32_T)ACTIVE != 0);
            } else {
              localDW->debounceCount = (uint16_T)(int32_T)((int32_T)
                localDW->debounceCount + 1);
            }
          }
        } else {
          // During 'STGOFF_DIAG_INACTIVE': '<S373>:2'
          if (rtu_enable_STGOffDiag) {
            // Transition: '<S373>:20'
            // Exit Internal 'STGOFF_DIAG_INACTIVE': '<S373>:2'
            localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_eulg;
            localDW->bitsForTID0.is_FUNCTIONAL = MX_G_IN_STGOFF_DIAG_ACTIVE_hsaz;

            // Entry 'STGOFF_DIAG_ACTIVE': '<S373>:1'
            rtb_duty_Output = 0U;
            *rty_state_Output = INACTIVE;

            // Entry Internal 'STGOFF_DIAG_ACTIVE': '<S373>:1'
            // Transition: '<S373>:37'
            localDW->bitsForTID0.is_STGOFF_DIAG_ACTIVE =
              MX_Gtwy_Control_IN_Test_OC_dpgv;

            // Entry 'Test_OC': '<S373>:8'
            localDW->debounceCount = 0U;
            localB->enable_LoSide = ((int32_T)ACTIVE != 0);
          } else if (localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE ==
                     MX_Gtwy_Cont_IN_ACTIVE_OFF_o5z1) {
            rtb_duty_Output = 0U;

            // During 'ACTIVE_OFF': '<S373>:13'
            if (rtu_cmd_Output == (int32_T)ACTIVE) {
              // Transition: '<S373>:50'
              localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
                MX_Gtwy_Contr_IN_ACTIVE_ON_aqdk;

              // Entry 'ACTIVE_ON': '<S373>:3'
              rtb_duty_Output = FULL_ON;
              *rty_state_Output = ACTIVE;
            }
          } else {
            rtb_duty_Output = FULL_ON;

            // During 'ACTIVE_ON': '<S373>:3'
            if (rtu_cmd_Output != (int32_T)ACTIVE) {
              // Transition: '<S373>:22'
              localDW->bitsForTID0.is_STGOFF_DIAG_INACTIVE =
                MX_Gtwy_Cont_IN_ACTIVE_OFF_o5z1;

              // Entry 'ACTIVE_OFF': '<S373>:13'
              rtb_duty_Output = 0U;
              *rty_state_Output = INACTIVE;
            }
          }
        }
      }
      break;
    }
  }

  // End of Chart: '<S367>/control'

  // Outputs for Atomic SubSystem: '<S367>/Voltage_Limiter'
  MX_Gtwy_Control_Voltage_Limiter(rtu_calc_VBattery, rtb_duty_Output,
    &rtb_Divide1_hbnh, rtp_MAX_VOLTS);

  // End of Outputs for SubSystem: '<S367>/Voltage_Limiter'

  // DataTypeConversion: '<S372>/Data Type Conversion'
  rtb_DataTypeConversion_cdc3 = (int16_T)rtu_ain_PrecRef;

  // Outputs for Atomic SubSystem: '<S372>/LP_Filter_Adj_Gain'

  // Constant: '<S372>/Constant'
  MX_Gtwy_Cont_LP_Filter_Adj_Gain(((uint8_T)6U), rtb_DataTypeConversion_cdc3,
    &localB->Output, &localDW->LP_Filter_Adj_Gain);

  // End of Outputs for SubSystem: '<S372>/LP_Filter_Adj_Gain'

  // DataTypeConversion: '<S372>/Data Type Conversion1'
  rtb_DataTypeConversion1_ptgy = (uint16_T)(int32_T)(localB->Output >> 16);

  // Switch: '<S372>/Switch' incorporates:
  //   Constant: '<S372>/Constant1'
  //   Constant: '<S376>/Lower Limit'
  //   Constant: '<S376>/Upper Limit'
  //   Logic: '<S376>/AND'
  //   RelationalOperator: '<S376>/Lower Test'
  //   RelationalOperator: '<S376>/Upper Test'

  if ((((uint16_T)465U) < rtb_DataTypeConversion1_ptgy) &&
      (rtb_DataTypeConversion1_ptgy < ((uint16_T)569U))) {
  } else {
    rtb_DataTypeConversion1_ptgy = CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE;
  }

  // End of Switch: '<S372>/Switch'

  // Gain: '<S367>/Gain3'
  tmp = (uint32_T)((uint32_T)((uint32_T)rtp_IFBK_GAIN * (uint32_T)rtu_ifbk_A2D) >>
                   4);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  // Product: '<S372>/Divide' incorporates:
  //   Constant: '<S372>/Constant1'
  //   Gain: '<S367>/Gain3'
  //   Product: '<S372>/Divide1'

  rtb_Divide_if5c = (uint16_T)(uint32_T)((uint32_T)(tmp * (uint32_T)(uint16_T)
    ((uint32_T)rtb_DataTypeConversion1_ptgy == 0U ? MAX_uint32_T : (uint32_T)
     ((uint32_T)((uint32_T)CONSTANT_DATA->PRECISION_REF_NOMINAL_VALUE << 15) /
      (uint32_T)rtb_DataTypeConversion1_ptgy))) >> 15);

  // Outputs for Atomic SubSystem: '<S367>/hc_pair_OpenLoop'
  MX_Gtwy_Contro_hc_pair_OpenLoop(rtb_Divide1_hbnh, localB->enable_LoSide,
    rtb_LogicalOperator1_kyfp, rtb_Gain2, rtu_calc_VBattery, rtb_Divide_if5c,
    rtb_ocstg_check, rty_hs_cmd, rty_ls_cmd, &localB->oc_state,
    &localB->diag_state, &localDW->hc_pair_OpenLoop, rtp_IFBK_MAX, rtp_NZ_DUTY,
    rtp_NZ_IFBK, rtp_OC_DB_CNT, rtp_OPEN_DB_CNT, rtp_OSTG_DB_CNT, rtp_STB_DB_CNT,
    rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S367>/hc_pair_OpenLoop'

  // Update for UnitDelay: '<S367>/Unit Delay2'
  localDW->UnitDelay2_DSTATE = localB->oc_state;

  // Update for UnitDelay: '<S367>/Unit Delay3'
  localDW->UnitDelay3_DSTATE = localB->diag_state;
}

//
//  System initialize for enable system:
//     '<S405>/relay_oc'
//     '<S288>/relay_oc'
//     '<S292>/relay_oc'
//     '<S294>/relay_oc'
//     '<S295>/relay_oc'
//     '<S297>/relay_oc'

void MX_Gtwy_Control_relay_oc_Init(uint8_T *rty_state_Output, uint8_T
  *rty_state_Relay, rtB_relay_oc_MX_Gtwy_Control *localB,
  rtDW_relay_oc_MX_Gtwy_Control *localDW)
{
  // SystemInitialize for Chart: '<S410>/relay_error_state'
  localDW->bitsForTID0.is_STATE_OUTPUT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_ERROR_OFF_cild = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_ERROR_ON_lmya = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_FAILURE = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_NORMAL_food = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_STATE_RELAY = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_RELAY = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_ERROR_OFF = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_ERROR_ON = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_NORMAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
  localDW->bitsForTID0.is_active_c3_MX_Library = 0U;
  localDW->debounceOutput = 0U;
  localDW->debounceRelay = 0U;
  localB->state_Relay = 0U;
  localB->state_Output = 0U;

  // SystemInitialize for Outport: '<S410>/state_Output'
  *rty_state_Output = ((uint8_T)8U);

  // SystemInitialize for Outport: '<S410>/state_Relay'
  *rty_state_Relay = ((uint8_T)8U);
}

//
//  Disable for enable system:
//     '<S405>/relay_oc'
//     '<S288>/relay_oc'
//     '<S292>/relay_oc'
//     '<S294>/relay_oc'
//     '<S295>/relay_oc'
//     '<S297>/relay_oc'

void MX_Gtwy_Contro_relay_oc_Disable(uint8_T *rty_state_Output, uint8_T
  *rty_state_Relay, rtDW_relay_oc_MX_Gtwy_Control *localDW)
{
  // Outputs for Enabled SubSystem: '<S405>/relay_oc' incorporates:
  //   EnablePort: '<S410>/Enable'

  // Disable for Outport: '<S410>/state_Output'
  *rty_state_Output = ((uint8_T)8U);

  // Disable for Outport: '<S410>/state_Relay'
  *rty_state_Relay = ((uint8_T)8U);

  // End of Outputs for SubSystem: '<S405>/relay_oc'
  localDW->relay_oc_MODE = false;
}

//
//  Output and update for enable system:
//     '<S405>/relay_oc'
//     '<S288>/relay_oc'
//     '<S292>/relay_oc'
//     '<S294>/relay_oc'
//     '<S295>/relay_oc'
//     '<S297>/relay_oc'

void MX_Gtwy_Control_relay_oc(boolean_T rtu_Enable, boolean_T rtu_cmd, boolean_T
  rtu_dfbk, boolean_T rtu_din, uint8_T *rty_state_Output, uint8_T
  *rty_state_Relay, rtB_relay_oc_MX_Gtwy_Control *localB,
  rtDW_relay_oc_MX_Gtwy_Control *localDW, uint16_T rtp_ERROR_OFF_DB_CNT,
  uint16_T rtp_ERROR_ON_DB_CNT, uint16_T rtp_NORMAL_DB_CNT)
{
  // Outputs for Enabled SubSystem: '<S405>/relay_oc' incorporates:
  //   EnablePort: '<S410>/Enable'

  if (rtu_Enable) {
    if (!localDW->relay_oc_MODE) {
      localDW->relay_oc_MODE = true;
    }

    // Chart: '<S410>/relay_error_state'
    // Gateway: relay_oc/relay_error_state
    // During: relay_oc/relay_error_state
    if ((uint32_T)localDW->bitsForTID0.is_active_c3_MX_Library == 0U) {
      // Entry: relay_oc/relay_error_state
      localDW->bitsForTID0.is_active_c3_MX_Library = 1U;

      // Entry Internal: relay_oc/relay_error_state
      // Entry Internal 'STATE_OUTPUT': '<S411>:30'
      // Transition: '<S411>:121'
      localDW->bitsForTID0.is_STATE_OUTPUT = MX_Gtwy_Control_IN_OUTPUT;

      // Entry Internal 'OUTPUT': '<S411>:82'
      // Transition: '<S411>:31'
      localB->state_Output = NORMAL;
      localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_NORMAL_pqen;

      // Entry Internal 'NORMAL': '<S411>:36'
      // Transition: '<S411>:49'
      localDW->bitsForTID0.is_NORMAL_food = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

      // Entry 'DEBOUNCE': '<S411>:48'
      localDW->debounceOutput = 0U;

      // Entry Internal 'STATE_RELAY': '<S411>:124'
      // Transition: '<S411>:125'
      localDW->bitsForTID0.is_STATE_RELAY = MX_Gtwy_Control_IN_RELAY;

      // Entry Internal 'RELAY': '<S411>:128'
      // Transition: '<S411>:131'
      localB->state_Relay = NORMAL;
      localDW->bitsForTID0.is_RELAY = MX_Gtwy_Control_IN_NORMAL_pqenz;

      // Entry Internal 'NORMAL': '<S411>:148'
      // Transition: '<S411>:149'
      localDW->bitsForTID0.is_NORMAL = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

      // Entry 'DEBOUNCE': '<S411>:151'
      localDW->debounceRelay = 0U;
    } else {
      // During 'STATE_OUTPUT': '<S411>:30'
      if (localDW->bitsForTID0.is_STATE_OUTPUT == MX_Gtwy_Control_IN_OUTPUT) {
        // During 'OUTPUT': '<S411>:82'
        if ((localB->state_Relay != NORMAL) && (localB->state_Output == NORMAL))
        {
          // Transition: '<S411>:120'
          // Exit Internal 'OUTPUT': '<S411>:82'
          // Exit Internal 'ERROR_OFF': '<S411>:52'
          localDW->bitsForTID0.is_ERROR_OFF_cild =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'ERROR_ON': '<S411>:42'
          localDW->bitsForTID0.is_ERROR_ON_lmya =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'FAILURE': '<S411>:64'
          localDW->bitsForTID0.is_FAILURE = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'NORMAL': '<S411>:36'
          localDW->bitsForTID0.is_NORMAL_food = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'OPEN_CIRCUIT': '<S411>:57'
          localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID0.is_STATE_OUTPUT = MX_Gtwy_Control_IN_RELAY;
        } else {
          switch (localDW->bitsForTID0.is_OUTPUT) {
           case MX_Gtwy_Control_IN_ERROR_OFF:
            // During 'ERROR_OFF': '<S411>:52'
            if (((!rtu_cmd) || rtu_dfbk || rtu_din) && ((localB->state_Output ==
                  NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S411>:76'
              // Exit Internal 'ERROR_OFF': '<S411>:52'
              localDW->bitsForTID0.is_ERROR_OFF_cild =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S411>:36'
              // Transition: '<S411>:49'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID0.is_ERROR_OFF_cild ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:55'
              if ((localDW->debounceOutput >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Output == ERROR_OFF)) {
                // Transition: '<S411>:54'
                localDW->bitsForTID0.is_ERROR_OFF_cild =
                  MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:56'
                localB->state_Output = ERROR_OFF;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S411>:56'
            }
            break;

           case MX_Gtwy_Control_IN_ERROR_ON:
            // During 'ERROR_ON': '<S411>:42'
            if ((rtu_cmd || (!rtu_dfbk) || (!rtu_din)) && ((localB->state_Output
                  == NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S411>:71'
              // Exit Internal 'ERROR_ON': '<S411>:42'
              localDW->bitsForTID0.is_ERROR_ON_lmya =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S411>:36'
              // Transition: '<S411>:49'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID0.is_ERROR_ON_lmya ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:43'
              if ((localDW->debounceOutput >= rtp_ERROR_ON_DB_CNT) ||
                  (localB->state_Output == ERROR_ON)) {
                // Transition: '<S411>:46'
                localDW->bitsForTID0.is_ERROR_ON_lmya =
                  MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:45'
                localB->state_Output = ERROR_ON;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S411>:45'
            }
            break;

           case MX_Gtwy_Control_IN_FAILURE:
            // During 'FAILURE': '<S411>:64'
            if (((!rtu_cmd) || rtu_dfbk || (!rtu_din)) && ((localB->state_Output
                  == NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S411>:73'
              // Exit Internal 'FAILURE': '<S411>:64'
              localDW->bitsForTID0.is_FAILURE = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S411>:36'
              // Transition: '<S411>:49'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID0.is_FAILURE ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:67'
              if ((localDW->debounceOutput >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Output == FAILURE)) {
                // Transition: '<S411>:66'
                localDW->bitsForTID0.is_FAILURE = MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:68'
                localB->state_Output = FAILURE;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S411>:68'
            }
            break;

           case MX_Gtwy_Control_IN_NORMAL_pqen:
            // During 'NORMAL': '<S411>:36'
            if ((!rtu_cmd) && rtu_dfbk && rtu_din) {
              // Transition: '<S411>:70'
              // Exit Internal 'NORMAL': '<S411>:36'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_ERROR_ON;

              // Entry Internal 'ERROR_ON': '<S411>:42'
              // Transition: '<S411>:44'
              localDW->bitsForTID0.is_ERROR_ON_lmya =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:43'
              localDW->debounceOutput = 0U;
            } else if (rtu_cmd && (!rtu_dfbk) && rtu_din) {
              // Transition: '<S411>:72'
              // Exit Internal 'NORMAL': '<S411>:36'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_FAILURE;

              // Entry Internal 'FAILURE': '<S411>:64'
              // Transition: '<S411>:65'
              localDW->bitsForTID0.is_FAILURE = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:67'
              localDW->debounceOutput = 0U;
            } else if (rtu_cmd && (!rtu_dfbk)) {
              // Transition: '<S411>:75'
              // && !(din) for coverage
              // Exit Internal 'NORMAL': '<S411>:36'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_ERROR_OFF;

              // Entry Internal 'ERROR_OFF': '<S411>:52'
              // Transition: '<S411>:53'
              localDW->bitsForTID0.is_ERROR_OFF_cild =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:55'
              localDW->debounceOutput = 0U;
            } else if ((!rtu_cmd) && rtu_dfbk) {
              // Transition: '<S411>:77'
              // && !(din) for coverage
              // Exit Internal 'NORMAL': '<S411>:36'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Co_IN_OPEN_CIRCUIT_pa2m;

              // Entry Internal 'OPEN_CIRCUIT': '<S411>:57'
              // Transition: '<S411>:58'
              localDW->bitsForTID0.is_OPEN_CIRCUIT =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:60'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID0.is_NORMAL_food ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:48'
              if ((localDW->debounceOutput >= rtp_NORMAL_DB_CNT) ||
                  (localB->state_Output == NORMAL)) {
                // Transition: '<S411>:51'
                localDW->bitsForTID0.is_NORMAL_food =
                  MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:50'
                localB->state_Output = NORMAL;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S411>:50'
            }
            break;

           default:
            // During 'OPEN_CIRCUIT': '<S411>:57'
            if ((rtu_cmd || (!rtu_dfbk) || rtu_din) && ((localB->state_Output ==
                  NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S411>:78'
              // Exit Internal 'OPEN_CIRCUIT': '<S411>:57'
              localDW->bitsForTID0.is_OPEN_CIRCUIT =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_NORMAL_pqen;

              // Entry Internal 'NORMAL': '<S411>:36'
              // Transition: '<S411>:49'
              localDW->bitsForTID0.is_NORMAL_food =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:48'
              localDW->debounceOutput = 0U;
            } else if (localDW->bitsForTID0.is_OPEN_CIRCUIT ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:60'
              if ((localDW->debounceOutput >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Output == OPEN_CIRCUIT)) {
                // Transition: '<S411>:59'
                localDW->bitsForTID0.is_OPEN_CIRCUIT =
                  MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:61'
                localB->state_Output = OPEN_CIRCUIT;
              } else {
                localDW->debounceOutput = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceOutput + 1);
              }
            } else {
              // During 'FAULT': '<S411>:61'
            }
            break;
          }
        }
      } else {
        // During 'RELAY': '<S411>:119'
        if (localB->state_Relay == NORMAL) {
          // Transition: '<S411>:122'
          localDW->bitsForTID0.is_STATE_OUTPUT = MX_Gtwy_Control_IN_OUTPUT;

          // Entry Internal 'OUTPUT': '<S411>:82'
          // Transition: '<S411>:31'
          localB->state_Output = NORMAL;
          localDW->bitsForTID0.is_OUTPUT = MX_Gtwy_Control_IN_NORMAL_pqen;

          // Entry Internal 'NORMAL': '<S411>:36'
          // Transition: '<S411>:49'
          localDW->bitsForTID0.is_NORMAL_food = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

          // Entry 'DEBOUNCE': '<S411>:48'
          localDW->debounceOutput = 0U;
        }
      }

      // During 'STATE_RELAY': '<S411>:124'
      if (localDW->bitsForTID0.is_STATE_RELAY == MX_Gtwy_Control_IN_OUTPUT) {
        // During 'OUTPUT': '<S411>:163'
        if ((localB->state_Output == NORMAL) || (localB->state_Output == FAILURE))
        {
          // Transition: '<S411>:127'
          localDW->bitsForTID0.is_STATE_RELAY = MX_Gtwy_Control_IN_RELAY;

          // Entry Internal 'RELAY': '<S411>:128'
          // Transition: '<S411>:131'
          localB->state_Relay = NORMAL;
          localDW->bitsForTID0.is_RELAY = MX_Gtwy_Control_IN_NORMAL_pqenz;

          // Entry Internal 'NORMAL': '<S411>:148'
          // Transition: '<S411>:149'
          localDW->bitsForTID0.is_NORMAL = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

          // Entry 'DEBOUNCE': '<S411>:151'
          localDW->debounceRelay = 0U;
        }
      } else {
        // During 'RELAY': '<S411>:128'
        if ((localB->state_Output != NORMAL) && (localB->state_Output != FAILURE)
            && (localB->state_Relay == NORMAL)) {
          // Transition: '<S411>:126'
          // Exit Internal 'RELAY': '<S411>:128'
          // Exit Internal 'ERROR_OFF': '<S411>:158'
          localDW->bitsForTID0.is_ERROR_OFF = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID0.is_RELAY = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'ERROR_ON': '<S411>:138'
          localDW->bitsForTID0.is_ERROR_ON = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;

          // Exit Internal 'NORMAL': '<S411>:148'
          localDW->bitsForTID0.is_NORMAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
          localDW->bitsForTID0.is_STATE_RELAY = MX_Gtwy_Control_IN_OUTPUT;
        } else {
          switch (localDW->bitsForTID0.is_RELAY) {
           case MX_Gtwy_Control_IN_ERROR_OFF:
            // During 'ERROR_OFF': '<S411>:158'
            if (((!rtu_cmd) || ((!rtu_dfbk) && (localB->state_Output != FAILURE))
                 || rtu_din) && ((localB->state_Relay == NORMAL) ||
                                 (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S411>:136'
              // Exit Internal 'ERROR_OFF': '<S411>:158'
              localDW->bitsForTID0.is_ERROR_OFF =
                MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_RELAY = MX_Gtwy_Control_IN_NORMAL_pqenz;

              // Entry Internal 'NORMAL': '<S411>:148'
              // Transition: '<S411>:149'
              localDW->bitsForTID0.is_NORMAL = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:151'
              localDW->debounceRelay = 0U;
            } else if (localDW->bitsForTID0.is_ERROR_OFF ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:161'
              if ((localDW->debounceRelay >= rtp_ERROR_OFF_DB_CNT) ||
                  (localB->state_Relay == ERROR_OFF)) {
                // Transition: '<S411>:160'
                localDW->bitsForTID0.is_ERROR_OFF =
                  MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:162'
                localB->state_Relay = ERROR_OFF;
              } else {
                localDW->debounceRelay = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceRelay + 1);
              }
            } else {
              // During 'FAULT': '<S411>:162'
            }
            break;

           case MX_Gtwy_Control_IN_ERROR_ON:
            // During 'ERROR_ON': '<S411>:138'
            if ((rtu_cmd || rtu_dfbk || (!rtu_din)) && ((localB->state_Relay ==
                  NORMAL) || (rtp_NORMAL_DB_CNT != UNLIMITED))) {
              // Transition: '<S411>:130'
              // Exit Internal 'ERROR_ON': '<S411>:138'
              localDW->bitsForTID0.is_ERROR_ON = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_RELAY = MX_Gtwy_Control_IN_NORMAL_pqenz;

              // Entry Internal 'NORMAL': '<S411>:148'
              // Transition: '<S411>:149'
              localDW->bitsForTID0.is_NORMAL = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:151'
              localDW->debounceRelay = 0U;
            } else if (localDW->bitsForTID0.is_ERROR_ON ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:141'
              if ((localDW->debounceRelay >= rtp_ERROR_ON_DB_CNT) ||
                  (localB->state_Relay == ERROR_ON)) {
                // Transition: '<S411>:140'
                localDW->bitsForTID0.is_ERROR_ON = MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:142'
                localB->state_Relay = ERROR_ON;
              } else {
                localDW->debounceRelay = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceRelay + 1);
              }
            } else {
              // During 'FAULT': '<S411>:142'
            }
            break;

           default:
            // During 'NORMAL': '<S411>:148'
            if ((!rtu_cmd) && (!rtu_dfbk) && rtu_din) {
              // Transition: '<S411>:129'
              // Exit Internal 'NORMAL': '<S411>:148'
              localDW->bitsForTID0.is_NORMAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_RELAY = MX_Gtwy_Control_IN_ERROR_ON;

              // Entry Internal 'ERROR_ON': '<S411>:138'
              // Transition: '<S411>:139'
              localDW->bitsForTID0.is_ERROR_ON = MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:141'
              localDW->debounceRelay = 0U;
            } else if (rtu_cmd && (rtu_dfbk || (localB->state_Output == FAILURE))
                       && (!rtu_din)) {
              // Transition: '<S411>:137'
              // Exit Internal 'NORMAL': '<S411>:148'
              localDW->bitsForTID0.is_NORMAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_bpan;
              localDW->bitsForTID0.is_RELAY = MX_Gtwy_Control_IN_ERROR_OFF;

              // Entry Internal 'ERROR_OFF': '<S411>:158'
              // Transition: '<S411>:159'
              localDW->bitsForTID0.is_ERROR_OFF =
                MX_Gtwy_Contro_IN_DEBOUNCE_mmz1;

              // Entry 'DEBOUNCE': '<S411>:161'
              localDW->debounceRelay = 0U;
            } else if (localDW->bitsForTID0.is_NORMAL ==
                       MX_Gtwy_Contro_IN_DEBOUNCE_mmz1) {
              // During 'DEBOUNCE': '<S411>:151'
              if ((localDW->debounceRelay >= rtp_NORMAL_DB_CNT) ||
                  (localB->state_Relay == NORMAL)) {
                // Transition: '<S411>:150'
                localDW->bitsForTID0.is_NORMAL = MX_Gtwy_Control_IN_FAULT_pyte;

                // Entry 'FAULT': '<S411>:152'
                localB->state_Relay = NORMAL;
              } else {
                localDW->debounceRelay = (uint16_T)(int32_T)((int32_T)
                  localDW->debounceRelay + 1);
              }
            } else {
              // During 'FAULT': '<S411>:152'
            }
            break;
          }
        }
      }
    }

    // End of Chart: '<S410>/relay_error_state'

    // SignalConversion: '<S410>/OutportBufferForstate_Output'
    *rty_state_Output = localB->state_Output;

    // SignalConversion: '<S410>/OutportBufferForstate_Relay'
    *rty_state_Relay = localB->state_Relay;
  } else {
    if (localDW->relay_oc_MODE) {
      MX_Gtwy_Contro_relay_oc_Disable(rty_state_Output, rty_state_Relay, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S405>/relay_oc'
}

//
//  System initialize for enable system:
//     '<S286>/hc_hsd'
//     '<S565>/hc_hsd'

void MX_Gtwy_Control_hc_hsd_Init(uint8_T *rty_state, rtB_hc_hsd_MX_Gtwy_Control *
  localB, rtDW_hc_hsd_MX_Gtwy_Control *localDW)
{
  // SystemInitialize for Chart: '<S421>/Fault monitor'
  localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID0.is_SHORT_TO_BATTERY = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID0.is_SHORT_TO_GROUND = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID0.is_active_c4_MX_Library = 0U;
  localDW->bitsForTID0.is_c4_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->db_cnt = 0U;
  localB->state = 0U;

  // SystemInitialize for Outport: '<S421>/state'
  *rty_state = ((uint8_T)8U);
}

//
//  System reset for enable system:
//     '<S286>/hc_hsd'
//     '<S565>/hc_hsd'

void MX_Gtwy_Control_hc_hsd_Reset(rtB_hc_hsd_MX_Gtwy_Control *localB,
  rtDW_hc_hsd_MX_Gtwy_Control *localDW)
{
  // SystemReset for Chart: '<S421>/Fault monitor'
  localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID0.is_SHORT_TO_BATTERY = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID0.is_SHORT_TO_GROUND = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->bitsForTID0.is_active_c4_MX_Library = 0U;
  localDW->bitsForTID0.is_c4_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
  localDW->db_cnt = 0U;
  localB->state = 0U;
}

//
//  Disable for enable system:
//     '<S286>/hc_hsd'
//     '<S565>/hc_hsd'

void MX_Gtwy_Control_hc_hsd_Disable(uint8_T *rty_state,
  rtDW_hc_hsd_MX_Gtwy_Control *localDW)
{
  // Outputs for Enabled SubSystem: '<S286>/hc_hsd' incorporates:
  //   EnablePort: '<S421>/Enable'

  // Disable for Outport: '<S421>/state'
  *rty_state = ((uint8_T)8U);

  // End of Outputs for SubSystem: '<S286>/hc_hsd'
  localDW->hc_hsd_MODE = false;
}

//
//  Output and update for enable system:
//     '<S286>/hc_hsd'
//     '<S565>/hc_hsd'

void MX_Gtwy_Control_hc_hsd(boolean_T rtu_Enable, uint16_T rtu_duty, uint16_T
  rtu_afbk, uint16_T rtu_Vbatt, uint8_T *rty_state, rtB_hc_hsd_MX_Gtwy_Control
  *localB, rtDW_hc_hsd_MX_Gtwy_Control *localDW, uint16_T rtp_OPEN_DB_CNT,
  uint16_T rtp_STB_DB_CNT, uint16_T rtp_STG_DB_CNT)
{
  int16_T rtb_afbk_ratio;

  // Outputs for Enabled SubSystem: '<S286>/hc_hsd' incorporates:
  //   EnablePort: '<S421>/Enable'

  if (rtu_Enable) {
    if (!localDW->hc_hsd_MODE) {
      MX_Gtwy_Control_hc_hsd_Reset(localB, localDW);
      localDW->hc_hsd_MODE = true;
    }

    // Product: '<S421>/Divide'
    rtb_afbk_ratio = div_s16u32((uint32_T)((uint32_T)rtu_afbk << 8), (uint32_T)
      rtu_Vbatt);

    // Chart: '<S421>/Fault monitor'
    // Gateway: hc_hsd/Fault monitor
    // During: hc_hsd/Fault monitor
    if ((uint32_T)localDW->bitsForTID0.is_active_c4_MX_Library == 0U) {
      // Entry: hc_hsd/Fault monitor
      localDW->bitsForTID0.is_active_c4_MX_Library = 1U;

      // Entry Internal: hc_hsd/Fault monitor
      // Transition: '<S422>:155'
      localDW->bitsForTID0.is_c4_MX_Library = MX_Gtwy_Control_IN_NORMAL_l0jr;

      // Entry 'NORMAL': '<S422>:145'
      localDW->db_cnt = (uint16_T)INACTIVE;
      localB->state = NORMAL;
    } else {
      switch (localDW->bitsForTID0.is_c4_MX_Library) {
       case MX_Gtwy_Control_IN_NORMAL_l0jr:
        localB->state = NORMAL;

        // During 'NORMAL': '<S422>:145'
        if (((uint32_T)rtu_duty == (uint32_T)((uint32_T)INACTIVE << 16)) &&
            ((int32_T)rtb_afbk_ratio > 205) && (rtp_STB_DB_CNT != UNLIMITED)) {
          // Transition: '<S422>:149'
          localDW->bitsForTID0.is_c4_MX_Library =
            MX_Gtw_IN_SHORT_TO_BATTERY_mp5u;

          // Entry Internal 'SHORT_TO_BATTERY': '<S422>:146'
          // Transition: '<S422>:158'
          localDW->bitsForTID0.is_SHORT_TO_BATTERY =
            MX_Gtwy_Contro_IN_DEBOUNCE_mxcs;

          // Entry 'DEBOUNCE': '<S422>:156'
          localDW->db_cnt = 0U;
        } else if (((int32_T)rtu_duty == 0) && ((int32_T)rtb_afbk_ratio > 64) &&
                   ((int32_T)rtb_afbk_ratio < 192) && (rtp_OPEN_DB_CNT !=
                    UNLIMITED)) {
          // Transition: '<S422>:151'
          localDW->bitsForTID0.is_c4_MX_Library =
            MX_Gtwy_Co_IN_OPEN_CIRCUIT_iupo;

          // Entry Internal 'OPEN_CIRCUIT': '<S422>:148'
          // Transition: '<S422>:162'
          localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_Contro_IN_DEBOUNCE_mxcs;

          // Entry 'DEBOUNCE': '<S422>:161'
          localDW->db_cnt = 0U;
        } else {
          if (((int32_T)rtu_duty >= 64225) && ((int32_T)rtb_afbk_ratio < 51) &&
              (rtp_STG_DB_CNT != UNLIMITED)) {
            // Transition: '<S422>:153'
            localDW->bitsForTID0.is_c4_MX_Library =
              MX_Gtwy_IN_SHORT_TO_GROUND_e2rb;

            // Entry Internal 'SHORT_TO_GROUND': '<S422>:147'
            // Transition: '<S422>:166'
            localDW->bitsForTID0.is_SHORT_TO_GROUND =
              MX_Gtwy_Contro_IN_DEBOUNCE_mxcs;

            // Entry 'DEBOUNCE': '<S422>:165'
            localDW->db_cnt = 0U;
          }
        }
        break;

       case MX_Gtwy_Co_IN_OPEN_CIRCUIT_iupo:
        // During 'OPEN_CIRCUIT': '<S422>:148'
        if ((localB->state == NORMAL) && (((uint32_T)rtu_duty != (uint32_T)
              ((uint32_T)INACTIVE << 16)) || ((int32_T)rtb_afbk_ratio <= 64) ||
             ((int32_T)rtb_afbk_ratio >= 192))) {
          // Transition: '<S422>:152'
          // Exit Internal 'OPEN_CIRCUIT': '<S422>:148'
          localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
          localDW->bitsForTID0.is_c4_MX_Library = MX_Gtwy_Control_IN_NORMAL_l0jr;

          // Entry 'NORMAL': '<S422>:145'
          localDW->db_cnt = (uint16_T)INACTIVE;
          localB->state = NORMAL;
        } else if (localDW->bitsForTID0.is_OPEN_CIRCUIT ==
                   MX_Gtwy_Contro_IN_DEBOUNCE_mxcs) {
          // During 'DEBOUNCE': '<S422>:161'
          if (localDW->db_cnt >= rtp_OPEN_DB_CNT) {
            // Transition: '<S422>:164'
            localDW->bitsForTID0.is_OPEN_CIRCUIT = MX_Gtwy_Control_IN_FAULT_k5qe;

            // Entry 'FAULT': '<S422>:163'
            localB->state = OPEN_CIRCUIT;
          } else {
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          }
        } else {
          localB->state = OPEN_CIRCUIT;

          // During 'FAULT': '<S422>:163'
        }
        break;

       case MX_Gtw_IN_SHORT_TO_BATTERY_mp5u:
        // During 'SHORT_TO_BATTERY': '<S422>:146'
        if ((localB->state == NORMAL) && (((uint32_T)rtu_duty != (uint32_T)
              ((uint32_T)INACTIVE << 16)) || ((int32_T)rtb_afbk_ratio <= 205)))
        {
          // Transition: '<S422>:150'
          // Exit Internal 'SHORT_TO_BATTERY': '<S422>:146'
          localDW->bitsForTID0.is_SHORT_TO_BATTERY =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
          localDW->bitsForTID0.is_c4_MX_Library = MX_Gtwy_Control_IN_NORMAL_l0jr;

          // Entry 'NORMAL': '<S422>:145'
          localDW->db_cnt = (uint16_T)INACTIVE;
          localB->state = NORMAL;
        } else if (localDW->bitsForTID0.is_SHORT_TO_BATTERY ==
                   MX_Gtwy_Contro_IN_DEBOUNCE_mxcs) {
          // During 'DEBOUNCE': '<S422>:156'
          if (localDW->db_cnt >= rtp_STB_DB_CNT) {
            // Transition: '<S422>:160'
            localDW->bitsForTID0.is_SHORT_TO_BATTERY =
              MX_Gtwy_Control_IN_FAULT_k5qe;

            // Entry 'FAULT': '<S422>:159'
            localB->state = SHORT_TO_BATTERY;
          } else {
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          }
        } else {
          localB->state = SHORT_TO_BATTERY;

          // During 'FAULT': '<S422>:159'
        }
        break;

       default:
        // During 'SHORT_TO_GROUND': '<S422>:147'
        if ((localB->state == NORMAL) && (((int32_T)rtu_duty < 64225) ||
             ((int32_T)rtb_afbk_ratio >= 51))) {
          // Transition: '<S422>:154'
          // Exit Internal 'SHORT_TO_GROUND': '<S422>:147'
          localDW->bitsForTID0.is_SHORT_TO_GROUND =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_bes5;
          localDW->bitsForTID0.is_c4_MX_Library = MX_Gtwy_Control_IN_NORMAL_l0jr;

          // Entry 'NORMAL': '<S422>:145'
          localDW->db_cnt = (uint16_T)INACTIVE;
          localB->state = NORMAL;
        } else if (localDW->bitsForTID0.is_SHORT_TO_GROUND ==
                   MX_Gtwy_Contro_IN_DEBOUNCE_mxcs) {
          // During 'DEBOUNCE': '<S422>:165'
          if (localDW->db_cnt >= rtp_STG_DB_CNT) {
            // Transition: '<S422>:168'
            localDW->bitsForTID0.is_SHORT_TO_GROUND =
              MX_Gtwy_Control_IN_FAULT_k5qe;

            // Entry 'FAULT': '<S422>:167'
            localB->state = SHORT_TO_GROUND;
          } else {
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          }
        } else {
          localB->state = SHORT_TO_GROUND;

          // During 'FAULT': '<S422>:167'
        }
        break;
      }
    }

    // End of Chart: '<S421>/Fault monitor'

    // SignalConversion: '<S421>/OutportBufferForstate'
    *rty_state = localB->state;
  } else {
    if (localDW->hc_hsd_MODE) {
      MX_Gtwy_Control_hc_hsd_Disable(rty_state, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S286>/hc_hsd'
}

// System initialize for atomic system: '<S561>/hc_Output'
void MX__output_single_OpenLoop_Init(uint8_T *rty_state,
  rtB_output_single_OpenLoop_MX_G *localB, rtDW_output_single_OpenLoop_MX_
  *localDW)
{
  // InitializeConditions for UnitDelay: '<S565>/Unit Delay'
  localDW->UnitDelay_DSTATE = ((uint8_T)0U);

  // SystemInitialize for Chart: '<S565>/control'
  localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_opa5;
  localDW->bitsForTID0.is_active_c41_MX_Library = 0U;
  localDW->bitsForTID0.is_c41_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_opa5;
  localB->duty_Output = 0U;
  *rty_state = 0U;

  // SystemInitialize for Enabled SubSystem: '<S565>/hc_hsd'
  MX_Gtwy_Control_hc_hsd_Init(&localB->state, &localB->hc_hsd, &localDW->hc_hsd);

  // End of SystemInitialize for SubSystem: '<S565>/hc_hsd'
}

// System reset for atomic system: '<S561>/hc_Output'
void MX_output_single_OpenLoop_Reset(uint8_T *rty_state,
  rtB_output_single_OpenLoop_MX_G *localB, rtDW_output_single_OpenLoop_MX_
  *localDW)
{
  // InitializeConditions for UnitDelay: '<S565>/Unit Delay'
  localDW->UnitDelay_DSTATE = ((uint8_T)0U);

  // SystemReset for Chart: '<S565>/control'
  localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_opa5;
  localDW->bitsForTID0.is_active_c41_MX_Library = 0U;
  localDW->bitsForTID0.is_c41_MX_Library = MX_Gtwy_IN_NO_ACTIVE_CHILD_opa5;
  localB->duty_Output = 0U;
  *rty_state = 0U;
}

// Disable for atomic system: '<S561>/hc_Output'
void output_single_OpenLoop_Disable(rtB_output_single_OpenLoop_MX_G *localB,
  rtDW_output_single_OpenLoop_MX_ *localDW)
{
  // Disable for Enabled SubSystem: '<S565>/hc_hsd'
  if (localDW->hc_hsd.hc_hsd_MODE) {
    MX_Gtwy_Control_hc_hsd_Disable(&localB->state, &localDW->hc_hsd);
  }

  // End of Disable for SubSystem: '<S565>/hc_hsd'
}

// Output and update for atomic system: '<S561>/hc_Output'
void MX_Gtwy__output_single_OpenLoop(uint16_T rtu_cmd, uint8_T
  rtu_state_Vbattery, uint16_T rtu_calc_VBattery, uint16_T rtu_afbk_A2D, uint8_T
  *rty_state, uint16_T *rty_duty_Output, rtB_output_single_OpenLoop_MX_G *localB,
  rtDW_output_single_OpenLoop_MX_ *localDW, uint16_T rtp_MAX_VOLTS, uint16_T
  rtp_OPEN_DB_CNT, uint16_T rtp_STB_DB_CNT, uint16_T rtp_STG_DB_CNT, uint8_T
  rtp_FUNCTION, uint16_T rtp_AFBK_GAIN)
{
  boolean_T rtb_HiddenBuf_InsertedFor__ou0l;
  uint16_T rtb_Gain_huj2;
  uint32_T tmp;

  // Gain: '<S565>/Gain'
  tmp = (uint32_T)((uint32_T)rtp_AFBK_GAIN * (uint32_T)rtu_afbk_A2D);
  if (tmp > 65535U) {
    tmp = 65535U;
  }

  rtb_Gain_huj2 = (uint16_T)tmp;

  // End of Gain: '<S565>/Gain'

  // SignalConversion: '<S565>/HiddenBuf_InsertedFor_hc_hsd_at_inport_3' incorporates:
  //   Constant: '<S565>/FunctionState'
  //   Constant: '<S568>/Constant'
  //   Constant: '<S569>/Constant'
  //   Logic: '<S565>/Logical Operator'
  //   RelationalOperator: '<S568>/Compare'
  //   RelationalOperator: '<S569>/Compare'

  rtb_HiddenBuf_InsertedFor__ou0l = ((rtp_FUNCTION != NON_FUNCTIONAL) &&
    (rtu_state_Vbattery != OORL));

  // Chart: '<S565>/control' incorporates:
  //   UnitDelay: '<S565>/Unit Delay'

  // Gateway: output_single_OpenLoop/control
  // During: output_single_OpenLoop/control
  if ((uint32_T)localDW->bitsForTID0.is_active_c41_MX_Library == 0U) {
    // Entry: output_single_OpenLoop/control
    localDW->bitsForTID0.is_active_c41_MX_Library = 1U;

    // Entry Internal: output_single_OpenLoop/control
    // Transition: '<S571>:54'
    localDW->bitsForTID0.is_c41_MX_Library = MX_Gtwy_Cont_IN_FUNCTIONAL_gxam;

    // Entry 'FUNCTIONAL': '<S571>:21'
    localB->duty_Output = rtu_cmd;

    // Entry Internal 'FUNCTIONAL': '<S571>:21'
    // Transition: '<S571>:62'
    localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_Contro_IN_INACTIVE_l135;

    // Entry 'INACTIVE': '<S571>:2'
    *rty_state = INACTIVE;
  } else if (localDW->bitsForTID0.is_c41_MX_Library ==
             MX_Gtwy_Control_IN_ERROR_l2ny) {
    // During 'ERROR': '<S571>:22'
    if (localDW->UnitDelay_DSTATE == NORMAL) {
      // Transition: '<S571>:64'
      localDW->bitsForTID0.is_c41_MX_Library = MX_Gtwy_Cont_IN_FUNCTIONAL_gxam;

      // Entry 'FUNCTIONAL': '<S571>:21'
      localB->duty_Output = rtu_cmd;

      // Entry Internal 'FUNCTIONAL': '<S571>:21'
      // Transition: '<S571>:62'
      localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_Contro_IN_INACTIVE_l135;

      // Entry 'INACTIVE': '<S571>:2'
      *rty_state = INACTIVE;
    }
  } else {
    // During 'FUNCTIONAL': '<S571>:21'
    if (localDW->UnitDelay_DSTATE != NORMAL) {
      // Transition: '<S571>:63'
      // Exit Internal 'FUNCTIONAL': '<S571>:21'
      localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_opa5;
      localDW->bitsForTID0.is_c41_MX_Library = MX_Gtwy_Control_IN_ERROR_l2ny;

      // Entry 'ERROR': '<S571>:22'
      localB->duty_Output = 0U;
      *rty_state = localDW->UnitDelay_DSTATE;
    } else {
      localB->duty_Output = rtu_cmd;
      if (localDW->bitsForTID0.is_FUNCTIONAL == MX_Gtwy_Control_IN_ACTIVE_itwh)
      {
        // During 'ACTIVE': '<S571>:1'
        if ((uint32_T)rtu_cmd == (uint32_T)((uint32_T)INACTIVE << 16)) {
          // Transition: '<S571>:37'
          localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_Contro_IN_INACTIVE_l135;

          // Entry 'INACTIVE': '<S571>:2'
          *rty_state = INACTIVE;
        }
      } else {
        // During 'INACTIVE': '<S571>:2'
        if ((uint32_T)rtu_cmd != (uint32_T)((uint32_T)INACTIVE << 16)) {
          // Transition: '<S571>:35'
          localDW->bitsForTID0.is_FUNCTIONAL = MX_Gtwy_Control_IN_ACTIVE_itwh;

          // Entry 'ACTIVE': '<S571>:1'
          *rty_state = ACTIVE;
        }
      }
    }
  }

  // End of Chart: '<S565>/control'

  // Outputs for Atomic SubSystem: '<S565>/Voltage_Limiter'
  MX_Gtwy_Control_Voltage_Limiter(rtu_calc_VBattery, localB->duty_Output,
    rty_duty_Output, rtp_MAX_VOLTS);

  // End of Outputs for SubSystem: '<S565>/Voltage_Limiter'

  // Outputs for Enabled SubSystem: '<S565>/hc_hsd'
  MX_Gtwy_Control_hc_hsd(rtb_HiddenBuf_InsertedFor__ou0l, *rty_duty_Output,
    rtb_Gain_huj2, rtu_calc_VBattery, &localB->state, &localB->hc_hsd,
    &localDW->hc_hsd, rtp_OPEN_DB_CNT, rtp_STB_DB_CNT, rtp_STG_DB_CNT);

  // End of Outputs for SubSystem: '<S565>/hc_hsd'

  // Update for UnitDelay: '<S565>/Unit Delay'
  localDW->UnitDelay_DSTATE = localB->state;
}

//
//  [EOF]

