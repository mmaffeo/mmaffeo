//
//  Copyright (c) 2009 Bobcat Company as an unpublished work.
//  All Rights Reserved.
//
//  The information contained herein is confidential property of Bobcat Company.
//  The use, copying, transfer or disclosure of such information is prohibited except
//  by express written agreement with Bobcat Company.
//
//  Code Generated by Simulink Real-Time Workshop
//
//  Simulink model                       : MX_Gtwy_Control


#include "mod_Outputs.h"

// Include model header file for global data
#include "MX_Gtwy_Control.h"
#include "MX_Gtwy_Control_private.h"

// Named constants for Chart: '<S415>/Fault monitor'
#define MX_Gtwy_Contro_IN_debounce_cuwh ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Ok          ((uint8_T)1U)
#define MX_Gtwy_Control_IN_error_knwh  ((uint8_T)3U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_c5m3 ((uint8_T)0U)

// Named constants for Chart: '<S282>/Buzzer'
#define MX_Gtwy_Con_IN_Below_Grade_Zone ((uint8_T)1U)
#define MX_Gtwy_Cont_IN_One_Beep_Medium ((uint8_T)6U)
#define MX_Gtwy_Contro_IN_One_Beep_Long ((uint8_T)5U)
#define MX_Gtwy_Control_FIFTEEN_SECONDS ((uint16_T)1499U)
#define MX_Gtwy_Control_IN_Beep        ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Brief_Off   ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Depth_Check ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Grade_Zone  ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Multiple_Off ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Multiple_On ((uint8_T)3U)
#define MX_Gtwy_Control_IN_No_Beep     ((uint8_T)3U)
#define MX_Gtwy_Control_IN_Off_fwwp    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_On_lc3f     ((uint8_T)2U)
#define MX_Gtwy_Control_IN_On_lc3ft    ((uint8_T)4U)
#define MX_Gtwy_Control_IN_Single_Off  ((uint8_T)7U)
#define MX_Gtwy_Control_IN_Single_On   ((uint8_T)8U)
#define MX_Gtwy_Control_IN_Warning_Zone ((uint8_T)3U)
#define MX_Gtwy_Control_ONE_SECOND_ezbk ((uint16_T)99U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5 ((uint8_T)0U)

// Named constants for Chart: '<S364>/Diverter'
#define MX_Gtwy_Con_IN_DebounceInactive ((uint8_T)3U)
#define MX_Gtwy_Contr_IN_DebounceActive ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_EMEA_CONTROLS ((uint8_T)1U)
#define MX_Gtwy_Contro_IN_INACTIVE_cstq ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_InactiveCheck ((uint8_T)5U)
#define MX_Gtwy_Contro_IN_Inactive_lhek ((uint8_T)4U)
#define MX_Gtwy_Contro_IN_SECOND_AUX_NA ((uint8_T)3U)
#define MX_Gtwy_Control_IN_ACTIVE_azwi ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Active_hlsv ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h ((uint8_T)0U)
#define MX_Gtwy__IN_NON_FUNCTIONAL_menq ((uint8_T)2U)

// Named constants for Chart: '<S384>/Dump_Valve'
#define MX_Gtwy_Control_IN_Off_fwuc    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_On_m33g     ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_lqez ((uint8_T)0U)

// Named constants for Chart: '<S405>/RelaySolenoid'
#define MX_Gtwy_Contro_IN_INACTIVE_atau ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_nevi ((uint8_T)1U)
#define MX_Gtwy_Control_IN_INACTIVE_OFF ((uint8_T)3U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_ei1u ((uint8_T)0U)

// Named constants for Chart: '<S406>/RelaySolenoid'
#define MX_Gt_IN_STARTUP_ERROR_ON_CHECK ((uint8_T)3U)
#define MX_Gtwy_Contro_IN_INACTIVE_phj4 ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_gz5o ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_aog3 ((uint8_T)0U)

// Named constants for Chart: '<S286>/Solenoid'
#define MX_Gtwy_Contr_IN_CHECK_ERROR_ON ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_INACTIVE_nope ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_e31e ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ECU_HOLD    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ERROR_oymp  ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ERROR_oymps ((uint8_T)2U)
#define MX_Gtwy_Control_IN_FUEL_HOLD   ((uint8_T)2U)
#define MX_Gtwy_Control_IN_NORMAL_chyf ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0 ((uint8_T)0U)
#define MX_Gtwy__IN_NON_FUNCTIONAL_hp4p ((uint8_T)3U)

// Named constants for Chart: '<S287>/Timer'
#define MX_Gtwy_Contro_IN_INACTIVE_WAIT ((uint8_T)3U)
#define MX_Gtwy_Contro_IN_INACTIVE_c0o4 ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_g3bz ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_mh0r ((uint8_T)0U)

// Named constants for Chart: '<S288>/GlowPlug'
#define MX_Gtwy_Co_IN_GLOW_DURING_CRANK ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_INACTIVE_lvoc ((uint8_T)3U)
#define MX_Gtwy_Control_IN_AFTERGLOW   ((uint8_T)1U)
#define MX_Gtwy_Control_IN_CRANKING    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Countdown   ((uint8_T)1U)
#define MX_Gtwy_Control_IN_ECU_ljaf    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_NORMAL_jia4 ((uint8_T)3U)
#define MX_Gtwy_Control_IN_PREGLOW     ((uint8_T)1U)
#define MX_Gtwy_Control_IN_PREGLOW_WAIT ((uint8_T)2U)
#define MX_Gtwy_Control_IN_PREHEAT     ((uint8_T)4U)
#define MX_Gtwy_Control_IN_RESET_CRANK ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Stop        ((uint8_T)2U)
#define MX_Gtwy_Control_IN_WAIT_STARTUP ((uint8_T)5U)
#define MX_Gtwy_Control_IN_Wait        ((uint8_T)3U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel ((uint8_T)0U)
#define MX_Gtwy__IN_NON_FUNCTIONAL_pvlo ((uint8_T)2U)

// Named constants for Chart: '<S432>/Hyd_Bypass'
#define MX_Gtwy_Control_IN_Cranking    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Delay_dyin  ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Not_Cranking ((uint8_T)3U)
#define MX_Gtwy_Control_IN_Off_chbn    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_On_cbgn     ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_k5om ((uint8_T)0U)

// Named constants for Chart: '<S451>/Hyd_Enable'
#define MX_Gtwy_Co_IN_Not_Cranking_llua ((uint8_T)3U)
#define MX_Gtwy_Contro_IN_Cranking_c5p0 ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Delay_gzfi  ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Off_cbc5    ((uint8_T)1U)
#define MX_Gtwy_Control_IN_On_f50i     ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_pdyo ((uint8_T)0U)

// Named constants for Chart: '<S291>/Hydraulic_Xchange'
#define MX_Gtwy_Contro_IN_Inactive_j3td ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_Nonfunctional ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Active_lofk ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Functional  ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_daqq ((uint8_T)0U)

// Named constants for Chart: '<S292>/Lights'
#define MX_Gtw_IN_LIGHTS_ACTIVE_RISING1 ((uint8_T)2U)
#define MX_Gtw_IN_LIGHTS_ACTIVE_RISING2 ((uint8_T)3U)
#define MX_Gtwy_Cont_IN_LIGHTS_INACTIVE ((uint8_T)4U)
#define MX_Gtwy_Contro_IN_LIGHTS_ACTIVE ((uint8_T)1U)

// Named constants for Chart: '<S485>/Commands'
#define MX_Gtwy_Contro_IN_Inactive_cx3o ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Active_f4bs ((uint8_T)1U)
#define MX_Gtwy_Control_IN_BaseActive  ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Neutral_nhy3 ((uint8_T)2U)
#define MX_Gtwy_Control_IN_RodActive   ((uint8_T)3U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_ik2b ((uint8_T)0U)

// Named constants for Chart: '<S294>/PBValve'
#define MX_Gtwy_Contro_IN_INACTIVE_h2aq ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_ftsh ((uint8_T)1U)

// Named constants for Chart: '<S295>/Starter'
#define MX_Gtwy_Co_IN_DEBOUNCE_FOR_AUTO ((uint8_T)3U)
#define MX_Gtwy_Cont_IN_AUTOMATED_START ((uint8_T)2U)
#define MX_Gtwy_Contr_IN_INACTIVE_h31qw ((uint8_T)4U)
#define MX_Gtwy_Contro_IN_INACTIVE_h31q ((uint8_T)2U)
#define MX_Gtwy_Control_IN_ACTIVE_bwmt ((uint8_T)1U)
#define MX_Gtwy_Control_IN_AUTOMATED   ((uint8_T)1U)
#define MX_Gtwy_Control_IN_MANUAL      ((uint8_T)2U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_fajt ((uint8_T)0U)
#define MX_Gtwy__IN_NON_FUNCTIONAL_gcn1 ((uint8_T)3U)

// Named constants for Chart: '<S297>/Relay'
#define MX_G_IN_DEBOUNCE_ERROR_ON_CHECK ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_INACTIVE_bo51 ((uint8_T)4U)
#define MX_Gtwy_Control_IN_ACTIVE_ftye ((uint8_T)1U)
#define MX_Gtwy_Control_IN_DELAY_OFF   ((uint8_T)3U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_liu3 ((uint8_T)0U)

// Named constants for Chart: '<S561>/TwoSpeed_Control'
#define MX_Gtwy_C_IN_Autoshift_Inactive ((uint8_T)2U)
#define MX_Gtwy_Con_IN_Autoshift_Active ((uint8_T)1U)
#define MX_Gtwy_Con_IN_Track_Tensioning ((uint8_T)2U)
#define MX_Gtwy_Con_IN_Travel_Autoshift ((uint8_T)2U)
#define MX_Gtwy_Cont_IN_Low_Travel_aquv ((uint8_T)4U)
#define MX_Gtwy_Cont_IN_TrackTensioning ((uint8_T)5U)
#define MX_Gtwy_Contro_IN_Inactive_mv0f ((uint8_T)2U)
#define MX_Gtwy_Contro_IN_Low_No_Travel ((uint8_T)3U)
#define MX_Gtwy_Contro_IN_NoTravel_High ((uint8_T)1U)
#define MX_Gtwy_Contro_IN_NonFunctional ((uint8_T)3U)
#define MX_Gtwy_Control_IN_Active_pkjk ((uint8_T)1U)
#define MX_Gtwy_Control_IN_AutoShift   ((uint8_T)1U)
#define MX_Gtwy_Control_IN_Delay_b1g5  ((uint8_T)1U)
#define MX_Gtwy_Control_IN_High        ((uint8_T)1U)
#define MX_Gtwy_Control_IN_High_pby2   ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Low         ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Low_Delay   ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Low_Range   ((uint8_T)2U)
#define MX_Gtwy_Control_IN_Low_Travel  ((uint8_T)3U)
#define MX_Gtwy_Control_IN_Normal_h4rf ((uint8_T)4U)
#define MX_Gtwy_Control_IN_Normal_h4rfj ((uint8_T)1U)
#define MX_Gtwy_IN_High_Range_Available ((uint8_T)1U)
#define MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz ((uint8_T)0U)
#define MX_IN_AutoShift_TrackTensioning ((uint8_T)2U)

// Forward declaration for local functions
static uint8_T MX_Gtwy_Control_out_state(boolean_T rtu_cmd, boolean_T rtu_fbk,
  rtDW_dout_chk_MX_Gtwy_Control *localDW, uint16_T rtp_ERR_OFF_DB_CNT, uint16_T
  rtp_ERR_ON_DB_CNT);

// Forward declaration for local functions
static void MX_Gtwy_Control_Depth_Check(void);

// Forward declaration for local functions
static void MX_Gtwy_Control_FuelTiming(void);

// Forward declaration for local functions
static void MX_Gtwy_Control_PreheatTime(uint16_T temp);
static void MX_Gtwy_Control_AfterglowTime(uint16_T temp);
static void MX_Gtwy_Control_PreheatWaitTime(uint16_T temp);

// Forward declaration for local functions
static void MX_Gtwy_Control_Normal(uint8_T *state_TwoSpeedIcon_czcv, uint8_T
  *FixPtRelationalOperator_n1fs);
static void MX_Gtwy_Control_Control(uint8_T *state_TwoSpeedIcon_czcv, const
  boolean_T *Compare_geoy, const uint16_T *DataTypeConversion3, uint8_T
  *FixPtRelationalOperator_n1fs);

// System initialize for atomic system: '<S4>/Aux_Hydraulics'
void MX_Gtwy_Con_Aux_Hydraulics_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S281>/Aux_Hydraulics'
  // InitializeConditions for UnitDelay: '<S310>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE = ((uint16_T)0U);

  // InitializeConditions for UnitDelay: '<S318>/Delay Input2'
  MX_Gtwy_Control_DWork.DelayInput2_DSTATE = 0;

  // InitializeConditions for UnitDelay: '<S311>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE_abci = ((uint16_T)0U);

  // InitializeConditions for UnitDelay: '<S323>/Delay Input2'
  MX_Gtwy_Control_DWork.DelayInput2_DSTATE_gc5y = 0;

  // SystemInitialize for Truth Table: '<S302>/Aux_Control_Logic'
  MX_Gtwy_Control_DWork.ACDVarFlow = 0U;

  // SystemInitialize for Atomic SubSystem: '<S299>/hc_pair_control'
  MX__output_pair_ClosedLoop_Init(&MX_Gtwy_Control_B.hs_cmd_mvqz,
    &MX_Gtwy_Control_B.ls_cmd_jnku, &MX_Gtwy_Control_B.state_Output_movq,
    &MX_Gtwy_Control_B.hc_pair_control, &MX_Gtwy_Control_DWork.hc_pair_control);

  // End of SystemInitialize for SubSystem: '<S299>/hc_pair_control'

  // SystemInitialize for Atomic SubSystem: '<S299>/hc_pair_control1'
  MX__output_pair_ClosedLoop_Init(&MX_Gtwy_Control_B.hs_cmd_cifl,
    &MX_Gtwy_Control_B.ls_cmd_mxkm, &MX_Gtwy_Control_B.state_Output_akdd,
    &MX_Gtwy_Control_B.hc_pair_control1, &MX_Gtwy_Control_DWork.hc_pair_control1);

  // End of SystemInitialize for SubSystem: '<S299>/hc_pair_control1'

  // End of SystemInitialize for SubSystem: '<S281>/Aux_Hydraulics'
}

// Output and update for atomic system: '<S4>/Aux_Hydraulics'
void MX_Gtwy_Control_Aux_Hydraulics(void)
{
  // local block i/o variables
  uint16_T rtb_position_Pot;
  uint16_T rtb_Aux_Table1;
  uint16_T rtb_Aux_Table2;
  uint16_T rtb_Aux_Table3;
  uint16_T rtb_DataTypeConversion1_m3xv;
  boolean_T aVarTruthTableCondition_1;
  boolean_T aVarTruthTableCondition_2;
  boolean_T aVarTruthTableCondition_3;
  boolean_T aVarTruthTableCondition_4;
  boolean_T aVarTruthTableCondition_5;
  boolean_T aVarTruthTableCondition_6;
  boolean_T aVarTruthTableCondition_7;
  boolean_T aVarTruthTableCondition_9;
  boolean_T aVarTruthTableCondition_10;
  boolean_T aVarTruthTableCondition_11;
  boolean_T aVarTruthTableCondition_12;
  boolean_T b;
  uint8_T rtb_Saturation;
  uint8_T rtb_state_Pot;
  uint16_T rtb_Switch_aazc;
  int16_T rtb_Saturation_eckz;
  uint16_T rtb_Switch1;
  uint16_T rtb_icmd_Base;
  int32_T rtb_sampletime;
  int32_T rtb_UkYk1;
  int32_T rtb_deltafalllimit;
  boolean_T rtb_LogicalOperator_cwje;
  uint16_T rtb_Switch_allm;
  uint16_T rtb_Switch_dydk;
  uint32_T qY;
  int32_T rtb_deltafalllimit_tmp;

  // Outputs for Enabled SubSystem: '<S281>/Aux_Hydraulics' incorporates:
  //   EnablePort: '<S299>/Enable'

  // Logic: '<S281>/Logical Operator' incorporates:
  //   Constant: '<S281>/Constant1'
  //   Constant: '<S300>/Constant'
  //   Constant: '<S301>/Constant'
  //   Inport: '<Root>/afbk_AuxBase'
  //   Inport: '<Root>/afbk_AuxRod'
  //   Inport: '<Root>/ain_PrecisionReference'
  //   Inport: '<Root>/ifbk_AuxBase'
  //   Inport: '<Root>/ifbk_AuxRod'
  //   Inport: '<Root>/state_System'
  //   RelationalOperator: '<S300>/Compare'
  //   RelationalOperator: '<S301>/Compare'

  if ((CONSTANT_DATA->AUX_FUNCTION != NON_FUNCTIONAL) && (state_System ==
       SYS_NORMAL)) {
    if (!MX_Gtwy_Control_DWork.Aux_Hydraulics_MODE) {
      // InitializeConditions for UnitDelay: '<S310>/Unit Delay'
      MX_Gtwy_Control_DWork.UnitDelay_DSTATE = ((uint16_T)0U);

      // InitializeConditions for UnitDelay: '<S318>/Delay Input2'
      MX_Gtwy_Control_DWork.DelayInput2_DSTATE = 0;

      // InitializeConditions for UnitDelay: '<S311>/Unit Delay'
      MX_Gtwy_Control_DWork.UnitDelay_DSTATE_abci = ((uint16_T)0U);

      // InitializeConditions for UnitDelay: '<S323>/Delay Input2'
      MX_Gtwy_Control_DWork.DelayInput2_DSTATE_gc5y = 0;

      // SystemReset for Truth Table: '<S302>/Aux_Control_Logic'
      MX_Gtwy_Control_DWork.ACDVarFlow = 0U;

      // SystemReset for Atomic SubSystem: '<S299>/hc_pair_control'
      MX_output_pair_ClosedLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_mvqz,
        &MX_Gtwy_Control_B.ls_cmd_jnku, &MX_Gtwy_Control_B.state_Output_movq,
        &MX_Gtwy_Control_B.hc_pair_control,
        &MX_Gtwy_Control_DWork.hc_pair_control);

      // End of SystemReset for SubSystem: '<S299>/hc_pair_control'

      // SystemReset for Atomic SubSystem: '<S299>/hc_pair_control1'
      MX_output_pair_ClosedLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_cifl,
        &MX_Gtwy_Control_B.ls_cmd_mxkm, &MX_Gtwy_Control_B.state_Output_akdd,
        &MX_Gtwy_Control_B.hc_pair_control1,
        &MX_Gtwy_Control_DWork.hc_pair_control1);

      // End of SystemReset for SubSystem: '<S299>/hc_pair_control1'
      MX_Gtwy_Control_DWork.Aux_Hydraulics_MODE = true;
    }

    // Truth Table: '<S299>/Controls_Select'
    // Truth Table Function 'MX_Gtwy_Control/Outputs/Aux_Hydraulics/Aux_Hydraulics/Controls_Select': '<S305>:1' 
    //  EMEA Controls
    // Condition '#1': '<S305>:1:10'
    aVarTruthTableCondition_1 = (CONSTANT_DATA->AUX_FUNCTION ==
      AUX_EMEA_CONTROLS);

    //  Joysticks Reversed (Kawasaki)
    // Condition '#2': '<S305>:1:14'
    aVarTruthTableCondition_2 = (CONSTANT_DATA->EMEA_CONTROLS_REVERSE ==
      NON_FUNCTIONAL);

    //  Aux1 on right
    // Condition '#3': '<S305>:1:18'
    aVarTruthTableCondition_3 = (mode_RightControl == MODE_RIGHT_AUX1);
    if ((!aVarTruthTableCondition_1) && aVarTruthTableCondition_2 &&
        aVarTruthTableCondition_3) {
      // Decision 'D1': '<S305>:1:20'
      //  Legacy Aux Pot
      // Action '1': '<S305>:1:36'
      rtb_position_Pot = position_AuxPot;

      // Action '1': '<S305>:1:37'
      rtb_state_Pot = state_AuxPot;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_2) &&
               aVarTruthTableCondition_3) {
      // Decision 'D2': '<S305>:1:22'
      //  Right Pot
      // Action '2': '<S305>:1:43'
      rtb_position_Pot = position_RightPot;

      // Action '2': '<S305>:1:44'
      rtb_state_Pot = state_RightPot;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               aVarTruthTableCondition_3) {
      // Decision 'D3': '<S305>:1:24'
      //  Right Pot
      // Action '2': '<S305>:1:43'
      rtb_position_Pot = position_RightPot;

      // Action '2': '<S305>:1:44'
      rtb_state_Pot = state_RightPot;
    } else if (aVarTruthTableCondition_1 && aVarTruthTableCondition_2 &&
               aVarTruthTableCondition_3) {
      // Decision 'D4': '<S305>:1:26'
      //  Right Pot
      // Action '2': '<S305>:1:43'
      rtb_position_Pot = position_RightPot;

      // Action '2': '<S305>:1:44'
      rtb_state_Pot = state_RightPot;
    } else {
      // Decision 'D5': '<S305>:1:28'
      //  Default
      //  Neutral
      // Action '3': '<S305>:1:50'
      rtb_position_Pot = 500U;

      // Action '3': '<S305>:1:51'
      rtb_state_Pot = 8U;
    }

    // End of Truth Table: '<S299>/Controls_Select'

    // Logic: '<S308>/Logical Operator' incorporates:
    //   Constant: '<S308>/Constant4'
    //   Constant: '<S312>/Constant'
    //   DataStoreRead: '<S308>/Data Store Read'
    //   RelationalOperator: '<S312>/Compare'

    aVarTruthTableCondition_1 = !(((int32_T)eeMirror.deluxe_G5 != 0) &&
      (CONSTANT_DATA->AUX_FUNCTION == AUX_EMEA_CONTROLS));

    // Saturate: '<S308>/Saturation'
    if (aux_Flow > ((uint8_T)3U)) {
      rtb_Saturation = ((uint8_T)3U);
    } else if (aux_Flow < ((uint8_T)1U)) {
      rtb_Saturation = ((uint8_T)1U);
    } else {
      rtb_Saturation = aux_Flow;
    }

    // End of Saturate: '<S308>/Saturation'

    // MultiPortSwitch: '<S308>/Multiport Switch' incorporates:
    //   Lookup: '<S308>/Aux_Table1'
    //   Lookup: '<S308>/Aux_Table2'

    switch ((int32_T)rtb_Saturation) {
     case 1:
      // Lookup: '<S308>/Aux_Table1'
      //
      //  About '<S308>/Aux_Table1':
      //  Input0  Data Type:  Integer        U16
      //  Output0 Data Type:  Fixed Point    U16  2^-12
      //  Saturation Mode: Saturate
      //  Lookup Method: Linear_Endpoint
      //
      //  XData is inlined and evenly spaced, so the algorithm only needs
      //  the value of the first element, the last element, and the spacing.
      //  For efficiency, XData is excluded from the generated code.
      //  YData parameter uses the same data type and scaling as Output0

      LookUpEven_U16_U16_SAT( &(rtb_Aux_Table1), (&(MXGTW_AUXHYD1[0])),
        rtb_position_Pot, 20U, 160U, 6U);
      rtb_Switch_aazc = rtb_Aux_Table1;
      break;

     case 2:
      // Lookup: '<S308>/Aux_Table2'
      //
      //  About '<S308>/Aux_Table2':
      //  Input0  Data Type:  Integer        U16
      //  Output0 Data Type:  Fixed Point    U16  2^-12
      //  Saturation Mode: Saturate
      //  Lookup Method: Linear_Endpoint
      //
      //  XData is inlined and evenly spaced, so the algorithm only needs
      //  the value of the first element, the last element, and the spacing.
      //  For efficiency, XData is excluded from the generated code.
      //  YData parameter uses the same data type and scaling as Output0

      LookUpEven_U16_U16_SAT( &(rtb_Aux_Table2), (&(MXGTW_AUXHYD2[0])),
        rtb_position_Pot, 20U, 160U, 6U);
      rtb_Switch_aazc = rtb_Aux_Table2;
      break;

     default:
      // Switch: '<S308>/Switch' incorporates:
      //   Constant: '<S314>/Constant4'
      //   Gain: '<S314>/Gain'
      //   Inport: '<Root>/flow_Aux1Percent'
      //   Lookup: '<S308>/Aux_Table3'
      //   Product: '<S314>/Product'
      //   Sum: '<S314>/Sum1'

      if (aVarTruthTableCondition_1) {
        // Lookup: '<S308>/Aux_Table3'
        //
        //  About '<S308>/Aux_Table3':
        //  Input0  Data Type:  Integer        U16
        //  Output0 Data Type:  Fixed Point    U16  2^-12
        //  Saturation Mode: Saturate
        //  Lookup Method: Linear_Endpoint
        //
        //  XData is inlined and evenly spaced, so the algorithm only needs
        //  the value of the first element, the last element, and the spacing.
        //  For efficiency, XData is excluded from the generated code.
        //  YData parameter uses the same data type and scaling as Output0

        LookUpEven_U16_U16_SAT( &(rtb_Aux_Table3), (&(MXGTW_AUXHYD3[0])),
          rtb_position_Pot, 20U, 160U, 6U);
        rtb_Switch_aazc = rtb_Aux_Table3;
      } else {
        // Lookup: '<S314>/Aux_Table3'
        //
        //  About '<S314>/Aux_Table3':
        //  Input0  Data Type:  Integer        U16
        //  Output0 Data Type:  Fixed Point    U16  2^-12
        //  Saturation Mode: Saturate
        //  Lookup Method: Linear_Endpoint
        //
        //  XData is inlined and evenly spaced, so the algorithm only needs
        //  the value of the first element, the last element, and the spacing.
        //  For efficiency, XData is excluded from the generated code.
        //  YData parameter uses the same data type and scaling as Output0

        LookUpEven_U16_U16_SAT( &(rtb_DataTypeConversion1_m3xv),
          (&(MXGTW_AUXHYD3[0])), rtb_position_Pot, 20U, 160U, 6U);

        // Sum: '<S314>/Sum' incorporates:
        //   Constant: '<S314>/Constant4'
        //   DataTypeConversion: '<S314>/Data Type Conversion'

        rtb_Saturation_eckz = (int16_T)(int32_T)((int32_T)((int32_T)(int16_T)
          rtb_DataTypeConversion1_m3xv - (int32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT) >> 1);

        // Saturate: '<S314>/Saturation'
        if ((int32_T)rtb_Saturation_eckz > (int32_T)4096) {
          rtb_Saturation_eckz = 4096;
        } else {
          if ((int32_T)rtb_Saturation_eckz < (int32_T)0) {
            rtb_Saturation_eckz = 0;
          }
        }

        // End of Saturate: '<S314>/Saturation'

        // DataTypeConversion: '<S314>/Data Type Conversion1'
        rtb_DataTypeConversion1_m3xv = (uint16_T)(int32_T)((int32_T)(uint16_T)
          rtb_Saturation_eckz << 1);
        rtb_Switch_aazc = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT << 4) + (uint32_T)(uint16_T)
          (uint32_T)((uint32_T)((uint32_T)rtb_DataTypeConversion1_m3xv *
          (uint32_T)(uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint16_T)41943U)
          * (uint32_T)flow_Aux1Percent) >> 6)) >> 12)) >> 4);
      }

      // End of Switch: '<S308>/Switch'
      break;
    }

    // End of MultiPortSwitch: '<S308>/Multiport Switch'

    // MultiPortSwitch: '<S308>/Multiport Switch1' incorporates:
    //   Constant: '<S308>/Constant'
    //   Constant: '<S308>/Constant1'

    switch ((int32_T)rtb_Saturation) {
     case 1:
      rtb_Switch1 = CONSTANT_DATA->AUX_FULL_ON_AUX1;
      break;

     case 2:
      rtb_Switch1 = CONSTANT_DATA->AUX_FULL_ON_AUX2;
      break;

     default:
      // Switch: '<S308>/Switch1' incorporates:
      //   Constant: '<S308>/Constant2'
      //   Constant: '<S313>/Constant4'
      //   DataTypeConversion: '<S313>/Data Type Conversion1'
      //   Gain: '<S313>/Gain'
      //   Inport: '<Root>/flow_Aux1Percent'
      //   Product: '<S313>/Product'
      //   Sum: '<S313>/Sum1'

      if (aVarTruthTableCondition_1) {
        rtb_Switch1 = CONSTANT_DATA->AUX_FULL_ON_AUX3;
      } else {
        // Sum: '<S313>/Sum' incorporates:
        //   Constant: '<S308>/Constant2'
        //   Constant: '<S313>/Constant4'
        //   DataTypeConversion: '<S313>/Data Type Conversion'

        rtb_Saturation_eckz = (int16_T)(int32_T)((int32_T)((int32_T)(int16_T)
          CONSTANT_DATA->AUX_FULL_ON_AUX3 - (int32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT) >> 1);

        // Saturate: '<S313>/Saturation'
        if ((int32_T)rtb_Saturation_eckz > (int32_T)4096) {
          rtb_Saturation_eckz = 4096;
        } else {
          if ((int32_T)rtb_Saturation_eckz < (int32_T)0) {
            rtb_Saturation_eckz = 0;
          }
        }

        // End of Saturate: '<S313>/Saturation'
        rtb_Switch1 = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)
          CONSTANT_DATA->AUX_CRACKPOINT_CURRENT << 4) + (uint32_T)(uint16_T)
          (uint32_T)((uint32_T)((uint32_T)(int32_T)(uint16_T)(int32_T)((int32_T)
          (uint16_T)rtb_Saturation_eckz << 1) * (uint32_T)(uint16_T)(uint32_T)
          ((uint32_T)((uint32_T)((uint16_T)41943U) * (uint32_T)flow_Aux1Percent)
           >> 6)) >> 12)) >> 4);
      }

      // End of Switch: '<S308>/Switch1'
      break;
    }

    // End of MultiPortSwitch: '<S308>/Multiport Switch1'

    // S-Function (sfix_bitop): '<S302>/Detent_Front_Mask'
    rtb_Saturation = (uint8_T)(int32_T)((int32_T)state_Detent & (int32_T)
      ((uint8_T)15U));

    // Truth Table: '<S302>/Aux_Control_Logic' incorporates:
    //   Inport: '<Root>/can_ACD_AuxCommand'
    //   Inport: '<Root>/cmd_AuxEnable_ACD'

    // Truth Table Function 'MX_Gtwy_Control/Outputs/Aux_Hydraulics/Aux_Hydraulics/Aux_Hyd_Commands_Current_Control/Aux_Control_Logic': '<S309>:1' 
    //  Aux Enabled
    // Condition '#1': '<S309>:1:20'
    aVarTruthTableCondition_1 = (state_AuxEnable == ACTIVE_MODE_ONE);

    //  Aux Pot - Base Active
    // Condition '#2': '<S309>:1:24'
    aVarTruthTableCondition_2 = (rtb_state_Pot == BASE_ACTIVE);

    //  Aux Pot - Rod Active
    // Condition '#3': '<S309>:1:28'
    aVarTruthTableCondition_3 = (rtb_state_Pot == ROD_ACTIVE);

    //  Base Detent
    // Condition '#4': '<S309>:1:32'
    aVarTruthTableCondition_4 = (rtb_Saturation == BASE_DETENT);

    //  Rod Detent
    // Condition '#5': '<S309>:1:36'
    aVarTruthTableCondition_5 = (rtb_Saturation == ROD_DETENT);

    //  ACD Functional
    // Condition '#6': '<S309>:1:40'
    aVarTruthTableCondition_6 = (CONSTANT_DATA->RACD_FUNCTION != NON_FUNCTIONAL);

    //  ACD Active
    // Condition '#7': '<S309>:1:44'
    aVarTruthTableCondition_7 = (cmd_AuxEnable_ACD == ACTIVE);

    //  ACD Base Active
    if (((int32_T)can_ACD_AuxCommand == 1) || ((int32_T)can_ACD_AuxCommand == 5))
    {
      // Condition '#8': '<S309>:1:48'
      b = true;
    } else {
      b = false;
    }

    //  ACD Rod Active
    // Condition '#9': '<S309>:1:52'
    aVarTruthTableCondition_9 = ((int32_T)can_ACD_AuxCommand == 4);

    //  ACD was in variable flow
    // Condition '#10': '<S309>:1:56'
    aVarTruthTableCondition_10 = ((int32_T)MX_Gtwy_Control_DWork.ACDVarFlow > 0);

    //  Aux Release Rod
    // Condition '#11': '<S309>:1:60'
    aVarTruthTableCondition_11 = (cmd_AuxRelease == ROD_ACTIVE);

    //  Aux Release Base
    // Condition '#12': '<S309>:1:64'
    aVarTruthTableCondition_12 = (cmd_AuxRelease == BASE_ACTIVE);

    //  Engine Cranking
    // Condition '#13': '<S309>:1:68'
    if (state_Engine == ENGINE_CRANKING) {
      // Decision 'D1': '<S309>:1:70'
      //  Aux Off
      // Action '1': '<S309>:1:100'
      rtb_icmd_Base = 0U;

      // Action '1': '<S309>:1:101'
      rtb_Switch1 = 0U;

      // Action '1': '<S309>:1:102'
      MX_Gtwy_Control_B.state_AuxFlow = INACTIVE;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_7) &&
               aVarTruthTableCondition_11 && (!aVarTruthTableCondition_12)) {
      // Decision 'D2': '<S309>:1:72'
      //  Aux Rod Full On
      // Action '2': '<S309>:1:108'
      rtb_icmd_Base = 0U;

      // Action '2': '<S309>:1:109'
      // Action '2': '<S309>:1:110'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_7) && (
                !aVarTruthTableCondition_11) && aVarTruthTableCondition_12) {
      // Decision 'D3': '<S309>:1:74'
      //  Aux Base Full On
      // Action '3': '<S309>:1:116'
      rtb_icmd_Base = rtb_Switch1;

      // Action '3': '<S309>:1:117'
      rtb_Switch1 = 0U;

      // Action '3': '<S309>:1:118'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && (!aVarTruthTableCondition_4) &&
               aVarTruthTableCondition_5 && (!aVarTruthTableCondition_7) &&
               (!aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D4': '<S309>:1:76'
      //  Aux Rod Full On
      // Action '2': '<S309>:1:108'
      rtb_icmd_Base = 0U;

      // Action '2': '<S309>:1:109'
      // Action '2': '<S309>:1:110'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && aVarTruthTableCondition_4 &&
               (!aVarTruthTableCondition_5) && (!aVarTruthTableCondition_7) && (
                !aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D5': '<S309>:1:78'
      //  Aux Base Full On
      // Action '3': '<S309>:1:116'
      rtb_icmd_Base = rtb_Switch1;

      // Action '3': '<S309>:1:117'
      rtb_Switch1 = 0U;

      // Action '3': '<S309>:1:118'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               aVarTruthTableCondition_3 && (!aVarTruthTableCondition_7) &&
               (!aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D6': '<S309>:1:80'
      //  Aux Rod Proportional
      // Action '4': '<S309>:1:124'
      rtb_icmd_Base = 0U;

      // Action '4': '<S309>:1:125'
      rtb_Switch1 = rtb_Switch_aazc;

      // Action '4': '<S309>:1:126'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && aVarTruthTableCondition_2 &&
               (!aVarTruthTableCondition_3) && (!aVarTruthTableCondition_7) && (
                !aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D7': '<S309>:1:82'
      //  Aux Base Proportional
      // Action '5': '<S309>:1:132'
      rtb_icmd_Base = rtb_Switch_aazc;

      // Action '5': '<S309>:1:133'
      rtb_Switch1 = 0U;

      // Action '5': '<S309>:1:134'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_6 && aVarTruthTableCondition_7 && (!b) &&
               (!aVarTruthTableCondition_9) && (!aVarTruthTableCondition_11) &&
               (!aVarTruthTableCondition_12)) {
      // Decision 'D8': '<S309>:1:84'
      //  Reset ACD Variable Flow Flag
      // Action '6': '<S309>:1:140'
      rtb_icmd_Base = 0U;

      // Action '6': '<S309>:1:141'
      rtb_Switch1 = 0U;

      // Action '6': '<S309>:1:142'
      MX_Gtwy_Control_DWork.ACDVarFlow = 0U;

      // Action '6': '<S309>:1:143'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && aVarTruthTableCondition_6 &&
               aVarTruthTableCondition_7 && aVarTruthTableCondition_9 &&
               (!aVarTruthTableCondition_10) && (!aVarTruthTableCondition_11) &&
               (!aVarTruthTableCondition_12)) {
      // Decision 'D9': '<S309>:1:86'
      //  Aux Rod Full On
      // Action '2': '<S309>:1:108'
      rtb_icmd_Base = 0U;

      // Action '2': '<S309>:1:109'
      // Action '2': '<S309>:1:110'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) &&
               (!aVarTruthTableCondition_3) && aVarTruthTableCondition_6 &&
               aVarTruthTableCondition_7 && b && (!aVarTruthTableCondition_10) &&
               (!aVarTruthTableCondition_11) && (!aVarTruthTableCondition_12)) {
      // Decision 'D10': '<S309>:1:88'
      //  Aux Base Full On
      // Action '3': '<S309>:1:116'
      rtb_icmd_Base = rtb_Switch1;

      // Action '3': '<S309>:1:117'
      rtb_Switch1 = 0U;

      // Action '3': '<S309>:1:118'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else if (aVarTruthTableCondition_10 && (!aVarTruthTableCondition_11) &&
               (!aVarTruthTableCondition_12)) {
      // Decision 'D11': '<S309>:1:90'
      //  Inhibit ACD Command
      // Action '7': '<S309>:1:149'
      rtb_icmd_Base = 0U;

      // Action '7': '<S309>:1:150'
      rtb_Switch1 = 0U;

      // Action '7': '<S309>:1:151'
      qY = (uint32_T)((uint32_T)MX_Gtwy_Control_DWork.ACDVarFlow - 1U);
      if (qY > (uint32_T)MX_Gtwy_Control_DWork.ACDVarFlow) {
        qY = 0U;
      }

      MX_Gtwy_Control_DWork.ACDVarFlow = (uint8_T)qY;

      // Action '7': '<S309>:1:152'
      MX_Gtwy_Control_B.state_AuxFlow = ACTIVE;
    } else {
      // Decision 'D12': '<S309>:1:92'
      //  Default
      //  Aux Off
      // Action '1': '<S309>:1:100'
      rtb_icmd_Base = 0U;

      // Action '1': '<S309>:1:101'
      rtb_Switch1 = 0U;

      // Action '1': '<S309>:1:102'
      MX_Gtwy_Control_B.state_AuxFlow = INACTIVE;
    }

    // End of Truth Table: '<S302>/Aux_Control_Logic'

    // Switch: '<S310>/Switch2' incorporates:
    //   Constant: '<S310>/No Limit - Increasing'
    //   Constant: '<S317>/Lower Limit'
    //   Constant: '<S317>/Upper Limit'
    //   Logic: '<S317>/AND'
    //   RelationalOperator: '<S317>/Lower Test'
    //   RelationalOperator: '<S317>/Upper Test'

    if ((CONSTANT_DATA->AUX_RATE_LIMIT_MIN_ENG_SPD <= flt_EngineSpeed) &&
        (flt_EngineSpeed <= CONSTANT_DATA->AUX_RATE_LIMIT_MAX_ENG_SPD)) {
      // Switch: '<S310>/Switch1' incorporates:
      //   Constant: '<S310>/Constant'
      //   Constant: '<S310>/Constant3'
      //   Constant: '<S316>/Constant'
      //   RelationalOperator: '<S316>/Compare'
      //   UnitDelay: '<S310>/Unit Delay'

      if (MX_Gtwy_Control_DWork.UnitDelay_DSTATE >
          CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT) {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_NORMAL_RATE;
      } else {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT_RATE;
      }

      // End of Switch: '<S310>/Switch1'
    } else {
      rtb_UkYk1 = 2048000;
    }

    // End of Switch: '<S310>/Switch2'

    // Product: '<S318>/delta rise limit' incorporates:
    //   SampleTimeMath: '<S318>/sample time'
    //
    //  About '<S318>/sample time':
    //   y = K where K = ( w * Ts )

    rtb_sampletime = mul_s32_hiSR(rtb_UkYk1, 1374389535, 5U);

    // Sum: '<S318>/Difference Inputs1' incorporates:
    //   DataTypeConversion: '<S310>/Data Type Conversion1'
    //   UnitDelay: '<S318>/Delay Input2'

    rtb_UkYk1 = (int32_T)((int32_T)rtb_icmd_Base -
                          MX_Gtwy_Control_DWork.DelayInput2_DSTATE);

    // Product: '<S318>/delta fall limit' incorporates:
    //   Constant: '<S310>/No Limit - Decreasing'
    //   Product: '<S323>/delta fall limit'
    //   SampleTimeMath: '<S318>/sample time'
    //
    //  About '<S318>/sample time':
    //   y = K where K = ( w * Ts )

    rtb_deltafalllimit_tmp = mul_s32_hiSR(-2048000, 1374389535, 5U);

    // Switch: '<S319>/Switch2' incorporates:
    //   Product: '<S318>/delta fall limit'
    //   RelationalOperator: '<S319>/LowerRelop1'
    //   RelationalOperator: '<S319>/UpperRelop'
    //   Switch: '<S319>/Switch'

    if (rtb_UkYk1 > rtb_sampletime) {
      rtb_UkYk1 = rtb_sampletime;
    } else {
      if (rtb_UkYk1 < rtb_deltafalllimit_tmp) {
        // Switch: '<S319>/Switch' incorporates:
        //   Product: '<S318>/delta fall limit'

        rtb_UkYk1 = rtb_deltafalllimit_tmp;
      }
    }

    // End of Switch: '<S319>/Switch2'

    // Sum: '<S318>/Difference Inputs2' incorporates:
    //   UnitDelay: '<S318>/Delay Input2'

    rtb_sampletime = (int32_T)(rtb_UkYk1 +
      MX_Gtwy_Control_DWork.DelayInput2_DSTATE);

    // DataTypeConversion: '<S310>/Data Type Conversion2'
    rtb_Switch_aazc = (uint16_T)rtb_sampletime;

    // Switch: '<S310>/Switch' incorporates:
    //   Constant: '<S310>/Constant2'
    //   Constant: '<S315>/Constant'
    //   RelationalOperator: '<S315>/Compare'

    if (CONSTANT_DATA->AUX_RATE_LIMIT_FUNCTION == NON_FUNCTIONAL) {
      rtb_Switch_allm = rtb_icmd_Base;
    } else {
      rtb_Switch_allm = rtb_Switch_aazc;
    }

    // End of Switch: '<S310>/Switch'

    // Switch: '<S311>/Switch2' incorporates:
    //   Constant: '<S311>/No Limit - Increasing'
    //   Constant: '<S322>/Lower Limit'
    //   Constant: '<S322>/Upper Limit'
    //   Logic: '<S322>/AND'
    //   RelationalOperator: '<S322>/Lower Test'
    //   RelationalOperator: '<S322>/Upper Test'

    if ((CONSTANT_DATA->AUX_RATE_LIMIT_MIN_ENG_SPD <= flt_EngineSpeed) &&
        (flt_EngineSpeed <= CONSTANT_DATA->AUX_RATE_LIMIT_MAX_ENG_SPD)) {
      // Switch: '<S311>/Switch1' incorporates:
      //   Constant: '<S311>/Constant'
      //   Constant: '<S311>/Constant3'
      //   Constant: '<S321>/Constant'
      //   RelationalOperator: '<S321>/Compare'
      //   UnitDelay: '<S311>/Unit Delay'

      if (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_abci >
          CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT) {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_NORMAL_RATE;
      } else {
        rtb_UkYk1 = CONSTANT_DATA->AUX_RATE_LIMIT_CRACKPOINT_RATE;
      }

      // End of Switch: '<S311>/Switch1'
    } else {
      rtb_UkYk1 = 2048000;
    }

    // End of Switch: '<S311>/Switch2'

    // Product: '<S323>/delta rise limit' incorporates:
    //   SampleTimeMath: '<S323>/sample time'
    //
    //  About '<S323>/sample time':
    //   y = K where K = ( w * Ts )

    rtb_UkYk1 = mul_s32_hiSR(rtb_UkYk1, 1374389535, 5U);

    // Sum: '<S323>/Difference Inputs1' incorporates:
    //   DataTypeConversion: '<S311>/Data Type Conversion1'
    //   UnitDelay: '<S323>/Delay Input2'

    rtb_deltafalllimit = (int32_T)((int32_T)rtb_Switch1 -
      MX_Gtwy_Control_DWork.DelayInput2_DSTATE_gc5y);

    // Switch: '<S324>/Switch2' incorporates:
    //   RelationalOperator: '<S324>/LowerRelop1'
    //   RelationalOperator: '<S324>/UpperRelop'
    //   Switch: '<S324>/Switch'

    if (rtb_deltafalllimit > rtb_UkYk1) {
      rtb_deltafalllimit = rtb_UkYk1;
    } else {
      if (rtb_deltafalllimit < rtb_deltafalllimit_tmp) {
        // Switch: '<S324>/Switch'
        rtb_deltafalllimit = rtb_deltafalllimit_tmp;
      }
    }

    // End of Switch: '<S324>/Switch2'

    // Sum: '<S323>/Difference Inputs2' incorporates:
    //   UnitDelay: '<S323>/Delay Input2'

    rtb_UkYk1 = (int32_T)(rtb_deltafalllimit +
                          MX_Gtwy_Control_DWork.DelayInput2_DSTATE_gc5y);

    // DataTypeConversion: '<S311>/Data Type Conversion2'
    rtb_icmd_Base = (uint16_T)rtb_UkYk1;

    // Switch: '<S311>/Switch' incorporates:
    //   Constant: '<S311>/Constant2'
    //   Constant: '<S320>/Constant'
    //   RelationalOperator: '<S320>/Compare'

    if (CONSTANT_DATA->AUX_RATE_LIMIT_FUNCTION == NON_FUNCTIONAL) {
      rtb_Switch_dydk = rtb_Switch1;
    } else {
      rtb_Switch_dydk = rtb_icmd_Base;
    }

    // End of Switch: '<S311>/Switch'

    // Logic: '<S299>/Logical Operator' incorporates:
    //   Constant: '<S303>/Constant'
    //   Constant: '<S304>/Constant'
    //   RelationalOperator: '<S303>/Compare'
    //   RelationalOperator: '<S304>/Compare'

    rtb_LogicalOperator_cwje = ((cmd_AuxRelease == INACTIVE) && (state_AuxEnable
      == INACTIVE));

    // Outputs for Atomic SubSystem: '<S299>/hc_pair_control'
    MX_Gtwy__output_pair_ClosedLoop(rtb_Switch_allm, rtb_LogicalOperator_cwje,
      afbk_AuxBase, ifbk_AuxBase, MX_Gtwy_Control_B.RateTransition2_ad3t,
      state_Engine, MX_Gtwy_Control_B.RateTransition3_cdpa,
      ain_PrecisionReference, &MX_Gtwy_Control_B.hs_cmd_mvqz,
      &MX_Gtwy_Control_B.ls_cmd_jnku, &MX_Gtwy_Control_B.error_nvpj,
      &calc_ifbk_AuxBase, &MX_Gtwy_Control_B.state_Output_movq,
      &MX_Gtwy_Control_B.hc_pair_control, &MX_Gtwy_Control_DWork.hc_pair_control,
      CONSTANT_DATA->AUX_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->AUX_KP,
      CONSTANT_DATA->AUX_KI, CONSTANT_DATA->AUX_OVERCURRENT,
      CONSTANT_DATA->AUX_NON_ZERO_DUTY, CONSTANT_DATA->AUX_NON_ZERO_CURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_BATTERY, NON_FUNCTIONAL,
      CONSTANT_DATA->AUX_AFBK_GAIN, CONSTANT_DATA->AUX_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S299>/hc_pair_control'

    // SignalConversion: '<S299>/OutportBufferForerrorCC_AuxBase' incorporates:
    //   Inport: '<Root>/afbk_AuxBase'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_AuxBase'

    errorCC_AuxBase = MX_Gtwy_Control_B.error_nvpj;

    // Outputs for Atomic SubSystem: '<S299>/hc_pair_control1'
    MX_Gtwy__output_pair_ClosedLoop(rtb_Switch_dydk, rtb_LogicalOperator_cwje,
      afbk_AuxRod, ifbk_AuxRod, MX_Gtwy_Control_B.RateTransition2_ad3t,
      state_Engine, MX_Gtwy_Control_B.RateTransition3_cdpa,
      ain_PrecisionReference, &MX_Gtwy_Control_B.hs_cmd_cifl,
      &MX_Gtwy_Control_B.ls_cmd_mxkm, &MX_Gtwy_Control_B.error_lgr1,
      &calc_ifbk_AuxRod, &MX_Gtwy_Control_B.state_Output_akdd,
      &MX_Gtwy_Control_B.hc_pair_control1,
      &MX_Gtwy_Control_DWork.hc_pair_control1,
      CONSTANT_DATA->AUX_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->AUX_KP,
      CONSTANT_DATA->AUX_KI, CONSTANT_DATA->AUX_OVERCURRENT,
      CONSTANT_DATA->AUX_NON_ZERO_DUTY, CONSTANT_DATA->AUX_NON_ZERO_CURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->AUX_DEBOUNCE_SHORT_TO_BATTERY, NON_FUNCTIONAL,
      CONSTANT_DATA->AUX_AFBK_GAIN, CONSTANT_DATA->AUX_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S299>/hc_pair_control1'

    // SignalConversion: '<S299>/OutportBufferForerrorCC_AuxRod' incorporates:
    //   Inport: '<Root>/afbk_AuxRod'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_AuxRod'

    errorCC_AuxRod = MX_Gtwy_Control_B.error_lgr1;

    // SignalConversion: '<S299>/OutportBufferForhs_AuxBase'
    hs_AuxBase = MX_Gtwy_Control_B.hs_cmd_mvqz;

    // SignalConversion: '<S299>/OutportBufferForhs_AuxRod'
    hs_AuxRod = MX_Gtwy_Control_B.hs_cmd_cifl;

    // SignalConversion: '<S299>/OutportBufferForls_AuxBase'
    ls_AuxBase = MX_Gtwy_Control_B.ls_cmd_jnku;

    // SignalConversion: '<S299>/OutportBufferForls_AuxRod'
    ls_AuxRod = MX_Gtwy_Control_B.ls_cmd_mxkm;

    // SignalConversion: '<S299>/OutportBufferForstate_AuxBase'
    state_AuxBase = MX_Gtwy_Control_B.state_Output_movq;

    // SignalConversion: '<S299>/OutportBufferForstate_AuxRod'
    state_AuxRod = MX_Gtwy_Control_B.state_Output_akdd;

    // Update for UnitDelay: '<S310>/Unit Delay'
    MX_Gtwy_Control_DWork.UnitDelay_DSTATE = rtb_Switch_aazc;

    // Update for UnitDelay: '<S318>/Delay Input2'
    MX_Gtwy_Control_DWork.DelayInput2_DSTATE = rtb_sampletime;

    // Update for UnitDelay: '<S311>/Unit Delay'
    MX_Gtwy_Control_DWork.UnitDelay_DSTATE_abci = rtb_icmd_Base;

    // Update for UnitDelay: '<S323>/Delay Input2'
    MX_Gtwy_Control_DWork.DelayInput2_DSTATE_gc5y = rtb_UkYk1;
  } else {
    if (MX_Gtwy_Control_DWork.Aux_Hydraulics_MODE) {
      // Disable for Atomic SubSystem: '<S299>/hc_pair_control'
      output_pair_ClosedLoop_Disable(&MX_Gtwy_Control_B.error_nvpj,
        &MX_Gtwy_Control_B.hc_pair_control,
        &MX_Gtwy_Control_DWork.hc_pair_control);

      // End of Disable for SubSystem: '<S299>/hc_pair_control'

      // Disable for Atomic SubSystem: '<S299>/hc_pair_control1'
      output_pair_ClosedLoop_Disable(&MX_Gtwy_Control_B.error_lgr1,
        &MX_Gtwy_Control_B.hc_pair_control1,
        &MX_Gtwy_Control_DWork.hc_pair_control1);

      // End of Disable for SubSystem: '<S299>/hc_pair_control1'

      // Disable for Outport: '<S299>/hs_AuxBase'
      hs_AuxBase = ((uint16_T)0U);

      // Disable for Outport: '<S299>/ls_AuxBase'
      ls_AuxBase = false;

      // Disable for Outport: '<S299>/errorCC_AuxBase'
      errorCC_AuxBase = 0;

      // Disable for Outport: '<S299>/calc_ifbk_AuxBase'
      calc_ifbk_AuxBase = ((uint16_T)0U);

      // Disable for Outport: '<S299>/state_AuxBase'
      state_AuxBase = ((uint8_T)0U);

      // Disable for Outport: '<S299>/hs_AuxRod'
      hs_AuxRod = ((uint16_T)0U);

      // Disable for Outport: '<S299>/ls_AuxRod'
      ls_AuxRod = false;

      // Disable for Outport: '<S299>/errorCC_AuxRod'
      errorCC_AuxRod = 0;

      // Disable for Outport: '<S299>/calc_ifbk_AuxRod'
      calc_ifbk_AuxRod = ((uint16_T)0U);

      // Disable for Outport: '<S299>/state_AuxFlow'
      MX_Gtwy_Control_B.state_AuxFlow = ((uint8_T)0U);
      MX_Gtwy_Control_DWork.Aux_Hydraulics_MODE = false;
    }
  }

  // End of Logic: '<S281>/Logical Operator'
  // End of Outputs for SubSystem: '<S281>/Aux_Hydraulics'
}

// Function for Chart: '<S282>/Buzzer'
static void MX_Gtwy_Control_Depth_Check(void)
{
  boolean_T guard1 = false;
  boolean_T guard2 = false;

  // Inport: '<Root>/state_DepthBeep' incorporates:
  //   Inport: '<Root>/state_System'

  // During 'Depth_Check': '<S359>:98'
  guard1 = false;
  guard2 = false;
  if (((int32_T)((int32_T)state_DepthBeep & 0x80) != 0x80) || (state_DepthBeep ==
       BEEP_NONE) || (state_System != SYS_NORMAL)) {
    // Transition: '<S359>:100'
    guard1 = true;
  } else if ((state_Buzzer != BEEP_NONE) && (state_Buzzer != NO_BEEP) &&
             (state_System == SYS_NORMAL)) {
    // Transition: '<S359>:125'
    if (state_Buzzer == CONTINUOUS_BEEP) {
      // Transition: '<S359>:56'
      MX_Gtwy_Control_DWork.Beeps = 1U;

      // Exit Internal 'Depth_Check': '<S359>:98'
      if (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check ==
          MX_Gtwy_Control_IN_Grade_Zone) {
        // Exit 'Grade_Zone': '<S359>:107'
        dout_Buzzer = ((int32_T)INACTIVE != 0);
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
      } else {
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

        // Exit Internal 'Below_Grade_Zone': '<S359>:108'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

        // Exit Internal 'Warning_Zone': '<S359>:101'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
      }

      MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
        MX_Gtwy_Control_IN_Beep;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Beep = MX_Gtwy_Control_IN_On_lc3ft;

      // Entry 'On': '<S359>:55'
      dout_Buzzer = ((int32_T)ACTIVE != 0);
    } else {
      // Transition: '<S359>:69'
      if (state_Buzzer == SINGLE_SHORT_BEEP) {
        // Transition: '<S359>:12'
        MX_Gtwy_Control_DWork.Beeps = 1U;

        // Exit Internal 'Depth_Check': '<S359>:98'
        if (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check ==
            MX_Gtwy_Control_IN_Grade_Zone) {
          // Exit 'Grade_Zone': '<S359>:107'
          dout_Buzzer = ((int32_T)INACTIVE != 0);
          MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        } else {
          MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

          // Exit Internal 'Below_Grade_Zone': '<S359>:108'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

          // Exit Internal 'Warning_Zone': '<S359>:101'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        }

        MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_Beep;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Beep = MX_Gtwy_Control_IN_Single_On;
        MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry 'Single_On': '<S359>:136'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else {
        // Transition: '<S359>:70'
        if (state_Buzzer == DOUBLE_SHORT_BEEP) {
          // Transition: '<S359>:13'
          MX_Gtwy_Control_DWork.Beeps = 2U;
          guard2 = true;
        } else {
          // Transition: '<S359>:73'
          if (state_Buzzer == TRIPLE_SHORT_BEEP) {
            // Transition: '<S359>:18'
            MX_Gtwy_Control_DWork.Beeps = 3U;
            guard2 = true;
          } else {
            // Transition: '<S359>:95'
            if (state_Buzzer == QUAD_SHORT_BEEP) {
              // Transition: '<S359>:96'
              MX_Gtwy_Control_DWork.Beeps = 4U;
              guard2 = true;
            } else {
              // Transition: '<S359>:75'
              if (state_Buzzer == SINGLE_MEDIUM_BEEP) {
                // Transition: '<S359>:9'
                MX_Gtwy_Control_DWork.Beeps = 1U;

                // Exit Internal 'Depth_Check': '<S359>:98'
                if (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check ==
                    MX_Gtwy_Control_IN_Grade_Zone) {
                  // Exit 'Grade_Zone': '<S359>:107'
                  dout_Buzzer = ((int32_T)INACTIVE != 0);
                  MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
                    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
                } else {
                  MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
                    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

                  // Exit Internal 'Below_Grade_Zone': '<S359>:108'
                  MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
                    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

                  // Exit Internal 'Warning_Zone': '<S359>:101'
                  MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
                    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
                }

                MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
                  MX_Gtwy_Control_IN_Beep;
                MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
                  MX_Gtwy_Cont_IN_One_Beep_Medium;
                MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

                // Entry 'One_Beep_Medium': '<S359>:3'
                dout_Buzzer = ((int32_T)ACTIVE != 0);
              } else {
                // Transition: '<S359>:90'
                if (state_Buzzer == SINGLE_LONG_BEEP) {
                  // Transition: '<S359>:89'
                  MX_Gtwy_Control_DWork.Beeps = 1U;

                  // Exit Internal 'Depth_Check': '<S359>:98'
                  if (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check ==
                      MX_Gtwy_Control_IN_Grade_Zone) {
                    // Exit 'Grade_Zone': '<S359>:107'
                    dout_Buzzer = ((int32_T)INACTIVE != 0);
                    MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
                      MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
                  } else {
                    MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
                      MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

                    // Exit Internal 'Below_Grade_Zone': '<S359>:108'
                    MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
                      MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

                    // Exit Internal 'Warning_Zone': '<S359>:101'
                    MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
                      MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
                  }

                  MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
                    MX_Gtwy_Control_IN_Beep;
                  MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
                    MX_Gtwy_Contro_IN_One_Beep_Long;
                  MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

                  // Entry 'One_Beep_Long': '<S359>:88'
                  dout_Buzzer = ((int32_T)ACTIVE != 0);
                } else {
                  // Transition: '<S359>:78'
                  guard1 = true;
                }
              }
            }
          }
        }
      }
    }
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check) {
     case MX_Gtwy_Con_IN_Below_Grade_Zone:
      // During 'Below_Grade_Zone': '<S359>:108'
      if (state_DepthBeep == DC_WARNING_BEEP) {
        // Transition: '<S359>:121'
        // Exit Internal 'Below_Grade_Zone': '<S359>:108'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_Control_IN_Warning_Zone;
        MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry Internal 'Warning_Zone': '<S359>:101'
        // Transition: '<S359>:102'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_Control_IN_On_lc3f;
        MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny = 0U;

        // Entry 'On': '<S359>:104'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (state_DepthBeep == DC_GRADE_BEEP) {
        // Transition: '<S359>:119'
        // Exit Internal 'Below_Grade_Zone': '<S359>:108'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_Control_IN_Grade_Zone;

        // Entry 'Grade_Zone': '<S359>:107'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone ==
                 MX_Gtwy_Control_IN_Off_fwwp) {
        // During 'Off': '<S359>:113'
        if (MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >=
            CONSTANT_DATA->CHIRP_OFF_LENGTH) {
          // Transition: '<S359>:110'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
            MX_Gtwy_Control_IN_On_lc3f;
          MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry 'On': '<S359>:112'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        }
      } else {
        // During 'On': '<S359>:112'
        if (MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >=
            CONSTANT_DATA->CHIRP_ON_LENGTH) {
          // Transition: '<S359>:111'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
            MX_Gtwy_Control_IN_Off_fwwp;
          MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry 'Off': '<S359>:113'
          dout_Buzzer = ((int32_T)INACTIVE != 0);
        }
      }
      break;

     case MX_Gtwy_Control_IN_Grade_Zone:
      // During 'Grade_Zone': '<S359>:107'
      if (state_DepthBeep == DC_WARNING_BEEP) {
        // Transition: '<S359>:117'
        // Exit 'Grade_Zone': '<S359>:107'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_Control_IN_Warning_Zone;
        MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry Internal 'Warning_Zone': '<S359>:101'
        // Transition: '<S359>:102'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_Control_IN_On_lc3f;
        MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny = 0U;

        // Entry 'On': '<S359>:104'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else {
        if (state_DepthBeep == DC_BELOW_GRADE_BEEP) {
          // Transition: '<S359>:118'
          // Exit 'Grade_Zone': '<S359>:107'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
            MX_Gtwy_Con_IN_Below_Grade_Zone;

          // Entry Internal 'Below_Grade_Zone': '<S359>:108'
          // Transition: '<S359>:109'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
            MX_Gtwy_Control_IN_On_lc3f;
          MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry 'On': '<S359>:112'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        }
      }
      break;

     default:
      // Inport: '<Root>/delay_DepthBeep'
      // During 'Warning_Zone': '<S359>:101'
      if (MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >= delay_DepthBeep) {
        // Transition: '<S359>:106'
        // Exit Internal 'Warning_Zone': '<S359>:101'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_Control_IN_Warning_Zone;
        MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry Internal 'Warning_Zone': '<S359>:101'
        // Transition: '<S359>:102'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_Control_IN_On_lc3f;
        MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny = 0U;

        // Entry 'On': '<S359>:104'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (state_DepthBeep == DC_GRADE_BEEP) {
        // Transition: '<S359>:115'
        // Exit Internal 'Warning_Zone': '<S359>:101'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_Control_IN_Grade_Zone;

        // Entry 'Grade_Zone': '<S359>:107'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if (state_DepthBeep == DC_BELOW_GRADE_BEEP) {
        // Transition: '<S359>:116'
        // Exit Internal 'Warning_Zone': '<S359>:101'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
          MX_Gtwy_Con_IN_Below_Grade_Zone;

        // Entry Internal 'Below_Grade_Zone': '<S359>:108'
        // Transition: '<S359>:109'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
          MX_Gtwy_Control_IN_On_lc3f;
        MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

        // Entry 'On': '<S359>:112'
        dout_Buzzer = ((int32_T)ACTIVE != 0);
      } else if ((MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone ==
                  MX_Gtwy_Control_IN_Off_fwwp) ||
                 (!(MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny >=
                    CONSTANT_DATA->WARNING_BEEP_LENGTH))) {
        // During 'Off': '<S359>:105'
      } else {
        // During 'On': '<S359>:104'
        // Transition: '<S359>:103'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
          MX_Gtwy_Control_IN_Off_fwwp;

        // Entry 'Off': '<S359>:105'
        dout_Buzzer = ((int32_T)INACTIVE != 0);
      }

      // End of Inport: '<Root>/delay_DepthBeep'
      break;
    }
  }

  if (guard2) {
    // Exit Internal 'Depth_Check': '<S359>:98'
    if (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check ==
        MX_Gtwy_Control_IN_Grade_Zone) {
      // Exit 'Grade_Zone': '<S359>:107'
      dout_Buzzer = ((int32_T)INACTIVE != 0);
      MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
    } else {
      MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Below_Grade_Zone': '<S359>:108'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Warning_Zone': '<S359>:101'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
    }

    MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
      MX_Gtwy_Control_IN_Beep;
    MX_Gtwy_Control_DWork.bitsForTID0.is_Beep = MX_Gtwy_Control_IN_Multiple_On;
    MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

    // Entry 'Multiple_On': '<S359>:4'
    dout_Buzzer = ((int32_T)ACTIVE != 0);
  }

  if (guard1) {
    // Exit Internal 'Depth_Check': '<S359>:98'
    if (MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check ==
        MX_Gtwy_Control_IN_Grade_Zone) {
      // Exit 'Grade_Zone': '<S359>:107'
      dout_Buzzer = ((int32_T)INACTIVE != 0);
      MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
    } else {
      MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Below_Grade_Zone': '<S359>:108'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;

      // Exit Internal 'Warning_Zone': '<S359>:101'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
    }

    MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
      MX_Gtwy_Control_IN_No_Beep;

    // Entry 'No_Beep': '<S359>:1'
    dout_Buzzer = ((int32_T)INACTIVE != 0);
    state_Buzzer = NO_BEEP;
    MX_Gtwy_Control_DWork.Beeps = 0U;
  }

  // End of Inport: '<Root>/state_DepthBeep'
}

// System initialize for atomic system: '<S4>/Buzzer'
void MX_Gtwy_Control_Buzzer_Init(void)
{
  // SystemInitialize for Chart: '<S282>/Buzzer'
  MX_Gtwy_Control_DWork.bitsForTID0.is_Beep = MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Below_Grade_Zone =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;
  MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c65_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
  MX_Gtwy_Control_DWork.Beeps = 0U;
  dout_Buzzer = false;
}

// Output and update for atomic system: '<S4>/Buzzer'
void MX_Gtwy_Control_Buzzer(void)
{
  boolean_T guard1 = false;

  // Chart: '<S282>/Buzzer' incorporates:
  //   Inport: '<Root>/state_DepthBeep'
  //   Inport: '<Root>/state_System'

  // Gateway: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
  if ((uint32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 < 65535U) {
    MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = (uint16_T)(int32_T)((int32_T)
      MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 + 1);
  }

  if ((uint32_T)MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny < 255U) {
    MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny = (uint8_T)(int32_T)((int32_T)
      MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny + 1);
  }

  // During: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID0.is_active_c65_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
    MX_Gtwy_Control_DWork.bitsForTID0.is_active_c65_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Buzzer/Buzzer
    // Transition: '<S359>:83'
    MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
      MX_Gtwy_Control_IN_No_Beep;

    // Entry 'No_Beep': '<S359>:1'
    dout_Buzzer = ((int32_T)INACTIVE != 0);
    state_Buzzer = NO_BEEP;
    MX_Gtwy_Control_DWork.Beeps = 0U;
  } else {
    guard1 = false;
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_Beep:
      // During 'Beep': '<S359>:71'
      if ((state_Buzzer == NO_BEEP) || (!((int32_T)MX_Gtwy_Control_DWork.Beeps
            != 0)) || (state_System != SYS_NORMAL)) {
        // Transition: '<S359>:57'
        // Exit Internal 'Beep': '<S359>:71'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_eiu5;
        MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_No_Beep;

        // Entry 'No_Beep': '<S359>:1'
        dout_Buzzer = ((int32_T)INACTIVE != 0);
        state_Buzzer = NO_BEEP;
        MX_Gtwy_Control_DWork.Beeps = 0U;
      } else {
        switch (MX_Gtwy_Control_DWork.bitsForTID0.is_Beep) {
         case MX_Gtwy_Control_IN_Brief_Off:
          // During 'Brief_Off': '<S359>:58'
          if ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >= 10) {
            // Transition: '<S359>:59'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
              MX_Gtwy_Control_IN_Multiple_On;
            MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Multiple_On': '<S359>:4'
            dout_Buzzer = ((int32_T)ACTIVE != 0);
          }
          break;

         case MX_Gtwy_Control_IN_Multiple_Off:
          // During 'Multiple_Off': '<S359>:5'
          if ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >= 20) {
            // Transition: '<S359>:16'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
              MX_Gtwy_Control_IN_Multiple_On;
            MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Multiple_On': '<S359>:4'
            dout_Buzzer = ((int32_T)ACTIVE != 0);
          }
          break;

         case MX_Gtwy_Control_IN_Multiple_On:
          // During 'Multiple_On': '<S359>:4'
          if ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >= 10) {
            // Transition: '<S359>:15'
            MX_Gtwy_Control_DWork.Beeps = (uint8_T)(int32_T)((int32_T)
              MX_Gtwy_Control_DWork.Beeps - 1);
            MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
              MX_Gtwy_Control_IN_Multiple_Off;
            MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Multiple_Off': '<S359>:5'
            dout_Buzzer = ((int32_T)INACTIVE != 0);
          }
          break;

         case MX_Gtwy_Control_IN_On_lc3ft:
          // During 'On': '<S359>:55'
          break;

         case MX_Gtwy_Contro_IN_One_Beep_Long:
          // During 'One_Beep_Long': '<S359>:88'
          if (MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >=
              MX_Gtwy_Control_FIFTEEN_SECONDS) {
            MX_Gtwy_Control_DWork.Beeps = 0U;
          }
          break;

         case MX_Gtwy_Cont_IN_One_Beep_Medium:
          // During 'One_Beep_Medium': '<S359>:3'
          if ((state_Buzzer == TRIPLE_SHORT_BEEP) && ((int32_T)
               MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >= 50)) {
            // Transition: '<S359>:27'
            MX_Gtwy_Control_DWork.Beeps = 3U;
            MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
              MX_Gtwy_Control_IN_Brief_Off;
            MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Brief_Off': '<S359>:58'
            dout_Buzzer = ((int32_T)INACTIVE != 0);
          } else {
            if (MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >=
                MX_Gtwy_Control_ONE_SECOND_ezbk) {
              MX_Gtwy_Control_DWork.Beeps = 0U;
            }
          }
          break;

         case MX_Gtwy_Control_IN_Single_Off:
          // During 'Single_Off': '<S359>:137'
          break;

         default:
          // During 'Single_On': '<S359>:136'
          if ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 >= 10) {
            // Transition: '<S359>:138'
            MX_Gtwy_Control_DWork.Beeps = (uint8_T)(int32_T)((int32_T)
              MX_Gtwy_Control_DWork.Beeps - 1);
            MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
              MX_Gtwy_Control_IN_Single_Off;

            // Entry 'Single_Off': '<S359>:137'
            dout_Buzzer = ((int32_T)INACTIVE != 0);
          } else {
            if (state_Buzzer == TRIPLE_SHORT_BEEP) {
              // Transition: '<S359>:139'
              MX_Gtwy_Control_DWork.Beeps = 3U;
              MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
                MX_Gtwy_Control_IN_Multiple_On;
              MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

              // Entry 'Multiple_On': '<S359>:4'
              dout_Buzzer = ((int32_T)ACTIVE != 0);
            }
          }
          break;
        }
      }
      break;

     case MX_Gtwy_Control_IN_Depth_Check:
      MX_Gtwy_Control_Depth_Check();
      break;

     default:
      // During 'No_Beep': '<S359>:1'
      if ((state_Buzzer != BEEP_NONE) && (state_Buzzer != NO_BEEP) &&
          (state_System == SYS_NORMAL)) {
        // Transition: '<S359>:66'
        if (state_Buzzer == CONTINUOUS_BEEP) {
          // Transition: '<S359>:56'
          MX_Gtwy_Control_DWork.Beeps = 1U;
          MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_Beep;
          MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
            MX_Gtwy_Control_IN_On_lc3ft;

          // Entry 'On': '<S359>:55'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        } else {
          // Transition: '<S359>:69'
          if (state_Buzzer == SINGLE_SHORT_BEEP) {
            // Transition: '<S359>:12'
            MX_Gtwy_Control_DWork.Beeps = 1U;
            MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
              MX_Gtwy_Control_IN_Beep;
            MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
              MX_Gtwy_Control_IN_Single_On;
            MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

            // Entry 'Single_On': '<S359>:136'
            dout_Buzzer = ((int32_T)ACTIVE != 0);
          } else {
            // Transition: '<S359>:70'
            if (state_Buzzer == DOUBLE_SHORT_BEEP) {
              // Transition: '<S359>:13'
              MX_Gtwy_Control_DWork.Beeps = 2U;
              guard1 = true;
            } else {
              // Transition: '<S359>:73'
              if (state_Buzzer == TRIPLE_SHORT_BEEP) {
                // Transition: '<S359>:18'
                MX_Gtwy_Control_DWork.Beeps = 3U;
                guard1 = true;
              } else {
                // Transition: '<S359>:95'
                if (state_Buzzer == QUAD_SHORT_BEEP) {
                  // Transition: '<S359>:96'
                  MX_Gtwy_Control_DWork.Beeps = 4U;
                  guard1 = true;
                } else {
                  // Transition: '<S359>:75'
                  if (state_Buzzer == SINGLE_MEDIUM_BEEP) {
                    // Transition: '<S359>:9'
                    MX_Gtwy_Control_DWork.Beeps = 1U;
                    MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
                      MX_Gtwy_Control_IN_Beep;
                    MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
                      MX_Gtwy_Cont_IN_One_Beep_Medium;
                    MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

                    // Entry 'One_Beep_Medium': '<S359>:3'
                    dout_Buzzer = ((int32_T)ACTIVE != 0);
                  } else {
                    // Transition: '<S359>:90'
                    if (state_Buzzer == SINGLE_LONG_BEEP) {
                      // Transition: '<S359>:89'
                      MX_Gtwy_Control_DWork.Beeps = 1U;
                      MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
                        MX_Gtwy_Control_IN_Beep;
                      MX_Gtwy_Control_DWork.bitsForTID0.is_Beep =
                        MX_Gtwy_Contro_IN_One_Beep_Long;
                      MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

                      // Entry 'One_Beep_Long': '<S359>:88'
                      dout_Buzzer = ((int32_T)ACTIVE != 0);
                    } else {
                      // Transition: '<S359>:78'
                      MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
                        MX_Gtwy_Control_IN_No_Beep;

                      // Entry 'No_Beep': '<S359>:1'
                      dout_Buzzer = ((int32_T)INACTIVE != 0);
                      state_Buzzer = NO_BEEP;
                      MX_Gtwy_Control_DWork.Beeps = 0U;
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if ((CONSTANT_DATA->DEPTH_CHECK_FUNCTION != NON_FUNCTIONAL) && ((int32_T)
             ((int32_T)state_DepthBeep & 0x80) == 0x80) && (state_DepthBeep !=
             BEEP_NONE) && (state_System == SYS_NORMAL)) {
          // Transition: '<S359>:99'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_Depth_Check;

          // Entry Internal 'Depth_Check': '<S359>:98'
          // Transition: '<S359>:114'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Depth_Check =
            MX_Gtwy_Control_IN_Warning_Zone;
          MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

          // Entry Internal 'Warning_Zone': '<S359>:101'
          // Transition: '<S359>:102'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Warning_Zone =
            MX_Gtwy_Control_IN_On_lc3f;
          MX_Gtwy_Control_DWork.temporalCounter_i2_b2ny = 0U;

          // Entry 'On': '<S359>:104'
          dout_Buzzer = ((int32_T)ACTIVE != 0);
        }
      }
      break;
    }

    if (guard1) {
      MX_Gtwy_Control_DWork.bitsForTID0.is_c65_MX_Gtwy_Control =
        MX_Gtwy_Control_IN_Beep;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Beep = MX_Gtwy_Control_IN_Multiple_On;
      MX_Gtwy_Control_DWork.temporalCounter_i1_omi3 = 0U;

      // Entry 'Multiple_On': '<S359>:4'
      dout_Buzzer = ((int32_T)ACTIVE != 0);
    }
  }

  // End of Chart: '<S282>/Buzzer'
}

// System initialize for atomic system: '<S4>/Diverter'
void MX_Gtwy_Control_Diverter_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S283>/Diverter'
  // InitializeConditions for UnitDelay: '<S364>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh = ((uint8_T)0U);

  // SystemInitialize for Chart: '<S364>/Diverter'
  MX_Gtwy_Control_DWork.bitsForTID0.is_EMEA_CONTROLS_lam2 =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h;
  MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h;
  MX_Gtwy_Control_DWork.temporalCounter_i1_lihp = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c61_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c61_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h;
  MX_Gtwy_Control_DWork.bitsForTID0.switch_hold = false;
  MX_Gtwy_Control_B.cmd_Diverter_hj33 = false;

  // SystemInitialize for Atomic SubSystem: '<S364>/output_pair_open_loop'
  MX_Gt_output_pair_OpenLoop_Init(&MX_Gtwy_Control_B.hs_cmd_evjd,
    &MX_Gtwy_Control_B.ls_cmd_obnv, &MX_Gtwy_Control_B.state_Output_h0ge,
    &MX_Gtwy_Control_B.output_pair_open_loop,
    &MX_Gtwy_Control_DWork.output_pair_open_loop);

  // End of SystemInitialize for SubSystem: '<S364>/output_pair_open_loop'

  // End of SystemInitialize for SubSystem: '<S283>/Diverter'
}

// Output and update for atomic system: '<S4>/Diverter'
void MX_Gtwy_Control_Diverter(void)
{
  boolean_T rtb_Compare_lw3g;

  // Outputs for Enabled SubSystem: '<S283>/Diverter' incorporates:
  //   EnablePort: '<S364>/Enable'

  // Logic: '<S283>/Logical Operator' incorporates:
  //   Constant: '<S283>/Constant'
  //   Constant: '<S283>/Constant1'
  //   Constant: '<S283>/Constant2'
  //   Constant: '<S360>/Constant'
  //   Constant: '<S361>/Constant'
  //   Constant: '<S362>/Constant'
  //   Constant: '<S363>/Constant'
  //   Inport: '<Root>/afbk_Diverter'
  //   Inport: '<Root>/ain_PrecisionReference'
  //   Inport: '<Root>/ifbk_Diverter'
  //   Inport: '<Root>/state_System'
  //   Logic: '<S283>/Logical Operator1'
  //   RelationalOperator: '<S360>/Compare'
  //   RelationalOperator: '<S361>/Compare'
  //   RelationalOperator: '<S362>/Compare'
  //   RelationalOperator: '<S363>/Compare'

  if ((state_System == SYS_NORMAL) && ((CONSTANT_DATA->SECOND_AUX_FUNCTION !=
        NON_FUNCTIONAL) || (CONSTANT_DATA->EMEA_CONTROLS_OPTION_A !=
        NON_FUNCTIONAL) || (CONSTANT_DATA->EMEA_CONTROLS_OPTION_C !=
        NON_FUNCTIONAL))) {
    if (!MX_Gtwy_Control_DWork.Diverter_MODE) {
      // InitializeConditions for UnitDelay: '<S364>/Unit Delay'
      MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh = ((uint8_T)0U);

      // SystemReset for Chart: '<S364>/Diverter'
      MX_Gtwy_Control_DWork.bitsForTID0.is_EMEA_CONTROLS_lam2 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h;
      MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h;
      MX_Gtwy_Control_DWork.temporalCounter_i1_lihp = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c61_MX_Gtwy_Control = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_c61_MX_Gtwy_Control =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_fi0h;
      MX_Gtwy_Control_DWork.bitsForTID0.switch_hold = false;
      MX_Gtwy_Control_B.cmd_Diverter_hj33 = false;

      // SystemReset for Atomic SubSystem: '<S364>/output_pair_open_loop'
      MX_G_output_pair_OpenLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_evjd,
        &MX_Gtwy_Control_B.ls_cmd_obnv, &MX_Gtwy_Control_B.state_Output_h0ge,
        &MX_Gtwy_Control_B.output_pair_open_loop,
        &MX_Gtwy_Control_DWork.output_pair_open_loop);

      // End of SystemReset for SubSystem: '<S364>/output_pair_open_loop'
      MX_Gtwy_Control_DWork.Diverter_MODE = true;
    }

    // RelationalOperator: '<S365>/Compare' incorporates:
    //   Constant: '<S365>/Constant'

    rtb_Compare_lw3g = (state_Console != ACTIVE);

    // Chart: '<S364>/Diverter' incorporates:
    //   Inport: '<Root>/din_SecondAuxSw'
    //   UnitDelay: '<S364>/Unit Delay'

    // Gateway: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
    if ((uint32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_lihp < 65535U) {
      MX_Gtwy_Control_DWork.temporalCounter_i1_lihp = (uint16_T)(int32_T)
        ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_lihp + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
    if ((uint32_T)
        MX_Gtwy_Control_DWork.bitsForTID0.is_active_c61_MX_Gtwy_Control == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c61_MX_Gtwy_Control = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Diverter/Diverter/Diverter
      // Transition: '<S366>:121'
      MX_Gtwy_Control_DWork.bitsForTID0.is_c61_MX_Gtwy_Control =
        MX_Gtwy__IN_NON_FUNCTIONAL_menq;

      // Entry 'NON_FUNCTIONAL': '<S366>:117'
      MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
    } else {
      switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c61_MX_Gtwy_Control) {
       case MX_Gtwy_Contro_IN_EMEA_CONTROLS:
        // During 'EMEA_CONTROLS': '<S366>:100'
        if (MX_Gtwy_Control_DWork.bitsForTID0.is_EMEA_CONTROLS_lam2 ==
            MX_Gtwy_Control_IN_ACTIVE_azwi) {
          // During 'ACTIVE': '<S366>:123'
          if ((mode_LeftControl != MODE_LEFT_AUX2) ||
              (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh != ACTIVE)) {
            // Transition: '<S366>:125'
            MX_Gtwy_Control_DWork.bitsForTID0.is_EMEA_CONTROLS_lam2 =
              MX_Gtwy_Contro_IN_INACTIVE_cstq;

            // Entry 'INACTIVE': '<S366>:112'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          }
        } else {
          // During 'INACTIVE': '<S366>:112'
          if ((mode_LeftControl == MODE_LEFT_AUX2) &&
              (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh == INACTIVE)) {
            // Transition: '<S366>:124'
            MX_Gtwy_Control_DWork.bitsForTID0.is_EMEA_CONTROLS_lam2 =
              MX_Gtwy_Control_IN_ACTIVE_azwi;

            // Entry 'ACTIVE': '<S366>:123'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
          }
        }
        break;

       case MX_Gtwy__IN_NON_FUNCTIONAL_menq:
        // During 'NON_FUNCTIONAL': '<S366>:117'
        if ((CONSTANT_DATA->EMEA_CONTROLS_OPTION_A != NON_FUNCTIONAL) ||
            (CONSTANT_DATA->EMEA_CONTROLS_OPTION_C != NON_FUNCTIONAL)) {
          // Transition: '<S366>:120'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c61_MX_Gtwy_Control =
            MX_Gtwy_Contro_IN_EMEA_CONTROLS;

          // Entry Internal 'EMEA_CONTROLS': '<S366>:100'
          // Transition: '<S366>:101'
          MX_Gtwy_Control_DWork.bitsForTID0.is_EMEA_CONTROLS_lam2 =
            MX_Gtwy_Contro_IN_INACTIVE_cstq;

          // Entry 'INACTIVE': '<S366>:112'
          MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
        } else {
          if (CONSTANT_DATA->SECOND_AUX_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S366>:122'
            MX_Gtwy_Control_DWork.bitsForTID0.is_c61_MX_Gtwy_Control =
              MX_Gtwy_Contro_IN_SECOND_AUX_NA;

            // Entry Internal 'SECOND_AUX_NA': '<S366>:99'
            // Transition: '<S366>:78'
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Contro_IN_InactiveCheck;

            // Entry 'InactiveCheck': '<S366>:88'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          }
        }
        break;

       default:
        // During 'SECOND_AUX_NA': '<S366>:99'
        switch (MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA) {
         case MX_Gtwy_Control_IN_Active_hlsv:
          // During 'Active': '<S366>:80'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S366>:95'
            MX_Gtwy_Control_DWork.bitsForTID0.switch_hold = ((int32_T)INACTIVE
              != 0);
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Control_IN_Active_hlsv;

            // Entry 'Active': '<S366>:80'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
          } else if ((din_SecondAuxSw == (int32_T)ACTIVE) &&
                     (MX_Gtwy_Control_DWork.bitsForTID0.switch_hold == (int32_T)
                      INACTIVE)) {
            // Transition: '<S366>:85'
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Con_IN_DebounceInactive;
            MX_Gtwy_Control_DWork.temporalCounter_i1_lihp = 0U;
          } else {
            if ((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh != ACTIVE) &&
                (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh != INACTIVE)) {
              // Transition: '<S366>:92'
              MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
                MX_Gtwy_Contro_IN_Inactive_lhek;

              // Entry 'Inactive': '<S366>:77'
              MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
            }
          }
          break;

         case MX_Gtwy_Contr_IN_DebounceActive:
          // During 'DebounceActive': '<S366>:79'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S366>:82'
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Contro_IN_Inactive_lhek;

            // Entry 'Inactive': '<S366>:77'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          } else {
            if (MX_Gtwy_Control_DWork.temporalCounter_i1_lihp >=
                CONSTANT_DATA->SECOND_AUX_SWITCH_DEBOUNCE) {
              // Transition: '<S366>:83'
              state_Buzzer = SINGLE_SHORT_BEEP;
              MX_Gtwy_Control_DWork.bitsForTID0.switch_hold = ((int32_T)ACTIVE
                != 0);
              MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
                MX_Gtwy_Control_IN_Active_hlsv;

              // Entry 'Active': '<S366>:80'
              MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
            }
          }
          break;

         case MX_Gtwy_Con_IN_DebounceInactive:
          // During 'DebounceInactive': '<S366>:84'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S366>:86'
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Control_IN_Active_hlsv;

            // Entry 'Active': '<S366>:80'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)ACTIVE != 0);
          } else {
            if (MX_Gtwy_Control_DWork.temporalCounter_i1_lihp >=
                CONSTANT_DATA->SECOND_AUX_SWITCH_DEBOUNCE) {
              // Transition: '<S366>:87'
              state_Buzzer = SINGLE_SHORT_BEEP;
              MX_Gtwy_Control_DWork.bitsForTID0.switch_hold = ((int32_T)ACTIVE
                != 0);
              MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
                MX_Gtwy_Contro_IN_Inactive_lhek;

              // Entry 'Inactive': '<S366>:77'
              MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
            }
          }
          break;

         case MX_Gtwy_Contro_IN_Inactive_lhek:
          // During 'Inactive': '<S366>:77'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S366>:96'
            MX_Gtwy_Control_DWork.bitsForTID0.switch_hold = ((int32_T)INACTIVE
              != 0);
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Contro_IN_Inactive_lhek;

            // Entry 'Inactive': '<S366>:77'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          } else {
            if ((din_SecondAuxSw == (int32_T)ACTIVE) &&
                (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh == INACTIVE) &&
                (MX_Gtwy_Control_DWork.bitsForTID0.switch_hold == (int32_T)
                 INACTIVE)) {
              // Transition: '<S366>:81'
              MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
                MX_Gtwy_Contr_IN_DebounceActive;
              MX_Gtwy_Control_DWork.temporalCounter_i1_lihp = 0U;
            }
          }
          break;

         default:
          // During 'InactiveCheck': '<S366>:88'
          if (din_SecondAuxSw == (int32_T)INACTIVE) {
            // Transition: '<S366>:89'
            MX_Gtwy_Control_DWork.bitsForTID0.is_SECOND_AUX_NA =
              MX_Gtwy_Contro_IN_Inactive_lhek;

            // Entry 'Inactive': '<S366>:77'
            MX_Gtwy_Control_B.cmd_Diverter_hj33 = ((int32_T)INACTIVE != 0);
          }
          break;
        }
        break;
      }
    }

    // End of Chart: '<S364>/Diverter'

    // SignalConversion: '<S364>/OutportBufferForcmd_Diverter'
    cmd_Diverter = MX_Gtwy_Control_B.cmd_Diverter_hj33;

    // Outputs for Atomic SubSystem: '<S364>/output_pair_open_loop'
    MX_Gtwy_Co_output_pair_OpenLoop(MX_Gtwy_Control_B.cmd_Diverter_hj33,
      rtb_Compare_lw3g, state_Engine, afbk_Diverter, ifbk_Diverter,
      MX_Gtwy_Control_B.RateTransition46_p0ur,
      MX_Gtwy_Control_B.RateTransition45, ain_PrecisionReference,
      &MX_Gtwy_Control_B.hs_cmd_evjd, &MX_Gtwy_Control_B.ls_cmd_obnv,
      &MX_Gtwy_Control_B.state_Output_h0ge,
      &MX_Gtwy_Control_B.output_pair_open_loop,
      &MX_Gtwy_Control_DWork.output_pair_open_loop,
      CONSTANT_DATA->SECOND_AUX_MAX_VOLTS,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->SECOND_AUX_OVERCURRENT,
      CONSTANT_DATA->SECOND_AUX_NON_ZERO_DUTY,
      CONSTANT_DATA->SECOND_AUX_NON_ZERO_CURRENT,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->SECOND_AUX_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->SECOND_AUX_FEEDBACK_FUNCTION,
      CONSTANT_DATA->SECOND_AUX_AFBK_GAIN, CONSTANT_DATA->SECOND_AUX_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S364>/output_pair_open_loop'

    // SignalConversion: '<S364>/OutportBufferForhs_Diverter' incorporates:
    //   Inport: '<Root>/afbk_Diverter'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_Diverter'

    hs_Diverter = MX_Gtwy_Control_B.hs_cmd_evjd;

    // SignalConversion: '<S364>/OutportBufferForls_Diverter'
    ls_Diverter = MX_Gtwy_Control_B.ls_cmd_obnv;

    // SignalConversion: '<S364>/OutportBufferForstate_Diverter'
    state_Diverter = MX_Gtwy_Control_B.state_Output_h0ge;

    // Update for UnitDelay: '<S364>/Unit Delay'
    MX_Gtwy_Control_DWork.UnitDelay_DSTATE_igsh =
      MX_Gtwy_Control_B.state_Output_h0ge;
  } else {
    if (MX_Gtwy_Control_DWork.Diverter_MODE) {
      // Disable for Outport: '<S364>/state_Diverter'
      state_Diverter = ((uint8_T)0U);

      // Disable for Outport: '<S364>/hs_Diverter'
      hs_Diverter = ((uint16_T)0U);

      // Disable for Outport: '<S364>/ls_Diverter'
      ls_Diverter = false;

      // Disable for Outport: '<S364>/cmd_Diverter'
      cmd_Diverter = false;
      MX_Gtwy_Control_DWork.Diverter_MODE = false;
    }
  }

  // End of Logic: '<S283>/Logical Operator'
  // End of Outputs for SubSystem: '<S283>/Diverter'
}

// System initialize for atomic system: '<S4>/Dump_Valve'
void MX_Gtwy_Control_Dump_Valve_Init(void)
{
  uint16_T rtb_icmd_DumpValve;

  // SystemInitialize for Enabled SubSystem: '<S284>/Dump_Valve'
  // SystemInitialize for Chart: '<S384>/Dump_Valve'
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c10_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c10_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_lqez;
  rtb_icmd_DumpValve = 0U;

  // SystemInitialize for Atomic SubSystem: '<S384>/hc_pair_control'
  MX__output_pair_ClosedLoop_Init(&MX_Gtwy_Control_B.hs_cmd_cnig,
    &MX_Gtwy_Control_B.ls_cmd_fvfb, &MX_Gtwy_Control_B.state_Output_au4i,
    &MX_Gtwy_Control_B.hc_pair_control_mjt1,
    &MX_Gtwy_Control_DWork.hc_pair_control_mjt1);

  // End of SystemInitialize for SubSystem: '<S384>/hc_pair_control'

  // End of SystemInitialize for SubSystem: '<S284>/Dump_Valve'
}

// Output and update for atomic system: '<S4>/Dump_Valve'
void MX_Gtwy_Control_Dump_Valve(void)
{
  uint16_T rtb_icmd_DumpValve;
  boolean_T rtb_Compare_mjfo;

  // Outputs for Enabled SubSystem: '<S284>/Dump_Valve' incorporates:
  //   EnablePort: '<S384>/Enable'

  // Logic: '<S284>/Logical Operator' incorporates:
  //   Constant: '<S284>/Constant'
  //   Constant: '<S382>/Constant'
  //   Constant: '<S383>/Constant'
  //   Inport: '<Root>/afbk_DumpValve'
  //   Inport: '<Root>/ain_PrecisionReference'
  //   Inport: '<Root>/ifbk_DumpValve'
  //   Inport: '<Root>/state_System'
  //   RelationalOperator: '<S382>/Compare'
  //   RelationalOperator: '<S383>/Compare'

  if ((state_System == SYS_NORMAL) && (CONSTANT_DATA->DUMP_VALVE_FUNCTION !=
       NON_FUNCTIONAL)) {
    if (!MX_Gtwy_Control_DWork.Dump_Valve_MODE) {
      // SystemReset for Chart: '<S384>/Dump_Valve'
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c10_MX_Gtwy_Control = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_c10_MX_Gtwy_Control =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_lqez;
      rtb_icmd_DumpValve = 0U;

      // SystemReset for Atomic SubSystem: '<S384>/hc_pair_control'
      MX_output_pair_ClosedLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_cnig,
        &MX_Gtwy_Control_B.ls_cmd_fvfb, &MX_Gtwy_Control_B.state_Output_au4i,
        &MX_Gtwy_Control_B.hc_pair_control_mjt1,
        &MX_Gtwy_Control_DWork.hc_pair_control_mjt1);

      // End of SystemReset for SubSystem: '<S384>/hc_pair_control'
      MX_Gtwy_Control_DWork.Dump_Valve_MODE = true;
    }

    // RelationalOperator: '<S385>/Compare' incorporates:
    //   Constant: '<S385>/Constant'

    rtb_Compare_mjfo = (aux_Flow != ((uint8_T)2U));

    // Chart: '<S384>/Dump_Valve'
    // Gateway: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve
    // During: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve
    if ((uint32_T)
        MX_Gtwy_Control_DWork.bitsForTID0.is_active_c10_MX_Gtwy_Control == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c10_MX_Gtwy_Control = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Dump_Valve/Dump_Valve/Dump_Valve 
      // Transition: '<S386>:21'
      MX_Gtwy_Control_DWork.bitsForTID0.is_c10_MX_Gtwy_Control =
        MX_Gtwy_Control_IN_Off_fwuc;

      // Entry 'Off': '<S386>:2'
      rtb_icmd_DumpValve = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
    } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_c10_MX_Gtwy_Control ==
               MX_Gtwy_Control_IN_Off_fwuc) {
      rtb_icmd_DumpValve = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);

      // During 'Off': '<S386>:2'
      if (aux_Flow == AUX_FLOW_MEDIUM) {
        // Transition: '<S386>:20'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c10_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_On_m33g;

        // Entry 'On': '<S386>:9'
        rtb_icmd_DumpValve = CONSTANT_DATA->DUMP_VALVE_ON_CURRENT;
      }
    } else {
      rtb_icmd_DumpValve = CONSTANT_DATA->DUMP_VALVE_ON_CURRENT;

      // During 'On': '<S386>:9'
      if (aux_Flow != AUX_FLOW_MEDIUM) {
        // Transition: '<S386>:18'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c10_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_Off_fwuc;

        // Entry 'Off': '<S386>:2'
        rtb_icmd_DumpValve = (uint16_T)(int32_T)((int32_T)INACTIVE << 12);
      }
    }

    // End of Chart: '<S384>/Dump_Valve'

    // Outputs for Atomic SubSystem: '<S384>/hc_pair_control'
    MX_Gtwy__output_pair_ClosedLoop(rtb_icmd_DumpValve, rtb_Compare_mjfo,
      afbk_DumpValve, ifbk_DumpValve, MX_Gtwy_Control_B.RateTransition31_aank,
      state_Engine, MX_Gtwy_Control_B.RateTransition28_o4gy,
      ain_PrecisionReference, &MX_Gtwy_Control_B.hs_cmd_cnig,
      &MX_Gtwy_Control_B.ls_cmd_fvfb, &MX_Gtwy_Control_B.error_cybc,
      &calc_ifbk_DumpValve, &MX_Gtwy_Control_B.state_Output_au4i,
      &MX_Gtwy_Control_B.hc_pair_control_mjt1,
      &MX_Gtwy_Control_DWork.hc_pair_control_mjt1,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->DUMP_VALVE_KP, CONSTANT_DATA->DUMP_VALVE_KI,
      CONSTANT_DATA->DUMP_VALVE_OVERCURRENT,
      CONSTANT_DATA->DUMP_VALVE_NON_ZERO_DUTY,
      CONSTANT_DATA->DUMP_VALVE_NON_ZERO_CURRENT,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->DUMP_VALVE_DEBOUNCE_SHORT_TO_BATTERY, NON_FUNCTIONAL,
      CONSTANT_DATA->DUMP_VALVE_AFBK_GAIN, CONSTANT_DATA->DUMP_VALVE_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S384>/hc_pair_control'

    // SignalConversion: '<S384>/OutportBufferForerrorCC_DumpValve' incorporates:
    //   Inport: '<Root>/afbk_DumpValve'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_DumpValve'

    errorCC_DumpValve = MX_Gtwy_Control_B.error_cybc;

    // SignalConversion: '<S384>/OutportBufferForhs_DumpValve'
    hs_DumpValve = MX_Gtwy_Control_B.hs_cmd_cnig;

    // SignalConversion: '<S384>/OutportBufferForls_DumpValve'
    ls_DumpValve = MX_Gtwy_Control_B.ls_cmd_fvfb;

    // SignalConversion: '<S384>/OutportBufferForstate_DumpValve'
    state_DumpValve = MX_Gtwy_Control_B.state_Output_au4i;
  } else {
    if (MX_Gtwy_Control_DWork.Dump_Valve_MODE) {
      // Disable for Atomic SubSystem: '<S384>/hc_pair_control'
      output_pair_ClosedLoop_Disable(&MX_Gtwy_Control_B.error_cybc,
        &MX_Gtwy_Control_B.hc_pair_control_mjt1,
        &MX_Gtwy_Control_DWork.hc_pair_control_mjt1);

      // End of Disable for SubSystem: '<S384>/hc_pair_control'

      // Disable for Outport: '<S384>/state_DumpValve'
      state_DumpValve = ((uint8_T)0U);

      // Disable for Outport: '<S384>/hs_DumpValve'
      hs_DumpValve = ((uint16_T)0U);

      // Disable for Outport: '<S384>/ls_DumpValve'
      ls_DumpValve = false;

      // Disable for Outport: '<S384>/errorCC_DumpValve'
      errorCC_DumpValve = 0;

      // Disable for Outport: '<S384>/calc_ifbk_DumpValve'
      calc_ifbk_DumpValve = ((uint16_T)0U);
      MX_Gtwy_Control_DWork.Dump_Valve_MODE = false;
    }
  }

  // End of Logic: '<S284>/Logical Operator'
  // End of Outputs for SubSystem: '<S284>/Dump_Valve'
}

// Function for Chart: '<S405>/RelaySolenoid'
static void MX_Gtwy_Control_FuelTiming(void)
{
  // Graphical Function 'FuelTiming': '<S409>:4'
  // Transition: '<S409>:5'
  if ((MX_Gtwy_Control_B.time_Pull != UNLIMITED) &&
      ((CONSTANT_DATA->FUEL_PRIMARY_ON_SECONDARY_FAILURE == NON_FUNCTIONAL) ||
       (error_FuelSec == NORMAL))) {
    // Transition: '<S409>:6'
    // Transition: '<S409>:8'
    MX_Gtwy_Control_DWork.outputTimer = (uint16_T)(int32_T)((int32_T)
      MX_Gtwy_Control_DWork.outputTimer + 1);

    // Transition: '<S409>:9'
  } else {
    // Transition: '<S409>:7'
  }
}

// System initialize for atomic system: '<S285>/Fuel_Primary_Relay'
void MX_Gtwy_Fuel_Primary_Relay_Init(void)
{
  // SystemInitialize for Chart: '<S405>/RelaySolenoid'
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c62_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ei1u;
  MX_Gtwy_Control_DWork.outputTimer = 0U;
  dout_FuelPri = false;

  // SystemInitialize for Enabled SubSystem: '<S405>/relay_oc'
  MX_Gtwy_Control_relay_oc_Init(&state_FuelPriOutput, &state_FuelPriRelay,
    &MX_Gtwy_Control_B.relay_oc, &MX_Gtwy_Control_DWork.relay_oc);

  // End of SystemInitialize for SubSystem: '<S405>/relay_oc'
}

// Output and update for atomic system: '<S285>/Fuel_Primary_Relay'
void MX_Gtwy_Cont_Fuel_Primary_Relay(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;

  // SignalConversion: '<S405>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S405>/FunctionState'
  //   Constant: '<S407>/Constant'
  //   Constant: '<S408>/Constant'
  //   Logic: '<S405>/Logical Operator'
  //   RelationalOperator: '<S407>/Compare'
  //   RelationalOperator: '<S408>/Compare'

  rtb_HiddenBuf_InsertedFor_relay =
    ((CONSTANT_DATA->FUEL_PRIMARY_FEEDBACK_FUNCTION != NON_FUNCTIONAL) &&
     (MX_Gtwy_Control_B.RateTransition34_jbuw != OORL));

  // Lookup: '<S405>/PullTime1'
  //
  //  About '<S405>/PullTime1':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Round Mode: Nearest
  //  Lookup Method: Nearest
  //
  //  XData is inlined and evenly spaced, so the algorithm only needs
  //  the value of the first element, the last element, and the spacing.
  //  For efficiency, XData is excluded from the generated code.
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;

    // Find the location of current input value in the data table.
    //
    //  Based on the data type of the input, it is impossible for the
    //  search value to be less than the smallest point in the table.

    if (MX_Gtwy_Control_B.RateTransition40 >= 336U ) {
      // Greater than or equal to the largest point in the table.
      iLeft = 42U;
    } else {
      // The table is inlined with even spacing 2^3.
      //  The index is found by a 3 bit shift right.
      iLeft = (uint32_T)( MX_Gtwy_Control_B.RateTransition40 ) >> 3;

      // Adjust the index, if necessary, so that it always
      //  gives the data point nearest the current input value.
      //  It is necessary to round up iff the last bit shifted
      //  off was a one.

      iLeft += ((uint32_T)(( MX_Gtwy_Control_B.RateTransition40 ) & (0x00000004U)
                           )) != 0U;
    }

    MX_Gtwy_Control_B.time_Pull = MXGTW_FUEL_PULL_TIME[iLeft];
  }

  // Chart: '<S405>/RelaySolenoid' incorporates:
  //   UnitDelay: '<S405>/Unit Delay1'
  //   UnitDelay: '<S405>/Unit Delay2'

  // Gateway: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
  // During: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID0.is_active_c62_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
    MX_Gtwy_Control_DWork.bitsForTID0.is_active_c62_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/FuelPri_HVAC/Fuel_Primary_Relay/RelaySolenoid 
    // Transition: '<S409>:10'
    MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control =
      MX_Gtwy_Contro_IN_INACTIVE_atau;

    // Entry 'INACTIVE': '<S409>:1'
    dout_FuelPri = ((int32_T)INACTIVE != 0);
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_ACTIVE_nevi:
      // During 'ACTIVE': '<S409>:2'
      if ((MX_Gtwy_Control_DWork.outputTimer >= MX_Gtwy_Control_B.time_Pull) ||
          (!((state_FuelPriOutput == NORMAL) || (state_FuelPriOutput == FAILURE)))
          || (state_FuelPriRelay != NORMAL)) {
        // Transition: '<S409>:14'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_INACTIVE_OFF;

        // Entry 'INACTIVE_OFF': '<S409>:3'
        dout_FuelPri = ((int32_T)INACTIVE != 0);
      } else if (state_Engine == ENGINE_NOT_RUNNING) {
        // Transition: '<S409>:15'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_atau;

        // Entry 'INACTIVE': '<S409>:1'
        dout_FuelPri = ((int32_T)INACTIVE != 0);
      } else {
        MX_Gtwy_Control_FuelTiming();
      }
      break;

     case MX_Gtwy_Contro_IN_INACTIVE_atau:
      // During 'INACTIVE': '<S409>:1'
      if ((CONSTANT_DATA->FUEL_PRIMARY_FUNCTION != NON_FUNCTIONAL) &&
          (MX_Gtwy_Control_B.RateTransition41_mpbl == INACTIVE) && (state_Engine
           == ENGINE_CRANKING) && ((state_FuelPriOutput == NORMAL) ||
           (state_FuelPriOutput == FAILURE)) && (state_FuelPriRelay == NORMAL))
      {
        // Transition: '<S409>:13'
        MX_Gtwy_Control_DWork.outputTimer = 0U;
        MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ACTIVE_nevi;

        // Entry 'ACTIVE': '<S409>:2'
        dout_FuelPri = ((int32_T)ACTIVE != 0);
      }
      break;

     default:
      // During 'INACTIVE_OFF': '<S409>:3'
      if (state_Engine == ENGINE_NOT_RUNNING) {
        // Transition: '<S409>:11'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c62_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_atau;

        // Entry 'INACTIVE': '<S409>:1'
        dout_FuelPri = ((int32_T)INACTIVE != 0);
      }
      break;
    }
  }

  // End of Chart: '<S405>/RelaySolenoid'

  // Outputs for Enabled SubSystem: '<S405>/relay_oc'

  // Inport: '<Root>/dfbk_FuelPriOutput' incorporates:
  //   Inport: '<Root>/din_FuelPriRelay'

  MX_Gtwy_Control_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_FuelPri,
    dfbk_FuelPriOutput, din_FuelPriRelay, &state_FuelPriOutput,
    &state_FuelPriRelay, &MX_Gtwy_Control_B.relay_oc,
    &MX_Gtwy_Control_DWork.relay_oc,
    CONSTANT_DATA->FUEL_PRIMARY_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->FUEL_PRIMARY_DEBOUNCE_ERROR_ON,
    CONSTANT_DATA->FUEL_PRIMARY_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S405>/relay_oc'
}

// Function for Chart: '<S415>/Fault monitor'
static uint8_T MX_Gtwy_Control_out_state(boolean_T rtu_cmd, boolean_T rtu_fbk,
  rtDW_dout_chk_MX_Gtwy_Control *localDW, uint16_T rtp_ERR_OFF_DB_CNT, uint16_T
  rtp_ERR_ON_DB_CNT)
{
  uint8_T y;

  // Outputs for Enabled SubSystem: '<S406>/dout_chk' incorporates:
  //   EnablePort: '<S415>/Enable'

  // Chart: '<S415>/Fault monitor'
  // Truth Table Function 'out_state': '<S416>:5'
  // Condition '#1': '<S416>:104'
  //  command, off feedback, on
  // Condition '#2': '<S416>:106'
  //  command, on feedback, off
  if ((!rtu_cmd) && rtu_fbk) {
    // Decision 'D1': '<S416>:108'
    // Action '1': '<S416>:110'
    //  'E_on':Error On
    y = 2U;
    localDW->db_limit = rtp_ERR_ON_DB_CNT;
  } else if (rtu_cmd && (!rtu_fbk)) {
    // Decision 'D2': '<S416>:114'
    // Action '2': '<S416>:116'
    //  'E_off':Error Off
    y = 3U;
    localDW->db_limit = rtp_ERR_OFF_DB_CNT;
  } else {
    // Decision 'D3': '<S416>:120'
    //  Default
    // Action '3': '<S416>:122'
    //  'ok':default
    y = 8U;
  }

  // End of Chart: '<S415>/Fault monitor'
  // End of Outputs for SubSystem: '<S406>/dout_chk'
  return y;
}

//
//  System initialize for enable system:
//     '<S406>/dout_chk'
//     '<S291>/dout_chk'
//     '<S292>/dout_chk'
//     '<S294>/dout_chk'

void MX_Gtwy_Control_dout_chk_Init(uint8_T *rty_state,
  rtB_dout_chk_MX_Gtwy_Control *localB, rtDW_dout_chk_MX_Gtwy_Control *localDW)
{
  // SystemInitialize for Chart: '<S415>/Fault monitor'
  localDW->bitsForTID0.is_diagnostics = MX_Gtwy_IN_NO_ACTIVE_CHILD_c5m3;
  localDW->bitsForTID0.is_active_c60_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_state = 0U;
  localDW->db_limit = 20U;
  localB->state = 0U;

  // SystemInitialize for Outport: '<S415>/state'
  *rty_state = ((uint8_T)8U);
}

//
//  System reset for enable system:
//     '<S406>/dout_chk'
//     '<S291>/dout_chk'
//     '<S292>/dout_chk'
//     '<S294>/dout_chk'

void MX_Gtwy_Control_dout_chk_Reset(rtB_dout_chk_MX_Gtwy_Control *localB,
  rtDW_dout_chk_MX_Gtwy_Control *localDW)
{
  // SystemReset for Chart: '<S415>/Fault monitor'
  localDW->bitsForTID0.is_diagnostics = MX_Gtwy_IN_NO_ACTIVE_CHILD_c5m3;
  localDW->bitsForTID0.is_active_c60_MX_Library = 0U;
  localDW->db_cnt = 0U;
  localDW->db_state = 0U;
  localDW->db_limit = 20U;
  localB->state = 0U;
}

//
//  Disable for enable system:
//     '<S406>/dout_chk'
//     '<S291>/dout_chk'
//     '<S292>/dout_chk'
//     '<S294>/dout_chk'

void MX_Gtwy_Contro_dout_chk_Disable(uint8_T *rty_state,
  rtDW_dout_chk_MX_Gtwy_Control *localDW)
{
  // Outputs for Enabled SubSystem: '<S406>/dout_chk' incorporates:
  //   EnablePort: '<S415>/Enable'

  // Disable for Outport: '<S415>/state'
  *rty_state = ((uint8_T)8U);

  // End of Outputs for SubSystem: '<S406>/dout_chk'
  localDW->dout_chk_MODE = false;
}

//
//  Output and update for enable system:
//     '<S406>/dout_chk'
//     '<S291>/dout_chk'
//     '<S292>/dout_chk'
//     '<S294>/dout_chk'

void MX_Gtwy_Control_dout_chk(boolean_T rtu_Enable, boolean_T rtu_cmd, boolean_T
  rtu_fbk, uint8_T *rty_state, rtB_dout_chk_MX_Gtwy_Control *localB,
  rtDW_dout_chk_MX_Gtwy_Control *localDW, uint16_T rtp_ERR_OFF_DB_CNT, uint16_T
  rtp_ERR_ON_DB_CNT)
{
  uint8_T os;

  // Outputs for Enabled SubSystem: '<S406>/dout_chk' incorporates:
  //   EnablePort: '<S415>/Enable'

  if (rtu_Enable) {
    if (!localDW->dout_chk_MODE) {
      MX_Gtwy_Control_dout_chk_Reset(localB, localDW);
      localDW->dout_chk_MODE = true;
    }

    // Chart: '<S415>/Fault monitor'
    // Gateway: dout_chk/Fault monitor
    // During: dout_chk/Fault monitor
    if ((uint32_T)localDW->bitsForTID0.is_active_c60_MX_Library == 0U) {
      // Entry: dout_chk/Fault monitor
      localDW->bitsForTID0.is_active_c60_MX_Library = 1U;

      // Entry Internal: dout_chk/Fault monitor
      // Entry 'diagnostics': '<S416>:4'
      localDW->db_cnt = 0U;
      localDW->db_state = 0U;
      localDW->db_limit = 20U;

      // Entry Internal 'diagnostics': '<S416>:4'
      // Transition: '<S416>:6'
      localDW->bitsForTID0.is_diagnostics = MX_Gtwy_Control_IN_Ok;

      // Entry 'Ok': '<S416>:1'
      localB->state = 8U;
    } else {
      // During 'diagnostics': '<S416>:4'
      os = MX_Gtwy_Control_out_state(rtu_cmd, rtu_fbk, localDW,
        rtp_ERR_OFF_DB_CNT, rtp_ERR_ON_DB_CNT);
      switch (localDW->bitsForTID0.is_diagnostics) {
       case MX_Gtwy_Control_IN_Ok:
        // During 'Ok': '<S416>:1'
        if ((int32_T)os != 8) {
          // Transition: '<S416>:10'
          localDW->db_state = os;
          localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
          localDW->bitsForTID0.is_diagnostics = MX_Gtwy_Contro_IN_debounce_cuwh;
        }
        break;

       case MX_Gtwy_Contro_IN_debounce_cuwh:
        // During 'debounce': '<S416>:3'
        if ((int32_T)localDW->db_cnt == 0) {
          // Transition: '<S416>:9'
          localDW->bitsForTID0.is_diagnostics = MX_Gtwy_Control_IN_Ok;

          // Entry 'Ok': '<S416>:1'
          localB->state = 8U;
        } else if (localDW->db_cnt >= localDW->db_limit) {
          // Transition: '<S416>:7'
          localDW->bitsForTID0.is_diagnostics = MX_Gtwy_Control_IN_error_knwh;

          // Entry 'error': '<S416>:2'
          localB->state = os;
        } else {
          // Transition: '<S416>:8'
          if (localDW->db_state == os) {
            // Transition: '<S416>:12'
            localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt + 1);
            localDW->bitsForTID0.is_diagnostics =
              MX_Gtwy_Contro_IN_debounce_cuwh;
          } else {
            // Transition: '<S416>:13'
            if ((int32_T)os == 8) {
              // Transition: '<S416>:14'
              localDW->db_cnt = (uint16_T)(int32_T)((int32_T)localDW->db_cnt - 1);
              localDW->bitsForTID0.is_diagnostics =
                MX_Gtwy_Contro_IN_debounce_cuwh;
            } else {
              // Transition: '<S416>:11'
              localDW->db_cnt = 1U;
              localDW->db_state = os;
              localDW->bitsForTID0.is_diagnostics =
                MX_Gtwy_Contro_IN_debounce_cuwh;
            }
          }
        }
        break;

       default:
        // During 'error': '<S416>:2'
        break;
      }
    }

    // End of Chart: '<S415>/Fault monitor'

    // SignalConversion: '<S415>/OutportBufferForstate'
    *rty_state = localB->state;
  } else {
    if (localDW->dout_chk_MODE) {
      MX_Gtwy_Contro_dout_chk_Disable(rty_state, localDW);
    }
  }

  // End of Outputs for SubSystem: '<S406>/dout_chk'
}

// System initialize for atomic system: '<S285>/HVAC_Relay'
void MX_Gtwy_Control_HVAC_Relay_Init(void)
{
  // SystemInitialize for Chart: '<S406>/RelaySolenoid'
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c36_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_aog3;
  MX_Gtwy_Control_DWork.debounceCount_foat = 0U;
  dout_HVACOutput = false;

  // SystemInitialize for Enabled SubSystem: '<S406>/dout_chk'
  MX_Gtwy_Control_dout_chk_Init(&state_HVACOutput, &MX_Gtwy_Control_B.dout_chk,
    &MX_Gtwy_Control_DWork.dout_chk);

  // End of SystemInitialize for SubSystem: '<S406>/dout_chk'
}

// Output and update for atomic system: '<S285>/HVAC_Relay'
void MX_Gtwy_Control_HVAC_Relay(void)
{
  boolean_T rtb_LogicalOperator1_i4tt;

  // Logic: '<S406>/Logical Operator1' incorporates:
  //   Constant: '<S406>/FunctionState1'
  //   Constant: '<S412>/Constant'
  //   Constant: '<S413>/Constant'
  //   RelationalOperator: '<S412>/Compare'
  //   RelationalOperator: '<S413>/Compare'

  rtb_LogicalOperator1_i4tt = ((CONSTANT_DATA->HVAC_RELAY_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (MX_Gtwy_Control_B.RateTransition34_jbuw != OORL));

  // Chart: '<S406>/RelaySolenoid' incorporates:
  //   Inport: '<Root>/state_System'
  //   UnitDelay: '<S406>/Unit Delay3'

  // Gateway: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid
  // During: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID0.is_active_c36_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid
    MX_Gtwy_Control_DWork.bitsForTID0.is_active_c36_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/FuelPri_HVAC/HVAC_Relay/RelaySolenoid 
    // Transition: '<S414>:10'
    MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control =
      MX_Gt_IN_STARTUP_ERROR_ON_CHECK;

    // Entry 'STARTUP_ERROR_ON_CHECK': '<S414>:59'
    dout_HVACOutput = ((int32_T)INACTIVE != 0);
    MX_Gtwy_Control_DWork.debounceCount_foat = 0U;
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_ACTIVE_gz5o:
      // During 'ACTIVE': '<S414>:2'
      if ((state_Engine == ENGINE_CRANKING) || (state_HVACOutput != NORMAL) ||
          (state_System != SYS_NORMAL)) {
        // Transition: '<S414>:15'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_phj4;

        // Entry 'INACTIVE': '<S414>:1'
        dout_HVACOutput = ((int32_T)INACTIVE != 0);
      }
      break;

     case MX_Gtwy_Contro_IN_INACTIVE_phj4:
      // During 'INACTIVE': '<S414>:1'
      if ((CONSTANT_DATA->HVAC_RELAY_FUNCTION != NON_FUNCTIONAL) &&
          ((state_Engine != ENGINE_CRANKING) || (state_Engine == ENGINE_RUNNING))
          && (state_HVACOutput == NORMAL) && (state_System == SYS_NORMAL)) {
        // Transition: '<S414>:13'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ACTIVE_gz5o;

        // Entry 'ACTIVE': '<S414>:2'
        dout_HVACOutput = ((int32_T)ACTIVE != 0);
      }
      break;

     default:
      // During 'STARTUP_ERROR_ON_CHECK': '<S414>:59'
      if ((int32_T)MX_Gtwy_Control_DWork.debounceCount_foat >= (int32_T)
          ((int32_T)CONSTANT_DATA->HVAC_RELAY_DEBOUNCE_ERROR_ON + 100)) {
        // Transition: '<S414>:60'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_phj4;

        // Entry 'INACTIVE': '<S414>:1'
        dout_HVACOutput = ((int32_T)INACTIVE != 0);
      } else if ((CONSTANT_DATA->HVAC_RELAY_FUNCTION != NON_FUNCTIONAL) &&
                 (state_Engine == ENGINE_RUNNING) && (state_HVACOutput == NORMAL)
                 && (state_System == SYS_NORMAL)) {
        // Transition: '<S414>:66'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c36_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ACTIVE_gz5o;

        // Entry 'ACTIVE': '<S414>:2'
        dout_HVACOutput = ((int32_T)ACTIVE != 0);
      } else {
        MX_Gtwy_Control_DWork.debounceCount_foat = (uint16_T)(int32_T)((int32_T)
          MX_Gtwy_Control_DWork.debounceCount_foat + 1);
      }
      break;
    }
  }

  // End of Chart: '<S406>/RelaySolenoid'

  // Outputs for Enabled SubSystem: '<S406>/dout_chk'

  // Inport: '<Root>/dfbk_HVACOutput'
  MX_Gtwy_Control_dout_chk(rtb_LogicalOperator1_i4tt, dout_HVACOutput,
    dfbk_HVACOutput, &state_HVACOutput, &MX_Gtwy_Control_B.dout_chk,
    &MX_Gtwy_Control_DWork.dout_chk,
    CONSTANT_DATA->HVAC_RELAY_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->HVAC_RELAY_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S406>/dout_chk'
}

// System initialize for atomic system: '<S4>/FuelPri_HVAC'
void MX_Gtwy_Contr_FuelPri_HVAC_Init(void)
{
  // SystemInitialize for Atomic SubSystem: '<S285>/Fuel_Primary_Relay'
  MX_Gtwy_Fuel_Primary_Relay_Init();

  // End of SystemInitialize for SubSystem: '<S285>/Fuel_Primary_Relay'

  // SystemInitialize for Atomic SubSystem: '<S285>/HVAC_Relay'
  MX_Gtwy_Control_HVAC_Relay_Init();

  // End of SystemInitialize for SubSystem: '<S285>/HVAC_Relay'
}

// Output and update for atomic system: '<S4>/FuelPri_HVAC'
void MX_Gtwy_Control_FuelPri_HVAC(void)
{
  // Outputs for Atomic SubSystem: '<S285>/Fuel_Primary_Relay'
  MX_Gtwy_Cont_Fuel_Primary_Relay();

  // End of Outputs for SubSystem: '<S285>/Fuel_Primary_Relay'

  // Outputs for Atomic SubSystem: '<S285>/HVAC_Relay'
  MX_Gtwy_Control_HVAC_Relay();

  // End of Outputs for SubSystem: '<S285>/HVAC_Relay'
}

// System initialize for atomic system: '<S4>/FuelSec_ECUHold'
void MX_Gtwy_Co_FuelSec_ECUHold_Init(void)
{
  // SystemInitialize for Chart: '<S286>/Solenoid'
  MX_Gtwy_Control_DWork.bitsForTID0.is_ECU_HOLD =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gtwy_Control_DWork.bitsForTID0.is_FUEL_HOLD =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c37_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
  MX_Gtwy_Control_DWork.debounceCount_bjgo = 0U;
  duty_FuelSec = 0U;
  state_FuelSec = 0U;
  state_ECUHold = 0U;

  // SystemInitialize for Enabled SubSystem: '<S286>/hc_hsd'
  MX_Gtwy_Control_hc_hsd_Init(&error_FuelSec, &MX_Gtwy_Control_B.hc_hsd,
    &MX_Gtwy_Control_DWork.hc_hsd);

  // End of SystemInitialize for SubSystem: '<S286>/hc_hsd'
}

// Output and update for atomic system: '<S4>/FuelSec_ECUHold'
void MX_Gtwy_Control_FuelSec_ECUHold(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_hc_hs;
  uint16_T rtb_afbkGain_FuelSec;

  // Gain: '<S286>/Gain' incorporates:
  //   Inport: '<Root>/afbk_FuelSec'

  rtb_afbkGain_FuelSec = (uint16_T)(uint32_T)((uint32_T)
    CONSTANT_DATA->FUEL_SECONDARY_AFBK_GAIN * (uint32_T)afbk_FuelSec);

  // SignalConversion: '<S286>/HiddenBuf_InsertedFor_hc_hsd_at_inport_3' incorporates:
  //   Constant: '<S286>/FunctionState'
  //   Constant: '<S286>/FunctionState1'
  //   Constant: '<S417>/Constant'
  //   Constant: '<S418>/Constant'
  //   Constant: '<S419>/Constant'
  //   Logic: '<S286>/Logical Operator'
  //   Logic: '<S286>/Logical Operator1'
  //   RelationalOperator: '<S417>/Compare'
  //   RelationalOperator: '<S418>/Compare'
  //   RelationalOperator: '<S419>/Compare'

  rtb_HiddenBuf_InsertedFor_hc_hs =
    (((CONSTANT_DATA->FUEL_SECONDARY_FEEDBACK_FUNCTION != NON_FUNCTIONAL) ||
      (CONSTANT_DATA->ECU_FUNCTION != NON_FUNCTIONAL)) &&
     (MX_Gtwy_Control_B.RateTransition42 != OORL));

  // Chart: '<S286>/Solenoid' incorporates:
  //   Inport: '<Root>/din_StarterRelay'
  //   Inport: '<Root>/state_System'
  //   UnitDelay: '<S286>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
  // During: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID0.is_active_c37_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
    MX_Gtwy_Control_DWork.bitsForTID0.is_active_c37_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/FuelSec_ECUHold/Solenoid
    // Transition: '<S420>:13'
    MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control =
      MX_Gtwy__IN_NON_FUNCTIONAL_hp4p;

    // Entry 'NON_FUNCTIONAL': '<S420>:4'
    duty_FuelSec = 0U;
    state_FuelSec = INACTIVE;
    state_ECUHold = INACTIVE;
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_ECU_HOLD:
      // During 'ECU_HOLD': '<S420>:38'
      if ((state_System != SYS_NORMAL) || (state_Engine == SHUTDOWN)) {
        // Transition: '<S420>:49'
        // Exit Internal 'ECU_HOLD': '<S420>:38'
        MX_Gtwy_Control_DWork.bitsForTID0.is_ECU_HOLD =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;

        // Exit Internal 'NORMAL': '<S420>:77'
        MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
        MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control =
          MX_Gtwy__IN_NON_FUNCTIONAL_hp4p;

        // Entry 'NON_FUNCTIONAL': '<S420>:4'
        duty_FuelSec = 0U;
        state_FuelSec = INACTIVE;
        state_ECUHold = INACTIVE;
      } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_ECU_HOLD ==
                 MX_Gtwy_Control_IN_ERROR_oymp) {
        duty_FuelSec = 0U;

        // During 'ERROR': '<S420>:83'
        if (error_FuelSec == NORMAL) {
          // Transition: '<S420>:85'
          MX_Gtwy_Control_DWork.bitsForTID0.is_ECU_HOLD =
            MX_Gtwy_Control_IN_NORMAL_chyf;

          // Entry Internal 'NORMAL': '<S420>:77'
          // Transition: '<S420>:61'
          MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
            MX_Gtwy_Contr_IN_CHECK_ERROR_ON;

          // Entry 'CHECK_ERROR_ON': '<S420>:60'
          duty_FuelSec = 0U;
          state_ECUHold = INACTIVE;
          MX_Gtwy_Control_DWork.debounceCount_bjgo = 0U;
        }
      } else {
        // During 'NORMAL': '<S420>:77'
        if (error_FuelSec != NORMAL) {
          // Transition: '<S420>:84'
          // Exit Internal 'NORMAL': '<S420>:77'
          MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
          MX_Gtwy_Control_DWork.bitsForTID0.is_ECU_HOLD =
            MX_Gtwy_Control_IN_ERROR_oymp;

          // Entry 'ERROR': '<S420>:83'
          duty_FuelSec = 0U;
          state_ECUHold = error_FuelSec;
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n ==
                   MX_Gtwy_Control_IN_ACTIVE_e31e) {
          duty_FuelSec = FULL_ON;

          // During 'ACTIVE': '<S420>:62'
          if ((MX_Gtwy_Control_B.UnitDelay9_hk24 != NORMAL) ||
              (MX_Gtwy_Control_B.UnitDelay10_kkg2 != NORMAL) || (state_Engine ==
               ENGINE_OFF)) {
            // Transition: '<S420>:89'
            MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
              MX_Gtwy_Contr_IN_CHECK_ERROR_ON;

            // Entry 'CHECK_ERROR_ON': '<S420>:60'
            duty_FuelSec = 0U;
            state_ECUHold = INACTIVE;
            MX_Gtwy_Control_DWork.debounceCount_bjgo = 0U;
          }
        } else {
          duty_FuelSec = 0U;

          // During 'CHECK_ERROR_ON': '<S420>:60'
          if ((MX_Gtwy_Control_DWork.debounceCount_bjgo >=
               CONSTANT_DATA->ECU_HOLD_DEBOUNCE_ERROR_ON) &&
              (MX_Gtwy_Control_B.UnitDelay9_hk24 == NORMAL) &&
              (MX_Gtwy_Control_B.UnitDelay10_kkg2 == NORMAL) &&
              ((din_StarterRelay == (int32_T)INACTIVE) || (state_Engine ==
                ENGINE_CRANKING)) && (state_Engine != ENGINE_OFF)) {
            // Transition: '<S420>:63'
            MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
              MX_Gtwy_Control_IN_ACTIVE_e31e;

            // Entry 'ACTIVE': '<S420>:62'
            duty_FuelSec = FULL_ON;
            state_ECUHold = ACTIVE;
          } else {
            MX_Gtwy_Control_DWork.debounceCount_bjgo = (uint16_T)(int32_T)
              ((int32_T)MX_Gtwy_Control_DWork.debounceCount_bjgo + 1);
          }
        }
      }
      break;

     case MX_Gtwy_Control_IN_FUEL_HOLD:
      // During 'FUEL_HOLD': '<S420>:36'
      if (state_System != SYS_NORMAL) {
        // Transition: '<S420>:10'
        // Exit Internal 'FUEL_HOLD': '<S420>:36'
        // Exit Internal 'ACTIVE': '<S420>:3'
        MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
        MX_Gtwy_Control_DWork.bitsForTID0.is_FUEL_HOLD =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
        MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control =
          MX_Gtwy__IN_NON_FUNCTIONAL_hp4p;

        // Entry 'NON_FUNCTIONAL': '<S420>:4'
        duty_FuelSec = 0U;
        state_FuelSec = INACTIVE;
        state_ECUHold = INACTIVE;
      } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_FUEL_HOLD ==
                 MX_Gtwy_Control_IN_ACTIVE_e31e) {
        // During 'ACTIVE': '<S420>:3'
        if (error_FuelSec != NORMAL) {
          // Transition: '<S420>:11'
          // Exit Internal 'ACTIVE': '<S420>:3'
          MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_fnr0;
          MX_Gtwy_Control_DWork.bitsForTID0.is_FUEL_HOLD =
            MX_Gtwy_Control_IN_ERROR_oymps;

          // Entry 'ERROR': '<S420>:5'
          duty_FuelSec = 0U;
          state_FuelSec = error_FuelSec;
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei ==
                   MX_Gtwy_Control_IN_ACTIVE_e31e) {
          duty_FuelSec = FULL_ON;

          // During 'ACTIVE': '<S420>:1'
          if ((state_Engine == SHUTDOWN) || (state_Engine == ENGINE_OFF)) {
            // Transition: '<S420>:8'
            MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
              MX_Gtwy_Contro_IN_INACTIVE_nope;

            // Entry 'INACTIVE': '<S420>:2'
            duty_FuelSec = 0U;
            state_FuelSec = INACTIVE;
          }
        } else {
          duty_FuelSec = 0U;

          // During 'INACTIVE': '<S420>:2'
          if (state_Engine == ENGINE_CRANKING) {
            // Transition: '<S420>:7'
            MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
              MX_Gtwy_Control_IN_ACTIVE_e31e;

            // Entry 'ACTIVE': '<S420>:1'
            duty_FuelSec = FULL_ON;
            state_FuelSec = ACTIVE;
          }
        }
      } else {
        duty_FuelSec = 0U;

        // During 'ERROR': '<S420>:5'
        if (error_FuelSec == NORMAL) {
          // Transition: '<S420>:12'
          MX_Gtwy_Control_DWork.bitsForTID0.is_FUEL_HOLD =
            MX_Gtwy_Control_IN_ACTIVE_e31e;

          // Entry Internal 'ACTIVE': '<S420>:3'
          // Transition: '<S420>:6'
          MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
            MX_Gtwy_Contro_IN_INACTIVE_nope;

          // Entry 'INACTIVE': '<S420>:2'
          duty_FuelSec = 0U;
          state_FuelSec = INACTIVE;
        }
      }
      break;

     default:
      duty_FuelSec = 0U;

      // During 'NON_FUNCTIONAL': '<S420>:4'
      if ((CONSTANT_DATA->ECU_FUNCTION != NON_FUNCTIONAL) && (state_System ==
           SYS_NORMAL) && (state_Engine != SHUTDOWN)) {
        // Transition: '<S420>:48'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ECU_HOLD;

        // Entry Internal 'ECU_HOLD': '<S420>:38'
        // Transition: '<S420>:86'
        MX_Gtwy_Control_DWork.bitsForTID0.is_ECU_HOLD =
          MX_Gtwy_Control_IN_NORMAL_chyf;

        // Entry Internal 'NORMAL': '<S420>:77'
        // Transition: '<S420>:61'
        MX_Gtwy_Control_DWork.bitsForTID0.is_NORMAL_eo1n =
          MX_Gtwy_Contr_IN_CHECK_ERROR_ON;

        // Entry 'CHECK_ERROR_ON': '<S420>:60'
        duty_FuelSec = 0U;
        state_ECUHold = INACTIVE;
        MX_Gtwy_Control_DWork.debounceCount_bjgo = 0U;
      } else {
        if ((CONSTANT_DATA->FUEL_SECONDARY_FUNCTION != NON_FUNCTIONAL) &&
            (state_System == SYS_NORMAL)) {
          // Transition: '<S420>:9'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c37_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_FUEL_HOLD;

          // Entry Internal 'FUEL_HOLD': '<S420>:36'
          // Transition: '<S420>:76'
          MX_Gtwy_Control_DWork.bitsForTID0.is_FUEL_HOLD =
            MX_Gtwy_Control_IN_ACTIVE_e31e;

          // Entry Internal 'ACTIVE': '<S420>:3'
          // Transition: '<S420>:6'
          MX_Gtwy_Control_DWork.bitsForTID0.is_ACTIVE_niei =
            MX_Gtwy_Contro_IN_INACTIVE_nope;

          // Entry 'INACTIVE': '<S420>:2'
          duty_FuelSec = 0U;
          state_FuelSec = INACTIVE;
        }
      }
      break;
    }
  }

  // End of Chart: '<S286>/Solenoid'

  // Outputs for Enabled SubSystem: '<S286>/hc_hsd'
  MX_Gtwy_Control_hc_hsd(rtb_HiddenBuf_InsertedFor_hc_hs, duty_FuelSec,
    rtb_afbkGain_FuelSec, MX_Gtwy_Control_B.RateTransition7, &error_FuelSec,
    &MX_Gtwy_Control_B.hc_hsd, &MX_Gtwy_Control_DWork.hc_hsd,
    CONSTANT_DATA->FUEL_SECONDARY_DEBOUNCE_OPEN_CIRCUIT,
    CONSTANT_DATA->FUEL_SECONDARY_DEBOUNCE_SHORT_TO_BATTERY,
    CONSTANT_DATA->FUEL_SECONDARY_DEBOUNCE_SHORT_TO_GROUND);

  // End of Outputs for SubSystem: '<S286>/hc_hsd'
}

// System initialize for atomic system: '<S4>/Fuel_Resolution_Timer'
void MX_G_Fuel_Resolution_Timer_Init(void)
{
  // SystemInitialize for Chart: '<S287>/Timer'
  MX_Gtwy_Control_DWork.bitsForTID1.is_active_c58_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID1.is_c58_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_mh0r;
  MX_Gtwy_Control_DWork.resolutionTimer = 0U;
  timer_FuelResolution = 0U;
}

// Output and update for atomic system: '<S4>/Fuel_Resolution_Timer'
void MX_Gtwy_C_Fuel_Resolution_Timer(void)
{
  // Chart: '<S287>/Timer'
  // Gateway: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
  // During: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID1.is_active_c58_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
    MX_Gtwy_Control_DWork.bitsForTID1.is_active_c58_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Fuel_Resolution_Timer/Timer
    // Transition: '<S423>:4'
    MX_Gtwy_Control_DWork.bitsForTID1.is_c58_MX_Gtwy_Control =
      MX_Gtwy_Contro_IN_INACTIVE_c0o4;

    // Entry 'INACTIVE': '<S423>:2'
    timer_FuelResolution = INACTIVE;
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID1.is_c58_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_ACTIVE_g3bz:
      timer_FuelResolution = ACTIVE;

      // During 'ACTIVE': '<S423>:3'
      if ((int32_T)MX_Gtwy_Control_DWork.resolutionTimer <= 0) {
        // Transition: '<S423>:7'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c58_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_c0o4;

        // Entry 'INACTIVE': '<S423>:2'
        timer_FuelResolution = INACTIVE;
      } else {
        MX_Gtwy_Control_DWork.resolutionTimer = (uint16_T)(int32_T)((int32_T)
          MX_Gtwy_Control_DWork.resolutionTimer - 1);
      }
      break;

     case MX_Gtwy_Contro_IN_INACTIVE_c0o4:
      timer_FuelResolution = INACTIVE;

      // During 'INACTIVE': '<S423>:2'
      if ((CONSTANT_DATA->FUEL_PRIMARY_FUNCTION != NON_FUNCTIONAL) &&
          (MX_Gtwy_Control_B.dout_FuelPri_kx3h != (int32_T)INACTIVE)) {
        // Transition: '<S423>:5'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c58_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_WAIT;

        // Entry 'INACTIVE_WAIT': '<S423>:1'
        MX_Gtwy_Control_DWork.resolutionTimer =
          CONSTANT_DATA->FUEL_RESOLUTION_TIMER;
      }
      break;

     default:
      // During 'INACTIVE_WAIT': '<S423>:1'
      if (MX_Gtwy_Control_B.dout_FuelPri_kx3h == (int32_T)INACTIVE) {
        // Transition: '<S423>:6'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c58_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ACTIVE_g3bz;

        // Entry 'ACTIVE': '<S423>:3'
        timer_FuelResolution = ACTIVE;
      }
      break;
    }
  }

  // End of Chart: '<S287>/Timer'
}

// Function for Chart: '<S288>/GlowPlug'
static void MX_Gtwy_Control_PreheatTime(uint16_T temp)
{
  // Graphical Function 'PreheatTime': '<S427>:100'
  // Transition: '<S427>:163'
  //  Glow plug preheat time
  if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL1) {
    // Transition: '<S427>:165'
    // Transition: '<S427>:170'
    MX_Gtwy_Control_DWork.debounceCount_ivzl =
      CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL0;

    // Transition: '<S427>:169'
    // Transition: '<S427>:168'
    // Transition: '<S427>:175'
  } else {
    // Transition: '<S427>:164'
    if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL2) {
      // Transition: '<S427>:172'
      // Transition: '<S427>:171'
      MX_Gtwy_Control_DWork.debounceCount_ivzl =
        CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL1;

      // Transition: '<S427>:168'
      // Transition: '<S427>:175'
    } else {
      // Transition: '<S427>:167'
      if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL3) {
        // Transition: '<S427>:173'
        // Transition: '<S427>:174'
        MX_Gtwy_Control_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL2;

        // Transition: '<S427>:175'
      } else {
        // Transition: '<S427>:176'
        MX_Gtwy_Control_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_PREHEAT_TIME_LEVEL3;
      }
    }
  }

  // Transition: '<S427>:166'
}

// Function for Chart: '<S288>/GlowPlug'
static void MX_Gtwy_Control_AfterglowTime(uint16_T temp)
{
  // Graphical Function 'AfterglowTime': '<S427>:210'
  // Transition: '<S427>:222'
  //  Glow plug preheat time
  if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL1) {
    // Transition: '<S427>:223'
    // Transition: '<S427>:225'
    MX_Gtwy_Control_DWork.debounceCount_ivzl =
      CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL0;

    // Transition: '<S427>:234'
    // Transition: '<S427>:233'
    // Transition: '<S427>:232'
  } else {
    // Transition: '<S427>:224'
    if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL2) {
      // Transition: '<S427>:226'
      // Transition: '<S427>:228'
      MX_Gtwy_Control_DWork.debounceCount_ivzl =
        CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL1;

      // Transition: '<S427>:233'
      // Transition: '<S427>:232'
    } else {
      // Transition: '<S427>:227'
      if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL3) {
        // Transition: '<S427>:229'
        // Transition: '<S427>:231'
        MX_Gtwy_Control_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL2;

        // Transition: '<S427>:232'
      } else {
        // Transition: '<S427>:230'
        MX_Gtwy_Control_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_TIME_LEVEL3;
      }
    }
  }

  // Transition: '<S427>:235'
}

// Function for Chart: '<S288>/GlowPlug'
static void MX_Gtwy_Control_PreheatWaitTime(uint16_T temp)
{
  // Graphical Function 'PreheatWaitTime': '<S427>:183'
  // Transition: '<S427>:195'
  //  Glow plug preheat time
  if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL1) {
    // Transition: '<S427>:196'
    // Transition: '<S427>:198'
    MX_Gtwy_Control_DWork.debounceCount_ivzl =
      CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL0;

    // Transition: '<S427>:207'
    // Transition: '<S427>:206'
    // Transition: '<S427>:205'
  } else {
    // Transition: '<S427>:197'
    if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL2) {
      // Transition: '<S427>:199'
      // Transition: '<S427>:201'
      MX_Gtwy_Control_DWork.debounceCount_ivzl =
        CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL1;

      // Transition: '<S427>:206'
      // Transition: '<S427>:205'
    } else {
      // Transition: '<S427>:200'
      if (temp < CONSTANT_DATA->GLOW_PLUG_TEMP_LEVEL3) {
        // Transition: '<S427>:202'
        // Transition: '<S427>:204'
        MX_Gtwy_Control_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL2;

        // Transition: '<S427>:205'
      } else {
        // Transition: '<S427>:203'
        MX_Gtwy_Control_DWork.debounceCount_ivzl =
          CONSTANT_DATA->GLOW_PLUG_WAIT_TIME_LEVEL3;
      }
    }
  }

  // Transition: '<S427>:208'
}

// System initialize for atomic system: '<S4>/GlowPlug'
void MX_Gtwy_Control_GlowPlug_Init(void)
{
  // InitializeConditions for UnitDelay: '<S288>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 = ((uint8_T)8U);

  // InitializeConditions for UnitDelay: '<S288>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti = ((uint8_T)8U);

  // SystemInitialize for Chart: '<S288>/GlowPlug'
  MX_Gtwy_Control_DWork.bitsForTID1.is_ECU = MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gtwy_Control_DWork.bitsForTID1.is_PREHEAT = MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gtwy_Control_DWork.bitsForTID1.is_active_c38_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID1.is_c38_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
  MX_Gtwy_Control_DWork.debounceCount_ivzl = 0U;
  MX_Gtwy_Control_DWork.cycleCount = 0U;
  MX_Gtwy_Control_DWork.bitsForTID1.glowPlugAfterGlowDone = false;
  MX_Gtwy_Control_DWork.state_CrankTimerExpired = 0U;
  MX_Gtwy_Control_DWork.debounceCrank = 0U;
  dout_GlowPlug = false;
  count_GlowPlug = 0U;

  // SystemInitialize for Enabled SubSystem: '<S288>/relay_oc'
  MX_Gtwy_Control_relay_oc_Init(&state_GlowPlugOutput, &state_GlowPlugRelay,
    &MX_Gtwy_Control_B.relay_oc_dsbs, &MX_Gtwy_Control_DWork.relay_oc_dsbs);

  // End of SystemInitialize for SubSystem: '<S288>/relay_oc'
}

// Output and update for atomic system: '<S4>/GlowPlug'
void MX_Gtwy_Control_GlowPlug(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;
  uint16_T temp_Lowest;

  // Lookup: '<S288>/ECU_Glow_Time'
  //
  //  About '<S288>/ECU_Glow_Time':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Linear_Endpoint
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  LookUp_U16_U16_SAT( &(MX_Gtwy_Control_B.time_GlowPlug),
                     (&(MXGTW_ECU_GLOW_TIME[0])),
                     MX_Gtwy_Control_B.RateTransition26, (&(MXGTW_ECU_GLOW_TEMP
    [0])), 15U);

  // Switch: '<S288>/Switch' incorporates:
  //   Constant: '<S288>/FunctionState1'
  //   Constant: '<S426>/Constant'
  //   Logic: '<S288>/Logical Operator'
  //   RelationalOperator: '<S288>/Relational Operator'
  //   RelationalOperator: '<S426>/Compare'

  if ((CONSTANT_DATA->HOT_FUNCTION != NON_FUNCTIONAL) && (flt_HOT < flt_ECT)) {
    temp_Lowest = flt_HOT;
  } else {
    temp_Lowest = flt_ECT;
  }

  // End of Switch: '<S288>/Switch'

  // Chart: '<S288>/GlowPlug' incorporates:
  //   UnitDelay: '<S288>/Unit Delay'
  //   UnitDelay: '<S288>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
  // During: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID1.is_active_c38_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
    MX_Gtwy_Control_DWork.bitsForTID1.is_active_c38_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/GlowPlug/GlowPlug
    // Transition: '<S427>:247'
    MX_Gtwy_Control_DWork.bitsForTID1.is_c38_MX_Gtwy_Control =
      MX_Gtwy__IN_NON_FUNCTIONAL_pvlo;

    // Entry 'NON_FUNCTIONAL': '<S427>:246'
    dout_GlowPlug = ((int32_T)INACTIVE != 0);
    count_GlowPlug = 0U;
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID1.is_c38_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_ECU_ljaf:
      // During 'ECU': '<S427>:245'
      switch (MX_Gtwy_Control_DWork.bitsForTID1.is_ECU) {
       case MX_Gtwy_Control_IN_Countdown:
        // During 'Countdown': '<S427>:252'
        if ((MX_Gtwy_Control_B.RateTransition16_hyai == ENGINE_RUNNING) ||
            (MX_Gtwy_Control_B.RateTransition24_bca5 == INACTIVE) || ((int32_T)
             count_GlowPlug == 0)) {
          // Transition: '<S427>:255'
          MX_Gtwy_Control_DWork.bitsForTID1.is_ECU = MX_Gtwy_Control_IN_Stop;

          // Entry 'Stop': '<S427>:254'
          count_GlowPlug = 0U;
        } else {
          count_GlowPlug = (uint16_T)(int32_T)((int32_T)count_GlowPlug - 1);
        }
        break;

       case MX_Gtwy_Control_IN_Stop:
        // During 'Stop': '<S427>:254'
        if ((MX_Gtwy_Control_B.RateTransition16_hyai == ENGINE_NOT_RUNNING) &&
            (MX_Gtwy_Control_B.RateTransition24_bca5 == INACTIVE)) {
          // Transition: '<S427>:256'
          MX_Gtwy_Control_DWork.bitsForTID1.is_ECU = MX_Gtwy_Control_IN_Wait;

          // Entry 'Wait': '<S427>:250'
          count_GlowPlug = 0U;
        }
        break;

       default:
        // During 'Wait': '<S427>:250'
        if ((MX_Gtwy_Control_B.RateTransition24_bca5 == ACTIVE) &&
            (MX_Gtwy_Control_B.RateTransition27_chza == NORMAL)) {
          // Transition: '<S427>:253'
          MX_Gtwy_Control_DWork.bitsForTID1.is_ECU =
            MX_Gtwy_Control_IN_Countdown;

          // Entry 'Countdown': '<S427>:252'
          count_GlowPlug = MX_Gtwy_Control_B.time_GlowPlug;
        }
        break;
      }
      break;

     case MX_Gtwy__IN_NON_FUNCTIONAL_pvlo:
      // During 'NON_FUNCTIONAL': '<S427>:246'
      if ((CONSTANT_DATA->ECU_FUNCTION == ECU_J1939) &&
          (CONSTANT_DATA->GLOW_PLUG_ECU_COUNTDOWN_FUNCTION != NON_FUNCTIONAL)) {
        // Transition: '<S427>:248'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c38_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ECU_ljaf;

        // Entry Internal 'ECU': '<S427>:245'
        // Transition: '<S427>:251'
        MX_Gtwy_Control_DWork.bitsForTID1.is_ECU = MX_Gtwy_Control_IN_Wait;

        // Entry 'Wait': '<S427>:250'
        count_GlowPlug = 0U;
      } else {
        // Transition: '<S427>:249'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c38_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_NORMAL_jia4;

        // Entry Internal 'NORMAL': '<S427>:244'
        // Transition: '<S427>:97'
        MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
          MX_Gtwy_Control_IN_WAIT_STARTUP;

        // Entry 'WAIT_STARTUP': '<S427>:96'
        dout_GlowPlug = false;
        MX_Gtwy_Control_DWork.debounceCrank = 0U;
      }
      break;

     default:
      // During 'NORMAL': '<S427>:244'
      switch (MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL) {
       case MX_Gtwy_Control_IN_AFTERGLOW:
        // During 'AFTERGLOW': '<S427>:4'
        if (((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl == 0) ||
            (!((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
               (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == FAILURE))) ||
            (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti != NORMAL) ||
            (MX_Gtwy_Control_B.RateTransition44 != SYS_NORMAL)) {
          // Transition: '<S427>:12'
          // Exit 'AFTERGLOW': '<S427>:4'
          MX_Gtwy_Control_DWork.bitsForTID1.glowPlugAfterGlowDone = ((int32_T)
            ACTIVE != 0);
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Contro_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S427>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S427>:2'
          // Transition: '<S427>:38'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_Control_IN_CRANKING;
        } else {
          MX_Gtwy_Control_DWork.debounceCount_ivzl = (uint16_T)(int32_T)
            ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl - 1);
        }
        break;

       case MX_Gtwy_Co_IN_GLOW_DURING_CRANK:
        // During 'GLOW_DURING_CRANK': '<S427>:6'
        if ((MX_Gtwy_Control_B.RateTransition16_hyai != ENGINE_CRANKING) ||
            (!((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
               (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == FAILURE))) ||
            (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti != NORMAL) ||
            (state_VBattery == OORL) || (MX_Gtwy_Control_B.RateTransition44 !=
             SYS_NORMAL) || ((MX_Gtwy_Control_DWork.debounceCrank >=
                              CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_CRANK) &&
                             (CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_CRANK !=
                              UNLIMITED))) {
          // Transition: '<S427>:35'
          // Exit 'GLOW_DURING_CRANK': '<S427>:6'
          MX_Gtwy_Control_DWork.state_CrankTimerExpired = ACTIVE;
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Contro_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S427>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S427>:2'
          // Transition: '<S427>:38'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_Control_IN_CRANKING;
        } else {
          MX_Gtwy_Control_DWork.debounceCrank = (uint16_T)(int32_T)((int32_T)
            MX_Gtwy_Control_DWork.debounceCrank + 1);
        }
        break;

       case MX_Gtwy_Contro_IN_INACTIVE_lvoc:
        // During 'INACTIVE': '<S427>:2'
        if ((CONSTANT_DATA->GLOW_PLUG_AFTERGLOW_FUNCTION != NON_FUNCTIONAL) &&
            (MX_Gtwy_Control_B.RateTransition16_hyai == ENGINE_RUNNING) &&
            ((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
             (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == FAILURE)) &&
            (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti == NORMAL) &&
            (MX_Gtwy_Control_DWork.bitsForTID1.glowPlugAfterGlowDone == (int32_T)
             INACTIVE)) {
          // Transition: '<S427>:11'
          MX_Gtwy_Control_AfterglowTime(temp_Lowest);

          // Exit Internal 'INACTIVE': '<S427>:2'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Control_IN_AFTERGLOW;

          // Entry 'AFTERGLOW': '<S427>:4'
          dout_GlowPlug = ((int32_T)ACTIVE != 0);
          count_GlowPlug = 0U;
        } else if ((CONSTANT_DATA->GLOW_PLUG_CRANKING_FUNCTION != NON_FUNCTIONAL)
                   && (state_VBattery != OORL) &&
                   (MX_Gtwy_Control_B.RateTransition16_hyai == ENGINE_CRANKING) &&
                   ((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
                    (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == FAILURE)) &&
                   (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti == NORMAL) &&
                   (MX_Gtwy_Control_DWork.state_CrankTimerExpired != ACTIVE)) {
          // Transition: '<S427>:36'
          // Exit Internal 'INACTIVE': '<S427>:2'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Co_IN_GLOW_DURING_CRANK;

          // Entry 'GLOW_DURING_CRANK': '<S427>:6'
          dout_GlowPlug = ((int32_T)ACTIVE != 0);
          MX_Gtwy_Control_DWork.debounceCrank = 0U;
          MX_Gtwy_Control_DWork.bitsForTID1.glowPlugAfterGlowDone = ((int32_T)
            INACTIVE != 0);
        } else if ((CONSTANT_DATA->GLOW_PLUG_PREHEAT_FUNCTION != NON_FUNCTIONAL)
                   && (MX_Gtwy_Control_DWork.cycleCount <
                       CONSTANT_DATA->GLOW_PLUG_PREHEAT_COUNTER) &&
                   (state_VBattery != OORL) &&
                   ((CONSTANT_DATA->GLOW_PLUG_OFF_WITH_LOW_BATTERY ==
                     NON_FUNCTIONAL) || (state_VBattery == NORMAL) ||
                    (state_VBattery == HIGH)) &&
                   ((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
                    (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == FAILURE)) &&
                   (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti == NORMAL) &&
                   (MX_Gtwy_Control_B.RateTransition16_hyai ==
                    ENGINE_NOT_RUNNING) && (MX_Gtwy_Control_B.RateTransition44 ==
                    SYS_NORMAL)) {
          // Transition: '<S427>:9'
          MX_Gtwy_Control_PreheatTime(temp_Lowest);

          // Exit Internal 'INACTIVE': '<S427>:2'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Control_IN_PREHEAT;

          // Entry Internal 'PREHEAT': '<S427>:242'
          // Transition: '<S427>:243'
          MX_Gtwy_Control_DWork.bitsForTID1.is_PREHEAT =
            MX_Gtwy_Control_IN_PREGLOW;

          // Entry Internal 'PREGLOW': '<S427>:3'
          // Transition: '<S427>:30'
          if ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl != 0) {
            // Transition: '<S427>:31'
            // Transition: '<S427>:32'
            dout_GlowPlug = ((int32_T)ACTIVE != 0);

            // Transition: '<S427>:33'
          } else {
            // Transition: '<S427>:34'
            dout_GlowPlug = ((int32_T)INACTIVE != 0);
          }
        } else if ((MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE ==
                    MX_Gtwy_Control_IN_CRANKING) &&
                   ((MX_Gtwy_Control_B.RateTransition16_hyai != ENGINE_CRANKING)
                    && (CONSTANT_DATA->GLOW_PLUG_CRANKING_FUNCTION !=
                        NON_FUNCTIONAL))) {
          // During 'CRANKING': '<S427>:8'
          // Transition: '<S427>:37'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_Control_IN_RESET_CRANK;

          // Entry 'RESET_CRANK': '<S427>:7'
          MX_Gtwy_Control_DWork.state_CrankTimerExpired = INACTIVE;
        } else {
          // During 'RESET_CRANK': '<S427>:7'
        }
        break;

       case MX_Gtwy_Control_IN_PREHEAT:
        // During 'PREHEAT': '<S427>:242'
        if ((MX_Gtwy_Control_B.RateTransition16_hyai == ENGINE_RUNNING) ||
            (MX_Gtwy_Control_B.RateTransition16_hyai == ENGINE_CRANKING) ||
            (!((MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == NORMAL) ||
               (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 == FAILURE))) ||
            (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti != NORMAL) ||
            (MX_Gtwy_Control_B.RateTransition44 != SYS_NORMAL) ||
            (state_VBattery == OORL) || (MX_Gtwy_Control_DWork.cycleCount >=
             CONSTANT_DATA->GLOW_PLUG_PREHEAT_COUNTER)) {
          // Transition: '<S427>:26'
          MX_Gtwy_Control_DWork.cycleCount = (uint16_T)
            CONSTANT_DATA->GLOW_PLUG_PREHEAT_COUNTER;

          // Exit Internal 'PREHEAT': '<S427>:242'
          MX_Gtwy_Control_DWork.bitsForTID1.is_PREHEAT =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_mnel;
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Contro_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S427>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S427>:2'
          // Transition: '<S427>:38'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_Control_IN_CRANKING;
        } else if (MX_Gtwy_Control_DWork.bitsForTID1.is_PREHEAT ==
                   MX_Gtwy_Control_IN_PREGLOW) {
          // During 'PREGLOW': '<S427>:3'
          if ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl == 0) {
            // Transition: '<S427>:21'
            MX_Gtwy_Control_PreheatWaitTime(temp_Lowest);
            MX_Gtwy_Control_DWork.bitsForTID1.is_PREHEAT =
              MX_Gtwy_Control_IN_PREGLOW_WAIT;

            // Entry 'PREGLOW_WAIT': '<S427>:1'
            dout_GlowPlug = ((int32_T)INACTIVE != 0);
            MX_Gtwy_Control_DWork.cycleCount = (uint16_T)(int32_T)((int32_T)
              MX_Gtwy_Control_DWork.cycleCount + 1);
          } else {
            MX_Gtwy_Control_DWork.debounceCount_ivzl = (uint16_T)(int32_T)
              ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl - 1);
            count_GlowPlug = MX_Gtwy_Control_DWork.debounceCount_ivzl;
          }
        } else {
          // During 'PREGLOW_WAIT': '<S427>:1'
          if ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl == 0) {
            // Transition: '<S427>:22'
            MX_Gtwy_Control_PreheatTime(temp_Lowest);
            MX_Gtwy_Control_DWork.bitsForTID1.is_PREHEAT =
              MX_Gtwy_Control_IN_PREGLOW;

            // Entry Internal 'PREGLOW': '<S427>:3'
            // Transition: '<S427>:30'
            if ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl != 0) {
              // Transition: '<S427>:31'
              // Transition: '<S427>:32'
              dout_GlowPlug = ((int32_T)ACTIVE != 0);

              // Transition: '<S427>:33'
            } else {
              // Transition: '<S427>:34'
              dout_GlowPlug = ((int32_T)INACTIVE != 0);
            }
          } else {
            MX_Gtwy_Control_DWork.debounceCount_ivzl = (uint16_T)(int32_T)
              ((int32_T)MX_Gtwy_Control_DWork.debounceCount_ivzl - 1);
          }
        }
        break;

       default:
        // During 'WAIT_STARTUP': '<S427>:96'
        if ((int32_T)MX_Gtwy_Control_DWork.debounceCrank > 3) {
          // Transition: '<S427>:29'
          MX_Gtwy_Control_DWork.bitsForTID1.is_NORMAL =
            MX_Gtwy_Contro_IN_INACTIVE_lvoc;

          // Entry 'INACTIVE': '<S427>:2'
          dout_GlowPlug = ((int32_T)INACTIVE != 0);
          count_GlowPlug = 0U;

          // Entry Internal 'INACTIVE': '<S427>:2'
          // Transition: '<S427>:38'
          MX_Gtwy_Control_DWork.bitsForTID1.is_INACTIVE =
            MX_Gtwy_Control_IN_CRANKING;
        } else {
          MX_Gtwy_Control_DWork.debounceCrank = (uint16_T)(int32_T)((int32_T)
            MX_Gtwy_Control_DWork.debounceCrank + 1);
        }
        break;
      }
      break;
    }
  }

  // End of Chart: '<S288>/GlowPlug'

  // SignalConversion: '<S288>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S288>/FunctionState'
  //   Constant: '<S424>/Constant'
  //   Constant: '<S425>/Constant'
  //   Logic: '<S288>/Logical Operator1'
  //   RelationalOperator: '<S424>/Compare'
  //   RelationalOperator: '<S425>/Compare'

  rtb_HiddenBuf_InsertedFor_relay =
    ((CONSTANT_DATA->GLOW_PLUG_PREHEAT_FEEDBACK_FUNCTION != NON_FUNCTIONAL) &&
     (state_VBattery != OORL));

  // Outputs for Enabled SubSystem: '<S288>/relay_oc'
  MX_Gtwy_Control_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_GlowPlug,
    MX_Gtwy_Control_B.RateTransition29_kajv,
    MX_Gtwy_Control_B.RateTransition30_mgbl, &state_GlowPlugOutput,
    &state_GlowPlugRelay, &MX_Gtwy_Control_B.relay_oc_dsbs,
    &MX_Gtwy_Control_DWork.relay_oc_dsbs,
    CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_ERROR_ON,
    CONSTANT_DATA->GLOW_PLUG_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S288>/relay_oc'

  // Update for UnitDelay: '<S288>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE_jdy3 = state_GlowPlugOutput;

  // Update for UnitDelay: '<S288>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_awti = state_GlowPlugRelay;
}

// System initialize for atomic system: '<S4>/Hyd_Bypass'
void MX_Gtwy_Control_Hyd_Bypass_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S289>/Hyd_Bypass'
  // SystemInitialize for Chart: '<S432>/Hyd_Bypass'
  MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_k5om;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c59_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_k5om;
  MX_Gtwy_Control_B.dout_HydBypass = false;

  // SystemInitialize for Atomic SubSystem: '<S432>/output_pair_open_loop'
  MX_Gt_output_pair_OpenLoop_Init(&MX_Gtwy_Control_B.hs_cmd_bwye,
    &MX_Gtwy_Control_B.ls_cmd_kapg, &MX_Gtwy_Control_B.state_Output_ad00,
    &MX_Gtwy_Control_B.output_pair_open_loop_ckv4,
    &MX_Gtwy_Control_DWork.output_pair_open_loop_ckv4);

  // End of SystemInitialize for SubSystem: '<S432>/output_pair_open_loop'

  // End of SystemInitialize for SubSystem: '<S289>/Hyd_Bypass'
}

// Output and update for atomic system: '<S4>/Hyd_Bypass'
void MX_Gtwy_Control_Hyd_Bypass(void)
{
  boolean_T rtb_Compare_b4rp;

  // Outputs for Enabled SubSystem: '<S289>/Hyd_Bypass' incorporates:
  //   EnablePort: '<S432>/Enable'

  // Logic: '<S289>/Logical Operator' incorporates:
  //   Constant: '<S289>/Constant'
  //   Constant: '<S430>/Constant'
  //   Constant: '<S431>/Constant'
  //   Inport: '<Root>/afbk_HydBypass'
  //   Inport: '<Root>/ain_PrecisionReference'
  //   Inport: '<Root>/ifbk_HydBypass'
  //   Inport: '<Root>/state_System'
  //   RelationalOperator: '<S430>/Compare'
  //   RelationalOperator: '<S431>/Compare'

  if ((state_System == SYS_NORMAL) && (CONSTANT_DATA->HYD_BYPASS_FUNCTION !=
       NON_FUNCTIONAL)) {
    if (!MX_Gtwy_Control_DWork.Hyd_Bypass_MODE) {
      // SystemReset for Chart: '<S432>/Hyd_Bypass'
      MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_k5om;
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c59_MX_Gtwy_Control = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_k5om;
      MX_Gtwy_Control_B.dout_HydBypass = false;

      // SystemReset for Atomic SubSystem: '<S432>/output_pair_open_loop'
      MX_G_output_pair_OpenLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_bwye,
        &MX_Gtwy_Control_B.ls_cmd_kapg, &MX_Gtwy_Control_B.state_Output_ad00,
        &MX_Gtwy_Control_B.output_pair_open_loop_ckv4,
        &MX_Gtwy_Control_DWork.output_pair_open_loop_ckv4);

      // End of SystemReset for SubSystem: '<S432>/output_pair_open_loop'
      MX_Gtwy_Control_DWork.Hyd_Bypass_MODE = true;
    }

    // RelationalOperator: '<S433>/Compare' incorporates:
    //   Constant: '<S433>/Constant'

    rtb_Compare_b4rp = (state_Console != ACTIVE);

    // Chart: '<S432>/Hyd_Bypass'
    // Gateway: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass
    if ((uint32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 < 255U) {
      MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 = (uint8_T)(int32_T)
        ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass
    if ((uint32_T)
        MX_Gtwy_Control_DWork.bitsForTID0.is_active_c59_MX_Gtwy_Control == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c59_MX_Gtwy_Control = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Hyd_Bypass/Hyd_Bypass/Hyd_Bypass 
      // Transition: '<S434>:36'
      MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
        MX_Gtwy_Control_IN_Not_Cranking;

      // Entry Internal 'Not_Cranking': '<S434>:14'
      // Transition: '<S434>:21'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
        MX_Gtwy_Control_IN_Off_chbn;

      // Entry 'Off': '<S434>:2'
      MX_Gtwy_Control_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
    } else {
      switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control) {
       case MX_Gtwy_Control_IN_Cranking:
        // During 'Cranking': '<S434>:15'
        if (state_Engine != ENGINE_CRANKING) {
          // Transition: '<S434>:33'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_Delay_dyin;
          MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 = 0U;
        }
        break;

       case MX_Gtwy_Control_IN_Delay_dyin:
        // During 'Delay': '<S434>:16'
        if (MX_Gtwy_Control_DWork.temporalCounter_i1_iy55 >=
            CONSTANT_DATA->HYD_BYPASS_CRANK_DELAY) {
          // Transition: '<S434>:35'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_Not_Cranking;

          // Entry Internal 'Not_Cranking': '<S434>:14'
          // Transition: '<S434>:21'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
            MX_Gtwy_Control_IN_Off_chbn;

          // Entry 'Off': '<S434>:2'
          MX_Gtwy_Control_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
        } else {
          if (state_Engine == ENGINE_CRANKING) {
            // Transition: '<S434>:34'
            MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
              MX_Gtwy_Control_IN_Cranking;

            // Entry 'Cranking': '<S434>:15'
            MX_Gtwy_Control_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
          }
        }
        break;

       default:
        // During 'Not_Cranking': '<S434>:14'
        if (state_Engine == ENGINE_CRANKING) {
          // Transition: '<S434>:32'
          // Exit Internal 'Not_Cranking': '<S434>:14'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_k5om;
          MX_Gtwy_Control_DWork.bitsForTID0.is_c59_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_Cranking;

          // Entry 'Cranking': '<S434>:15'
          MX_Gtwy_Control_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht ==
                   MX_Gtwy_Control_IN_Off_chbn) {
          // During 'Off': '<S434>:2'
          if (state_Console == ACTIVE) {
            // Transition: '<S434>:20'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
              MX_Gtwy_Control_IN_On_cbgn;

            // Entry 'On': '<S434>:9'
            MX_Gtwy_Control_B.dout_HydBypass = ((int32_T)ACTIVE != 0);
          }
        } else {
          // During 'On': '<S434>:9'
          if (state_Console != ACTIVE) {
            // Transition: '<S434>:18'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking_jyht =
              MX_Gtwy_Control_IN_Off_chbn;

            // Entry 'Off': '<S434>:2'
            MX_Gtwy_Control_B.dout_HydBypass = ((int32_T)INACTIVE != 0);
          }
        }
        break;
      }
    }

    // End of Chart: '<S432>/Hyd_Bypass'

    // Outputs for Atomic SubSystem: '<S432>/output_pair_open_loop'
    MX_Gtwy_Co_output_pair_OpenLoop(MX_Gtwy_Control_B.dout_HydBypass,
      rtb_Compare_b4rp, state_Engine, afbk_HydBypass, ifbk_HydBypass,
      MX_Gtwy_Control_B.RateTransition12_a0us, MX_Gtwy_Control_B.RateTransition1,
      ain_PrecisionReference, &MX_Gtwy_Control_B.hs_cmd_bwye,
      &MX_Gtwy_Control_B.ls_cmd_kapg, &MX_Gtwy_Control_B.state_Output_ad00,
      &MX_Gtwy_Control_B.output_pair_open_loop_ckv4,
      &MX_Gtwy_Control_DWork.output_pair_open_loop_ckv4,
      CONSTANT_DATA->HYD_BYPASS_MAX_VOLTS,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_BYPASS_OVERCURRENT,
      CONSTANT_DATA->HYD_BYPASS_NON_ZERO_DUTY,
      CONSTANT_DATA->HYD_BYPASS_NON_ZERO_CURRENT,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_BYPASS_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->HYD_BYPASS_FEEDBACK_FUNCTION,
      CONSTANT_DATA->HYD_BYPASS_AFBK_GAIN, CONSTANT_DATA->HYD_BYPASS_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S432>/output_pair_open_loop'

    // SignalConversion: '<S432>/OutportBufferForhs_HydBypass' incorporates:
    //   Inport: '<Root>/afbk_HydBypass'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_HydBypass'

    hs_HydBypass = MX_Gtwy_Control_B.hs_cmd_bwye;

    // SignalConversion: '<S432>/OutportBufferForls_HydBypass'
    ls_HydBypass = MX_Gtwy_Control_B.ls_cmd_kapg;

    // SignalConversion: '<S432>/OutportBufferForstate_HydBypass'
    state_HydBypass = MX_Gtwy_Control_B.state_Output_ad00;
  } else {
    if (MX_Gtwy_Control_DWork.Hyd_Bypass_MODE) {
      // Disable for Outport: '<S432>/state_HydBypass'
      state_HydBypass = ((uint8_T)0U);

      // Disable for Outport: '<S432>/hs_HydBypass'
      hs_HydBypass = ((uint16_T)0U);

      // Disable for Outport: '<S432>/ls_HydBypass'
      ls_HydBypass = false;
      MX_Gtwy_Control_DWork.Hyd_Bypass_MODE = false;
    }
  }

  // End of Logic: '<S289>/Logical Operator'
  // End of Outputs for SubSystem: '<S289>/Hyd_Bypass'
}

// System initialize for atomic system: '<S4>/Hyd_Enable'
void MX_Gtwy_Control_Hyd_Enable_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S290>/Hyd_Enable'
  // SystemInitialize for Chart: '<S451>/Hyd_Enable'
  MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_pdyo;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c11_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_pdyo;
  MX_Gtwy_Control_B.dout_HydEnable = false;

  // SystemInitialize for Atomic SubSystem: '<S451>/output_pair_open_loop'
  MX_Gt_output_pair_OpenLoop_Init(&MX_Gtwy_Control_B.hs_cmd_jt20,
    &MX_Gtwy_Control_B.ls_cmd_g0eq, &MX_Gtwy_Control_B.state_Output_giiq,
    &MX_Gtwy_Control_B.output_pair_open_loop_gaik,
    &MX_Gtwy_Control_DWork.output_pair_open_loop_gaik);

  // End of SystemInitialize for SubSystem: '<S451>/output_pair_open_loop'

  // End of SystemInitialize for SubSystem: '<S290>/Hyd_Enable'
}

// Output and update for atomic system: '<S4>/Hyd_Enable'
void MX_Gtwy_Control_Hyd_Enable(void)
{
  boolean_T rtb_Compare_mkj3;
  boolean_T rtb_Switch_fq53;

  // Outputs for Enabled SubSystem: '<S290>/Hyd_Enable' incorporates:
  //   EnablePort: '<S451>/Enable'

  // RelationalOperator: '<S450>/Compare' incorporates:
  //   Constant: '<S450>/Constant'
  //   Inport: '<Root>/afbk_HydEnable'
  //   Inport: '<Root>/ain_PrecisionReference'
  //   Inport: '<Root>/ifbk_HydEnable'
  //   Inport: '<Root>/state_System'

  if (state_System == SYS_NORMAL) {
    if (!MX_Gtwy_Control_DWork.Hyd_Enable_MODE) {
      // SystemReset for Chart: '<S451>/Hyd_Enable'
      MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_pdyo;
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c11_MX_Gtwy_Control = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_pdyo;
      MX_Gtwy_Control_B.dout_HydEnable = false;

      // SystemReset for Atomic SubSystem: '<S451>/output_pair_open_loop'
      MX_G_output_pair_OpenLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_jt20,
        &MX_Gtwy_Control_B.ls_cmd_g0eq, &MX_Gtwy_Control_B.state_Output_giiq,
        &MX_Gtwy_Control_B.output_pair_open_loop_gaik,
        &MX_Gtwy_Control_DWork.output_pair_open_loop_gaik);

      // End of SystemReset for SubSystem: '<S451>/output_pair_open_loop'
      MX_Gtwy_Control_DWork.Hyd_Enable_MODE = true;
    }

    // RelationalOperator: '<S452>/Compare' incorporates:
    //   Constant: '<S452>/Constant'

    rtb_Compare_mkj3 = (state_Console != ACTIVE);

    // Chart: '<S451>/Hyd_Enable'
    // Gateway: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable
    if ((uint32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp < 255U) {
      MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp = (uint8_T)(int32_T)
        ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable
    if ((uint32_T)
        MX_Gtwy_Control_DWork.bitsForTID0.is_active_c11_MX_Gtwy_Control == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c11_MX_Gtwy_Control = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Hyd_Enable/Hyd_Enable/Hyd_Enable 
      // Transition: '<S453>:36'
      MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
        MX_Gtwy_Co_IN_Not_Cranking_llua;

      // Entry Internal 'Not_Cranking': '<S453>:14'
      // Transition: '<S453>:21'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
        MX_Gtwy_Control_IN_Off_cbc5;

      // Entry 'Off': '<S453>:2'
      MX_Gtwy_Control_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
    } else {
      switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control) {
       case MX_Gtwy_Contro_IN_Cranking_c5p0:
        // During 'Cranking': '<S453>:15'
        if (state_Engine != ENGINE_CRANKING) {
          // Transition: '<S453>:33'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_Delay_gzfi;
          MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp = 0U;
        }
        break;

       case MX_Gtwy_Control_IN_Delay_gzfi:
        // During 'Delay': '<S453>:16'
        if (MX_Gtwy_Control_DWork.temporalCounter_i1_jqtp >=
            CONSTANT_DATA->HYD_ENABLE_CRANK_DELAY) {
          // Transition: '<S453>:35'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
            MX_Gtwy_Co_IN_Not_Cranking_llua;

          // Entry Internal 'Not_Cranking': '<S453>:14'
          // Transition: '<S453>:21'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
            MX_Gtwy_Control_IN_Off_cbc5;

          // Entry 'Off': '<S453>:2'
          MX_Gtwy_Control_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
        } else {
          if (state_Engine == ENGINE_CRANKING) {
            // Transition: '<S453>:34'
            MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
              MX_Gtwy_Contro_IN_Cranking_c5p0;

            // Entry 'Cranking': '<S453>:15'
            MX_Gtwy_Control_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
          }
        }
        break;

       default:
        // During 'Not_Cranking': '<S453>:14'
        if (state_Engine == ENGINE_CRANKING) {
          // Transition: '<S453>:32'
          // Exit Internal 'Not_Cranking': '<S453>:14'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_pdyo;
          MX_Gtwy_Control_DWork.bitsForTID0.is_c11_MX_Gtwy_Control =
            MX_Gtwy_Contro_IN_Cranking_c5p0;

          // Entry 'Cranking': '<S453>:15'
          MX_Gtwy_Control_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking ==
                   MX_Gtwy_Control_IN_Off_cbc5) {
          // During 'Off': '<S453>:2'
          if (state_Console == ACTIVE) {
            // Transition: '<S453>:20'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
              MX_Gtwy_Control_IN_On_f50i;

            // Entry 'On': '<S453>:9'
            MX_Gtwy_Control_B.dout_HydEnable = ((int32_T)ACTIVE != 0);
          }
        } else {
          // During 'On': '<S453>:9'
          if (state_Console != ACTIVE) {
            // Transition: '<S453>:18'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Not_Cranking =
              MX_Gtwy_Control_IN_Off_cbc5;

            // Entry 'Off': '<S453>:2'
            MX_Gtwy_Control_B.dout_HydEnable = ((int32_T)INACTIVE != 0);
          }
        }
        break;
      }
    }

    // End of Chart: '<S451>/Hyd_Enable'

    // Switch: '<S451>/Switch' incorporates:
    //   Constant: '<S451>/Constant'
    //   Inport: '<Root>/state_Inverter'

    if (CONSTANT_DATA->EMEA_ELECTRIC_VERSION >= ((uint8_T)0U)) {
      rtb_Switch_fq53 = ((int32_T)state_Inverter != 0);
    } else {
      rtb_Switch_fq53 = MX_Gtwy_Control_B.dout_HydEnable;
    }

    // End of Switch: '<S451>/Switch'

    // Outputs for Atomic SubSystem: '<S451>/output_pair_open_loop'
    MX_Gtwy_Co_output_pair_OpenLoop(rtb_Switch_fq53, rtb_Compare_mkj3,
      state_Engine, afbk_HydEnable, ifbk_HydEnable,
      MX_Gtwy_Control_B.RateTransition15_ozmr,
      MX_Gtwy_Control_B.RateTransition13, ain_PrecisionReference,
      &MX_Gtwy_Control_B.hs_cmd_jt20, &MX_Gtwy_Control_B.ls_cmd_g0eq,
      &MX_Gtwy_Control_B.state_Output_giiq,
      &MX_Gtwy_Control_B.output_pair_open_loop_gaik,
      &MX_Gtwy_Control_DWork.output_pair_open_loop_gaik,
      CONSTANT_DATA->HYD_ENABLE_MAX_VOLTS,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_ENABLE_OVERCURRENT,
      CONSTANT_DATA->HYD_ENABLE_NON_ZERO_DUTY,
      CONSTANT_DATA->HYD_ENABLE_NON_ZERO_CURRENT,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->HYD_ENABLE_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->HYD_ENABLE_FEEDBACK_FUNCTION,
      CONSTANT_DATA->HYD_ENABLE_AFBK_GAIN, CONSTANT_DATA->HYD_ENABLE_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S451>/output_pair_open_loop'

    // SignalConversion: '<S451>/OutportBufferForhs_HydEnable' incorporates:
    //   Inport: '<Root>/afbk_HydEnable'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_HydEnable'

    hs_HydEnable = MX_Gtwy_Control_B.hs_cmd_jt20;

    // SignalConversion: '<S451>/OutportBufferForls_HydEnable'
    ls_HydEnable = MX_Gtwy_Control_B.ls_cmd_g0eq;

    // SignalConversion: '<S451>/OutportBufferForstate_HydEnable'
    state_HydEnable = MX_Gtwy_Control_B.state_Output_giiq;
  } else {
    if (MX_Gtwy_Control_DWork.Hyd_Enable_MODE) {
      // Disable for Outport: '<S451>/state_HydEnable'
      state_HydEnable = ((uint8_T)0U);

      // Disable for Outport: '<S451>/hs_HydEnable'
      hs_HydEnable = ((uint16_T)0U);

      // Disable for Outport: '<S451>/ls_HydEnable'
      ls_HydEnable = false;
      MX_Gtwy_Control_DWork.Hyd_Enable_MODE = false;
    }
  }

  // End of RelationalOperator: '<S450>/Compare'
  // End of Outputs for SubSystem: '<S290>/Hyd_Enable'
}

// System initialize for atomic system: '<S4>/Hydraulic_Exchange'
void MX_Gtwy_Hydraulic_Exchange_Init(void)
{
  // SystemInitialize for Chart: '<S291>/Hydraulic_Xchange'
  MX_Gtwy_Control_DWork.bitsForTID1.is_Functional_pmyt =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_daqq;
  MX_Gtwy_Control_DWork.bitsForTID1.is_active_c46_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID1.is_c46_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_daqq;
  dout_HydExchange = false;

  // SystemInitialize for Enabled SubSystem: '<S291>/dout_chk'
  MX_Gtwy_Control_dout_chk_Init(&state_HydExchange,
    &MX_Gtwy_Control_B.dout_chk_ci2g, &MX_Gtwy_Control_DWork.dout_chk_ci2g);

  // End of SystemInitialize for SubSystem: '<S291>/dout_chk'
}

// Output and update for atomic system: '<S4>/Hydraulic_Exchange'
void MX_Gtwy_Cont_Hydraulic_Exchange(void)
{
  boolean_T rtb_LogicalOperator_eydd;

  // Chart: '<S291>/Hydraulic_Xchange' incorporates:
  //   UnitDelay: '<S291>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange
  // During: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID1.is_active_c46_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange
    MX_Gtwy_Control_DWork.bitsForTID1.is_active_c46_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Hydraulic_Exchange/Hydraulic_Xchange 
    // Transition: '<S471>:12'
    MX_Gtwy_Control_DWork.bitsForTID1.is_c46_MX_Gtwy_Control =
      MX_Gtwy_Contro_IN_Nonfunctional;

    // Entry 'Nonfunctional': '<S471>:2'
    dout_HydExchange = ((int32_T)INACTIVE != 0);
  } else if (MX_Gtwy_Control_DWork.bitsForTID1.is_c46_MX_Gtwy_Control ==
             MX_Gtwy_Control_IN_Functional) {
    // During 'Functional': '<S471>:3'
    if (MX_Gtwy_Control_DWork.bitsForTID1.is_Functional_pmyt ==
        MX_Gtwy_Control_IN_Active_lofk) {
      // During 'Active': '<S471>:10'
      if ((MX_Gtwy_Control_B.RateTransition17_gzoi != ACTIVE) ||
          (state_HydExchange != NORMAL)) {
        // Transition: '<S471>:23'
        MX_Gtwy_Control_DWork.bitsForTID1.is_Functional_pmyt =
          MX_Gtwy_Contro_IN_Inactive_j3td;

        // Entry 'Inactive': '<S471>:11'
        dout_HydExchange = ((int32_T)INACTIVE != 0);
      }
    } else {
      // During 'Inactive': '<S471>:11'
      if ((MX_Gtwy_Control_B.RateTransition17_gzoi == ACTIVE) &&
          (state_HydExchange == NORMAL)) {
        // Transition: '<S471>:22'
        MX_Gtwy_Control_DWork.bitsForTID1.is_Functional_pmyt =
          MX_Gtwy_Control_IN_Active_lofk;

        // Entry 'Active': '<S471>:10'
        dout_HydExchange = ((int32_T)ACTIVE != 0);
      }
    }
  } else {
    // During 'Nonfunctional': '<S471>:2'
    if (CONSTANT_DATA->HYD_EXCHANGE_FUNCTION != NON_FUNCTIONAL) {
      // Transition: '<S471>:13'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c46_MX_Gtwy_Control =
        MX_Gtwy_Control_IN_Functional;

      // Entry Internal 'Functional': '<S471>:3'
      // Transition: '<S471>:21'
      MX_Gtwy_Control_DWork.bitsForTID1.is_Functional_pmyt =
        MX_Gtwy_Contro_IN_Inactive_j3td;

      // Entry 'Inactive': '<S471>:11'
      dout_HydExchange = ((int32_T)INACTIVE != 0);
    }
  }

  // End of Chart: '<S291>/Hydraulic_Xchange'

  // Logic: '<S291>/Logical Operator' incorporates:
  //   Constant: '<S291>/FunctionState'
  //   Constant: '<S469>/Constant'
  //   Constant: '<S470>/Constant'
  //   RelationalOperator: '<S469>/Compare'
  //   RelationalOperator: '<S470>/Compare'

  rtb_LogicalOperator_eydd = ((CONSTANT_DATA->HYD_EXCHANGE_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // Outputs for Enabled SubSystem: '<S291>/dout_chk'
  MX_Gtwy_Control_dout_chk(rtb_LogicalOperator_eydd, dout_HydExchange,
    MX_Gtwy_Control_B.RateTransition21_dojr, &state_HydExchange,
    &MX_Gtwy_Control_B.dout_chk_ci2g, &MX_Gtwy_Control_DWork.dout_chk_ci2g,
    CONSTANT_DATA->HYD_EXCHANGE_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->HYD_EXCHANGE_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S291>/dout_chk'
}

// System initialize for atomic system: '<S4>/Lights'
void MX_Gtwy_Control_Lights_Init(void)
{
  // InitializeConditions for UnitDelay: '<S292>/Unit Delay3'
  MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_fo0b = NORMAL;

  // InitializeConditions for UnitDelay: '<S292>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_e1ba = NORMAL;

  // SystemInitialize for Chart: '<S292>/Lights'
  MX_Gtwy_Control_DWork.state_Buttons_Old = 0U;

  // Chart: '<S292>/Lights'
  // Entry: MX_Gtwy_Control/Outputs/Lights/Lights
  // Entry Internal: MX_Gtwy_Control/Outputs/Lights/Lights
  // Transition: '<S478>:10'
  MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
    MX_Gtwy_Cont_IN_LIGHTS_INACTIVE;

  // Entry 'LIGHTS_INACTIVE': '<S478>:1'
  dout_Lights = ((int32_T)INACTIVE != 0);

  // SystemInitialize for Enabled SubSystem: '<S292>/dout_chk'
  MX_Gtwy_Control_dout_chk_Init(&MX_Gtwy_Control_B.OutportBufferForstate_futm,
    &MX_Gtwy_Control_B.dout_chk_jzfm, &MX_Gtwy_Control_DWork.dout_chk_jzfm);

  // End of SystemInitialize for SubSystem: '<S292>/dout_chk'

  // SystemInitialize for Enabled SubSystem: '<S292>/relay_oc'
  MX_Gtwy_Control_relay_oc_Init(&MX_Gtwy_Control_B.state_Output_bilf,
    &state_LightsRelay, &MX_Gtwy_Control_B.relay_oc_kvfj,
    &MX_Gtwy_Control_DWork.relay_oc_kvfj);

  // End of SystemInitialize for SubSystem: '<S292>/relay_oc'
}

// Output and update for atomic system: '<S4>/Lights'
void MX_Gtwy_Control_Lights(void)
{
  boolean_T rtb_LogicalOperator1_ochu;
  boolean_T rtb_HiddenBuf_InsertedFor_relay;
  boolean_T rtb_ErrorDetectionEnable;

  // Logic: '<S292>/Logical Operator1' incorporates:
  //   Constant: '<S292>/Light1FeedbackState1'
  //   Constant: '<S476>/Constant'
  //   Constant: '<S477>/Constant'
  //   RelationalOperator: '<S476>/Compare'
  //   RelationalOperator: '<S477>/Compare'

  rtb_LogicalOperator1_ochu = ((CONSTANT_DATA->LIGHTS_RELAY_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // SignalConversion: '<S292>/HiddenBuf_InsertedFor_relay_oc_at_inport_3'
  rtb_HiddenBuf_InsertedFor_relay = rtb_LogicalOperator1_ochu;

  // Chart: '<S292>/Lights' incorporates:
  //   UnitDelay: '<S292>/Unit Delay1'
  //   UnitDelay: '<S292>/Unit Delay3'

  // Gateway: MX_Gtwy_Control/Outputs/Lights/Lights
  // During: MX_Gtwy_Control/Outputs/Lights/Lights
  switch (MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control) {
   case MX_Gtwy_Contro_IN_LIGHTS_ACTIVE:
    // During 'LIGHTS_ACTIVE': '<S478>:2'
    if (((MX_Gtwy_Control_DWork.state_Buttons_Old == NO_COMMUNICATION) &&
         (MX_Gtwy_Control_B.RateTransition22_crtc != NO_COMMUNICATION)) ||
        (!((state_VBattery == NORMAL) || (state_VBattery == LOW))) ||
        (MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_fo0b != NORMAL) ||
        (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_e1ba != NORMAL)) {
      // Transition: '<S478>:14'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
        MX_Gtwy_Cont_IN_LIGHTS_INACTIVE;

      // Entry 'LIGHTS_INACTIVE': '<S478>:1'
      dout_Lights = ((int32_T)INACTIVE != 0);
    } else {
      if (MX_Gtwy_Control_B.RateTransition36_ijpl == (int32_T)ACTIVE) {
        // Transition: '<S478>:16'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
          MX_Gtw_IN_LIGHTS_ACTIVE_RISING2;

        // Entry 'LIGHTS_ACTIVE_RISING2': '<S478>:5'
        dout_Lights = ((int32_T)ACTIVE != 0);
      }
    }
    break;

   case MX_Gtw_IN_LIGHTS_ACTIVE_RISING1:
    // During 'LIGHTS_ACTIVE_RISING1': '<S478>:4'
    if (MX_Gtwy_Control_B.RateTransition36_ijpl == (int32_T)INACTIVE) {
      // Transition: '<S478>:15'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
        MX_Gtwy_Contro_IN_LIGHTS_ACTIVE;

      // Entry 'LIGHTS_ACTIVE': '<S478>:2'
      MX_Gtwy_Control_DWork.state_Buttons_Old =
        MX_Gtwy_Control_B.RateTransition22_crtc;
      dout_Lights = ((int32_T)ACTIVE != 0);
    }
    break;

   case MX_Gtw_IN_LIGHTS_ACTIVE_RISING2:
    // During 'LIGHTS_ACTIVE_RISING2': '<S478>:5'
    if (MX_Gtwy_Control_B.RateTransition36_ijpl == (int32_T)INACTIVE) {
      // Transition: '<S478>:11'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
        MX_Gtwy_Cont_IN_LIGHTS_INACTIVE;

      // Entry 'LIGHTS_INACTIVE': '<S478>:1'
      dout_Lights = ((int32_T)INACTIVE != 0);
    }
    break;

   default:
    // During 'LIGHTS_INACTIVE': '<S478>:1'
    if (((state_VBattery == NORMAL) || (state_VBattery == LOW)) &&
        (CONSTANT_DATA->LIGHTS_FUNCTION != NON_FUNCTIONAL) &&
        (MX_Gtwy_Control_B.RateTransition22_crtc == NO_COMMUNICATION) &&
        (MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_fo0b == NORMAL) &&
        (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_e1ba == NORMAL)) {
      // Transition: '<S478>:13'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
        MX_Gtwy_Contro_IN_LIGHTS_ACTIVE;

      // Entry 'LIGHTS_ACTIVE': '<S478>:2'
      MX_Gtwy_Control_DWork.state_Buttons_Old =
        MX_Gtwy_Control_B.RateTransition22_crtc;
      dout_Lights = ((int32_T)ACTIVE != 0);
    } else {
      if (((state_VBattery == NORMAL) || (state_VBattery == LOW)) &&
          (CONSTANT_DATA->LIGHTS_FUNCTION != NON_FUNCTIONAL) &&
          (MX_Gtwy_Control_B.RateTransition36_ijpl == (int32_T)ACTIVE) &&
          (MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_fo0b == NORMAL) &&
          (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_e1ba == NORMAL)) {
        // Transition: '<S478>:8'
        MX_Gtwy_Control_DWork.bitsForTID1.is_c34_MX_Gtwy_Control =
          MX_Gtw_IN_LIGHTS_ACTIVE_RISING1;

        // Entry 'LIGHTS_ACTIVE_RISING1': '<S478>:4'
        dout_Lights = ((int32_T)ACTIVE != 0);
      }
    }
    break;
  }

  // End of Chart: '<S292>/Lights'

  // Logic: '<S292>/Logical Operator2' incorporates:
  //   Constant: '<S292>/Light1FeedbackState'
  //   Constant: '<S474>/Constant'
  //   Constant: '<S475>/Constant'
  //   RelationalOperator: '<S474>/Compare'
  //   RelationalOperator: '<S475>/Compare'

  rtb_ErrorDetectionEnable = ((CONSTANT_DATA->LIGHTS_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // Outputs for Enabled SubSystem: '<S292>/dout_chk'
  MX_Gtwy_Control_dout_chk(rtb_ErrorDetectionEnable, dout_Lights,
    MX_Gtwy_Control_B.RateTransition25_a55f,
    &MX_Gtwy_Control_B.OutportBufferForstate_futm,
    &MX_Gtwy_Control_B.dout_chk_jzfm, &MX_Gtwy_Control_DWork.dout_chk_jzfm,
    CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S292>/dout_chk'

  // Outputs for Enabled SubSystem: '<S292>/relay_oc'
  MX_Gtwy_Control_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_Lights,
    MX_Gtwy_Control_B.RateTransition25_a55f,
    MX_Gtwy_Control_B.RateTransition18_etzj,
    &MX_Gtwy_Control_B.state_Output_bilf, &state_LightsRelay,
    &MX_Gtwy_Control_B.relay_oc_kvfj, &MX_Gtwy_Control_DWork.relay_oc_kvfj,
    CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->LIGHTS_DEBOUNCE_ERROR_ON,
    CONSTANT_DATA->LIGHTS_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S292>/relay_oc'

  // Switch: '<S292>/Switch' incorporates:
  //   Logic: '<S292>/Logical Operator3'

  if (!rtb_LogicalOperator1_ochu) {
    state_LightsOutput = MX_Gtwy_Control_B.OutportBufferForstate_futm;
  } else {
    state_LightsOutput = MX_Gtwy_Control_B.state_Output_bilf;
  }

  // End of Switch: '<S292>/Switch'

  // Update for UnitDelay: '<S292>/Unit Delay3'
  MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_fo0b = state_LightsOutput;

  // Update for UnitDelay: '<S292>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_e1ba = state_LightsRelay;
}

// System initialize for atomic system: '<S4>/Offset'
void MX_Gtwy_Control_Offset_Init(void)
{
  // SystemInitialize for Enabled SubSystem: '<S293>/Offset'
  // SystemInitialize for Chart: '<S485>/Commands'
  MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ik2b;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c33_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c33_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ik2b;
  MX_Gtwy_Control_B.icmd_Base = 0U;
  MX_Gtwy_Control_B.icmd_Rod = 0U;

  // SystemInitialize for Atomic SubSystem: '<S485>/hc_pair_control'
  MX__output_pair_ClosedLoop_Init(&MX_Gtwy_Control_B.hs_cmd_pjid,
    &MX_Gtwy_Control_B.ls_cmd_ifxm, &MX_Gtwy_Control_B.state_Output_lu5e,
    &MX_Gtwy_Control_B.hc_pair_control_lgu5,
    &MX_Gtwy_Control_DWork.hc_pair_control_lgu5);

  // End of SystemInitialize for SubSystem: '<S485>/hc_pair_control'

  // SystemInitialize for Atomic SubSystem: '<S485>/hc_pair_control1'
  MX__output_pair_ClosedLoop_Init(&MX_Gtwy_Control_B.hs_cmd,
    &MX_Gtwy_Control_B.ls_cmd, &MX_Gtwy_Control_B.state_Output_fskg,
    &MX_Gtwy_Control_B.hc_pair_control1_cc44,
    &MX_Gtwy_Control_DWork.hc_pair_control1_cc44);

  // End of SystemInitialize for SubSystem: '<S485>/hc_pair_control1'

  // End of SystemInitialize for SubSystem: '<S293>/Offset'
}

// Output and update for atomic system: '<S4>/Offset'
void MX_Gtwy_Control_Offset(void)
{
  // local block i/o variables
  uint16_T rtb_position_Pot_jbn4;
  uint16_T rtb_Offset_Table;
  uint16_T rtb_CurrentvsFlowCmd;
  uint16_T rtb_Aux2Flow_Table;
  boolean_T aVarTruthTableCondition_1;
  boolean_T aVarTruthTableCondition_2;
  boolean_T aVarTruthTableCondition_4;
  boolean_T b;
  uint8_T rtb_state_Pot;
  uint16_T rtb_Switch_jh5g;
  int16_T rtb_Saturation;
  boolean_T rtb_Compare_lst3;
  uint16_T rtb_Product_km1l;
  uint16_T rtb_TmpSignalConversionAtC_bbzb[2];
  uint16_T rtb_TmpSignalConversionAtCurren[2];

  // Outputs for Enabled SubSystem: '<S293>/Offset' incorporates:
  //   EnablePort: '<S485>/Enable'

  // Logic: '<S293>/Logical Operator' incorporates:
  //   Constant: '<S293>/Constant'
  //   Constant: '<S483>/Constant'
  //   Constant: '<S484>/Constant'
  //   Inport: '<Root>/afbk_OffsetBase'
  //   Inport: '<Root>/afbk_OffsetRod'
  //   Inport: '<Root>/ain_PrecisionReference'
  //   Inport: '<Root>/ifbk_OffsetBase'
  //   Inport: '<Root>/ifbk_OffsetRod'
  //   Inport: '<Root>/state_System'
  //   RelationalOperator: '<S483>/Compare'
  //   RelationalOperator: '<S484>/Compare'

  if ((state_System == SYS_NORMAL) && (CONSTANT_DATA->OFFSET_FUNCTION !=
       NON_FUNCTIONAL)) {
    if (!MX_Gtwy_Control_DWork.Offset_MODE) {
      // SystemReset for Chart: '<S485>/Commands'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ik2b;
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c33_MX_Gtwy_Control = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_c33_MX_Gtwy_Control =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ik2b;
      MX_Gtwy_Control_B.icmd_Base = 0U;
      MX_Gtwy_Control_B.icmd_Rod = 0U;

      // SystemReset for Atomic SubSystem: '<S485>/hc_pair_control'
      MX_output_pair_ClosedLoop_Reset(&MX_Gtwy_Control_B.hs_cmd_pjid,
        &MX_Gtwy_Control_B.ls_cmd_ifxm, &MX_Gtwy_Control_B.state_Output_lu5e,
        &MX_Gtwy_Control_B.hc_pair_control_lgu5,
        &MX_Gtwy_Control_DWork.hc_pair_control_lgu5);

      // End of SystemReset for SubSystem: '<S485>/hc_pair_control'

      // SystemReset for Atomic SubSystem: '<S485>/hc_pair_control1'
      MX_output_pair_ClosedLoop_Reset(&MX_Gtwy_Control_B.hs_cmd,
        &MX_Gtwy_Control_B.ls_cmd, &MX_Gtwy_Control_B.state_Output_fskg,
        &MX_Gtwy_Control_B.hc_pair_control1_cc44,
        &MX_Gtwy_Control_DWork.hc_pair_control1_cc44);

      // End of SystemReset for SubSystem: '<S485>/hc_pair_control1'
      MX_Gtwy_Control_DWork.Offset_MODE = true;
    }

    // Truth Table: '<S485>/Controls_Select'
    // Truth Table Function 'MX_Gtwy_Control/Outputs/Offset/Offset/Controls_Select': '<S489>:1' 
    //  EMEA Controls
    // Condition '#1': '<S489>:1:11'
    aVarTruthTableCondition_1 = (CONSTANT_DATA->AUX_FUNCTION ==
      AUX_EMEA_CONTROLS);

    //  Joysticks Reversed (Kawasaki)
    // Condition '#2': '<S489>:1:15'
    aVarTruthTableCondition_2 = (CONSTANT_DATA->EMEA_CONTROLS_REVERSE ==
      NON_FUNCTIONAL);

    //  Offset or Aux2 on Left
    if ((mode_LeftControl == MODE_LEFT_OFFSET) || (mode_LeftControl ==
         MODE_LEFT_AUX2)) {
      // Condition '#3': '<S489>:1:19'
      b = true;
    } else {
      b = false;
    }

    //  Offset on Right
    // Condition '#4': '<S489>:1:23'
    aVarTruthTableCondition_4 = (mode_RightControl == MODE_RIGHT_OFFSET);
    if ((!aVarTruthTableCondition_1) && aVarTruthTableCondition_2 && b &&
        (!aVarTruthTableCondition_4)) {
      // Decision 'D1': '<S489>:1:25'
      //  Offset Pot
      // Action '1': '<S489>:1:41'
      rtb_position_Pot_jbn4 = position_OffsetPot;

      // Action '1': '<S489>:1:42'
      rtb_state_Pot = state_OffsetPot;
    } else if ((!aVarTruthTableCondition_1) && (!aVarTruthTableCondition_2) && b
               && (!aVarTruthTableCondition_4)) {
      // Decision 'D2': '<S489>:1:27'
      //  Left Pot
      // Action '2': '<S489>:1:48'
      rtb_position_Pot_jbn4 = position_LeftPot;

      // Action '2': '<S489>:1:49'
      rtb_state_Pot = state_LeftPot;
    } else if (aVarTruthTableCondition_1 && (!aVarTruthTableCondition_2) && b &&
               (!aVarTruthTableCondition_4)) {
      // Decision 'D3': '<S489>:1:29'
      //  Left Pot
      // Action '2': '<S489>:1:48'
      rtb_position_Pot_jbn4 = position_LeftPot;

      // Action '2': '<S489>:1:49'
      rtb_state_Pot = state_LeftPot;
    } else if (aVarTruthTableCondition_1 && (!b) && aVarTruthTableCondition_4) {
      // Decision 'D4': '<S489>:1:31'
      //  Right Pot
      // Action '3': '<S489>:1:55'
      rtb_position_Pot_jbn4 = position_RightPot;

      // Action '3': '<S489>:1:56'
      rtb_state_Pot = state_RightPot;
    } else {
      // Decision 'D5': '<S489>:1:33'
      //  Default
      //  Neutral
      // Action '4': '<S489>:1:62'
      rtb_position_Pot_jbn4 = 500U;

      // Action '4': '<S489>:1:63'
      rtb_state_Pot = 8U;
    }

    // End of Truth Table: '<S485>/Controls_Select'

    // Lookup: '<S491>/Offset_Table'
    //
    //  About '<S491>/Offset_Table':
    //  Input0  Data Type:  Integer        U16
    //  Output0 Data Type:  Fixed Point    U16  2^-12
    //  Saturation Mode: Saturate
    //  Lookup Method: Linear_Endpoint
    //
    //  XData is inlined and evenly spaced, so the algorithm only needs
    //  the value of the first element, the last element, and the spacing.
    //  For efficiency, XData is excluded from the generated code.
    //  YData parameter uses the same data type and scaling as Output0

    LookUpEven_U16_U16_SAT( &(rtb_Offset_Table), (&(MXGTW_OFFSET[0])),
      rtb_position_Pot_jbn4, 20U, 160U, 6U);

    // Switch: '<S485>/Switch' incorporates:
    //   Constant: '<S488>/Constant'
    //   RelationalOperator: '<S488>/Compare'

    if (mode_LeftControl != MODE_LEFT_AUX2) {
      // Switch: '<S491>/Switch1' incorporates:
      //   Constant: '<S491>/Constant2'
      //   Constant: '<S491>/Constant4'
      //   Constant: '<S497>/Constant'
      //   DataStoreRead: '<S491>/Data Store Read'
      //   DataTypeConversion: '<S491>/Data Type Conversion1'
      //   Gain: '<S491>/Gain'
      //   Inport: '<Root>/flow_OffsetPercent'
      //   Logic: '<S491>/Logical Operator'
      //   Product: '<S491>/Product'
      //   RelationalOperator: '<S497>/Compare'
      //   Sum: '<S491>/Sum1'

      if (!(((int32_T)eeMirror.deluxe_G5 != 0) &&
            (CONSTANT_DATA->OFFSET_DLX_ADJ_FUNCTION != NON_FUNCTIONAL))) {
        rtb_Switch_jh5g = rtb_Offset_Table;
      } else {
        // Sum: '<S491>/Sum' incorporates:
        //   Constant: '<S491>/Constant4'
        //   DataTypeConversion: '<S491>/Data Type Conversion'

        rtb_Saturation = (int16_T)(int32_T)((int32_T)((int32_T)(int16_T)
          rtb_Offset_Table - (int32_T)CONSTANT_DATA->OFFSET_CRACKPOINT_CURRENT) >>
          1);

        // Saturate: '<S491>/Saturation'
        if ((int32_T)rtb_Saturation > (int32_T)4096) {
          rtb_Saturation = 4096;
        } else {
          if ((int32_T)rtb_Saturation < (int32_T)0) {
            rtb_Saturation = 0;
          }
        }

        // End of Saturate: '<S491>/Saturation'
        rtb_Switch_jh5g = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)
          CONSTANT_DATA->OFFSET_CRACKPOINT_CURRENT << 4) + (uint32_T)(uint16_T)
          (uint32_T)((uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
          rtb_Saturation << 1) * (uint32_T)(uint16_T)(uint32_T)((uint32_T)
          ((uint32_T)((uint16_T)41943U) * (uint32_T)flow_OffsetPercent) >> 6)) >>
                     12)) >> 4);
      }

      // End of Switch: '<S491>/Switch1'
    } else {
      // Lookup: '<S490>/Aux2Flow_Table'
      //
      //  About '<S490>/Aux2Flow_Table':
      //  Input0  Data Type:  Integer        U16
      //  Output0 Data Type:  Fixed Point    U16  2^-16
      //  Saturation Mode: Saturate
      //  Lookup Method: Linear_Endpoint
      //
      //  XData is inlined and evenly spaced, so the algorithm only needs
      //  the value of the first element, the last element, and the spacing.
      //  For efficiency, XData is excluded from the generated code.
      //  YData parameter uses the same data type and scaling as Output0

      LookUpEven_U16_U16_SAT( &(rtb_Aux2Flow_Table), (&(MXGTW_AUX2_FLOW[0])),
        rtb_position_Pot_jbn4, 0U, 100U, 10U);

      // Switch: '<S490>/Switch' incorporates:
      //   Constant: '<S494>/Constant1'
      //   Constant: '<S494>/Constant10'
      //   Constant: '<S494>/Constant6'
      //   Constant: '<S495>/Constant'
      //   Constant: '<S496>/Constant'
      //   DataStoreRead: '<S490>/Data Store Read'
      //   Gain: '<S490>/Gain'
      //   Inport: '<Root>/flow_Aux2Percent'
      //   RelationalOperator: '<S495>/Compare'
      //   RelationalOperator: '<S496>/Compare'
      //   Switch: '<S494>/Switch'
      //   Switch: '<S494>/Switch1'

      if ((int32_T)eeMirror.deluxe_G5 != 0) {
        rtb_Switch_jh5g = (uint16_T)(uint32_T)((uint32_T)((uint32_T)((uint16_T)
          41943U) * (uint32_T)flow_Aux2Percent) >> 6);
      } else if (CONSTANT_DATA->AUX2_FLOW_LOW_FUNCTION != NON_FUNCTIONAL) {
        // Switch: '<S494>/Switch' incorporates:
        //   Constant: '<S494>/Constant8'

        rtb_Switch_jh5g = CONSTANT_DATA->AUX2_LOW_FLOW_PERCENT;
      } else if (CONSTANT_DATA->AUX2_FLOW_MED_FUNCTION != NON_FUNCTIONAL) {
        // Switch: '<S494>/Switch1' incorporates:
        //   Constant: '<S494>/Constant9'
        //   Switch: '<S494>/Switch'

        rtb_Switch_jh5g = CONSTANT_DATA->AUX2_MED_FLOW_PERCENT;
      } else {
        rtb_Switch_jh5g = CONSTANT_DATA->AUX2_HI_FLOW_PERCENT;
      }

      // End of Switch: '<S490>/Switch'

      // Product: '<S490>/Product' incorporates:
      //   Lookup: '<S490>/Aux2Flow_Table'

      rtb_Product_km1l = (uint16_T)(uint32_T)((uint32_T)((uint32_T)
        rtb_Aux2Flow_Table * (uint32_T)rtb_Switch_jh5g) >> 16);

      // Switch: '<S490>/Switch1' incorporates:
      //   Constant: '<S490>/Constant6'

      if (rtb_Product_km1l > ((uint16_T)0U)) {
        // SignalConversion: '<S490>/TmpSignal ConversionAtCurrent vs Flow CmdInport3' incorporates:
        //   Constant: '<S490>/Constant4'
        //   Constant: '<S490>/Constant5'

        rtb_TmpSignalConversionAtCurren[0] =
          CONSTANT_DATA->AUX2_CRACKPOINT_CURRENT;
        rtb_TmpSignalConversionAtCurren[1] =
          CONSTANT_DATA->AUX2_MAX_FLOW_CURRENT;

        // SignalConversion: '<S490>/TmpSignal ConversionAtCurrent vs Flow CmdInport2' incorporates:
        //   Constant: '<S490>/Constant2'
        //   Constant: '<S490>/Constant3'

        rtb_TmpSignalConversionAtC_bbzb[0] = ((uint16_T)0U);
        rtb_TmpSignalConversionAtC_bbzb[1] = ((uint16_T)65535U);

        // S-Function (sfix_look1_dyn): '<S490>/Current vs Flow Cmd'
        // Dynamic Look-Up Table Block: '<S490>/Current vs Flow Cmd'
        //  Input0  Data Type:  Fixed Point    U16  2^-16
        //  Input1  Data Type:  Fixed Point    U16  2^-16
        //  Input2  Data Type:  Fixed Point    U16  2^-12
        //  Output0 Data Type:  Fixed Point    U16  2^-12
        //  Lookup Method: Linear_Endpoint
        //

        LookUp_U16_U16( &(rtb_CurrentvsFlowCmd),
                       &rtb_TmpSignalConversionAtCurren[0], rtb_Product_km1l,
                       &rtb_TmpSignalConversionAtC_bbzb[0], 1U);
        rtb_Switch_jh5g = rtb_CurrentvsFlowCmd;
      } else {
        rtb_Switch_jh5g = (uint16_T)(int32_T)(uint32_T)((uint32_T)((uint16_T)0U)
          >> 4);
      }

      // End of Switch: '<S490>/Switch1'
    }

    // End of Switch: '<S485>/Switch'

    // Chart: '<S485>/Commands'
    // Gateway: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
    // During: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
    if ((uint32_T)
        MX_Gtwy_Control_DWork.bitsForTID0.is_active_c33_MX_Gtwy_Control == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c33_MX_Gtwy_Control = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Offset/Offset/Commands
      // Transition: '<S486>:63'
      MX_Gtwy_Control_DWork.bitsForTID0.is_c33_MX_Gtwy_Control =
        MX_Gtwy_Contro_IN_Inactive_cx3o;

      // Entry 'Inactive': '<S486>:24'
      MX_Gtwy_Control_B.icmd_Base = 0U;
      MX_Gtwy_Control_B.icmd_Rod = 0U;
    } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_c33_MX_Gtwy_Control ==
               MX_Gtwy_Control_IN_Active_f4bs) {
      // During 'Active': '<S486>:3'
      if ((state_Console != ACTIVE) || (state_Engine == ENGINE_CRANKING) ||
          ((state_Diverter != ACTIVE) && (state_Diverter != INACTIVE))) {
        // Transition: '<S486>:72'
        // Exit Internal 'Active': '<S486>:3'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ik2b;
        MX_Gtwy_Control_DWork.bitsForTID0.is_c33_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_Inactive_cx3o;

        // Entry 'Inactive': '<S486>:24'
        MX_Gtwy_Control_B.icmd_Base = 0U;
        MX_Gtwy_Control_B.icmd_Rod = 0U;
      } else {
        switch (MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2) {
         case MX_Gtwy_Control_IN_BaseActive:
          // During 'BaseActive': '<S486>:25'
          if ((rtb_state_Pot != BASE_ACTIVE) && (rtb_state_Pot != ROD_ACTIVE)) {
            // Transition: '<S486>:66'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
              MX_Gtwy_Control_IN_Neutral_nhy3;

            // Entry 'Neutral': '<S486>:27'
            MX_Gtwy_Control_B.icmd_Base = 0U;
            MX_Gtwy_Control_B.icmd_Rod = 0U;
          } else if (rtb_state_Pot == ROD_ACTIVE) {
            // Transition: '<S486>:68'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
              MX_Gtwy_Control_IN_RodActive;

            // Entry 'RodActive': '<S486>:26'
            MX_Gtwy_Control_B.icmd_Base = 0U;
            MX_Gtwy_Control_B.icmd_Rod = rtb_Switch_jh5g;
          } else {
            MX_Gtwy_Control_B.icmd_Base = rtb_Switch_jh5g;
          }
          break;

         case MX_Gtwy_Control_IN_Neutral_nhy3:
          // During 'Neutral': '<S486>:27'
          if (rtb_state_Pot == ROD_ACTIVE) {
            // Transition: '<S486>:64'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
              MX_Gtwy_Control_IN_RodActive;

            // Entry 'RodActive': '<S486>:26'
            MX_Gtwy_Control_B.icmd_Base = 0U;
            MX_Gtwy_Control_B.icmd_Rod = rtb_Switch_jh5g;
          } else {
            if (rtb_state_Pot == BASE_ACTIVE) {
              // Transition: '<S486>:67'
              MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
                MX_Gtwy_Control_IN_BaseActive;

              // Entry 'BaseActive': '<S486>:25'
              MX_Gtwy_Control_B.icmd_Rod = 0U;
              MX_Gtwy_Control_B.icmd_Base = rtb_Switch_jh5g;
            }
          }
          break;

         default:
          // During 'RodActive': '<S486>:26'
          if ((rtb_state_Pot != BASE_ACTIVE) && (rtb_state_Pot != ROD_ACTIVE)) {
            // Transition: '<S486>:65'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
              MX_Gtwy_Control_IN_Neutral_nhy3;

            // Entry 'Neutral': '<S486>:27'
            MX_Gtwy_Control_B.icmd_Base = 0U;
            MX_Gtwy_Control_B.icmd_Rod = 0U;
          } else if (rtb_state_Pot == BASE_ACTIVE) {
            // Transition: '<S486>:69'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
              MX_Gtwy_Control_IN_BaseActive;

            // Entry 'BaseActive': '<S486>:25'
            MX_Gtwy_Control_B.icmd_Rod = 0U;
            MX_Gtwy_Control_B.icmd_Base = rtb_Switch_jh5g;
          } else {
            MX_Gtwy_Control_B.icmd_Rod = rtb_Switch_jh5g;
          }
          break;
        }
      }
    } else {
      // During 'Inactive': '<S486>:24'
      if ((state_Console == ACTIVE) && (state_Engine != ENGINE_CRANKING) &&
          ((state_Diverter == ACTIVE) || (state_Diverter == INACTIVE))) {
        // Transition: '<S486>:71'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c33_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_Active_f4bs;

        // Entry Internal 'Active': '<S486>:3'
        // Transition: '<S486>:70'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_k0x2 =
          MX_Gtwy_Control_IN_Neutral_nhy3;

        // Entry 'Neutral': '<S486>:27'
        MX_Gtwy_Control_B.icmd_Base = 0U;
        MX_Gtwy_Control_B.icmd_Rod = 0U;
      }
    }

    // End of Chart: '<S485>/Commands'

    // RelationalOperator: '<S487>/Compare' incorporates:
    //   Constant: '<S487>/Constant'

    rtb_Compare_lst3 = (state_Console != ACTIVE);

    // Outputs for Atomic SubSystem: '<S485>/hc_pair_control'
    MX_Gtwy__output_pair_ClosedLoop(MX_Gtwy_Control_B.icmd_Base,
      rtb_Compare_lst3, afbk_OffsetBase, ifbk_OffsetBase,
      MX_Gtwy_Control_B.RateTransition4_i0so, state_Engine,
      MX_Gtwy_Control_B.RateTransition5, ain_PrecisionReference,
      &MX_Gtwy_Control_B.hs_cmd_pjid, &MX_Gtwy_Control_B.ls_cmd_ifxm,
      &MX_Gtwy_Control_B.error_dmed, &calc_ifbk_OffsetBase,
      &MX_Gtwy_Control_B.state_Output_lu5e,
      &MX_Gtwy_Control_B.hc_pair_control_lgu5,
      &MX_Gtwy_Control_DWork.hc_pair_control_lgu5,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->OFFSET_KP,
      CONSTANT_DATA->OFFSET_KI, CONSTANT_DATA->OFFSET_OVERCURRENT,
      CONSTANT_DATA->OFFSET_NON_ZERO_DUTY,
      CONSTANT_DATA->OFFSET_NON_ZERO_CURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->OFFSET_BIDIRECTIONAL_CONTROL,
      CONSTANT_DATA->OFFSET_AFBK_GAIN, CONSTANT_DATA->OFFSET_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S485>/hc_pair_control'

    // SignalConversion: '<S485>/OutportBufferForerrorCC_OffsetBase' incorporates:
    //   Inport: '<Root>/afbk_OffsetBase'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_OffsetBase'

    errorCC_OffsetBase = MX_Gtwy_Control_B.error_dmed;

    // Outputs for Atomic SubSystem: '<S485>/hc_pair_control1'
    MX_Gtwy__output_pair_ClosedLoop(MX_Gtwy_Control_B.icmd_Rod, rtb_Compare_lst3,
      afbk_OffsetRod, ifbk_OffsetRod, MX_Gtwy_Control_B.RateTransition4_i0so,
      state_Engine, MX_Gtwy_Control_B.RateTransition5, ain_PrecisionReference,
      &MX_Gtwy_Control_B.hs_cmd, &MX_Gtwy_Control_B.ls_cmd,
      &MX_Gtwy_Control_B.error, &calc_ifbk_OffsetRod,
      &MX_Gtwy_Control_B.state_Output_fskg,
      &MX_Gtwy_Control_B.hc_pair_control1_cc44,
      &MX_Gtwy_Control_DWork.hc_pair_control1_cc44,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND, CONSTANT_DATA->OFFSET_KP,
      CONSTANT_DATA->OFFSET_KI, CONSTANT_DATA->OFFSET_OVERCURRENT,
      CONSTANT_DATA->OFFSET_NON_ZERO_DUTY,
      CONSTANT_DATA->OFFSET_NON_ZERO_CURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_OVERCURRENT,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->OFFSET_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->OFFSET_BIDIRECTIONAL_CONTROL,
      CONSTANT_DATA->OFFSET_AFBK_GAIN, CONSTANT_DATA->OFFSET_IFBK_GAIN);

    // End of Outputs for SubSystem: '<S485>/hc_pair_control1'

    // SignalConversion: '<S485>/OutportBufferForerrorCC_OffsetRod' incorporates:
    //   Inport: '<Root>/afbk_OffsetRod'
    //   Inport: '<Root>/ain_PrecisionReference'
    //   Inport: '<Root>/ifbk_OffsetRod'

    errorCC_OffsetRod = MX_Gtwy_Control_B.error;

    // SignalConversion: '<S485>/OutportBufferForhs_OffsetBase'
    hs_OffsetBase = MX_Gtwy_Control_B.hs_cmd_pjid;

    // SignalConversion: '<S485>/OutportBufferForhs_OffsetRod'
    hs_OffsetRod = MX_Gtwy_Control_B.hs_cmd;

    // SignalConversion: '<S485>/OutportBufferForls_OffsetBase'
    ls_OffsetBase = MX_Gtwy_Control_B.ls_cmd_ifxm;

    // SignalConversion: '<S485>/OutportBufferForls_OffsetRod'
    ls_OffsetRod = MX_Gtwy_Control_B.ls_cmd;

    // SignalConversion: '<S485>/OutportBufferForstate_OffsetBase'
    state_OffsetBase = MX_Gtwy_Control_B.state_Output_lu5e;

    // SignalConversion: '<S485>/OutportBufferForstate_OffsetRod'
    state_OffsetRod = MX_Gtwy_Control_B.state_Output_fskg;
  } else {
    if (MX_Gtwy_Control_DWork.Offset_MODE) {
      // Disable for Atomic SubSystem: '<S485>/hc_pair_control'
      output_pair_ClosedLoop_Disable(&MX_Gtwy_Control_B.error_dmed,
        &MX_Gtwy_Control_B.hc_pair_control_lgu5,
        &MX_Gtwy_Control_DWork.hc_pair_control_lgu5);

      // End of Disable for SubSystem: '<S485>/hc_pair_control'

      // Disable for Atomic SubSystem: '<S485>/hc_pair_control1'
      output_pair_ClosedLoop_Disable(&MX_Gtwy_Control_B.error,
        &MX_Gtwy_Control_B.hc_pair_control1_cc44,
        &MX_Gtwy_Control_DWork.hc_pair_control1_cc44);

      // End of Disable for SubSystem: '<S485>/hc_pair_control1'

      // Disable for Outport: '<S485>/hs_OffsetBase'
      hs_OffsetBase = ((uint16_T)0U);

      // Disable for Outport: '<S485>/ls_OffsetBase'
      ls_OffsetBase = false;

      // Disable for Outport: '<S485>/errorCC_OffsetBase'
      errorCC_OffsetBase = 0;

      // Disable for Outport: '<S485>/calc_ifbk_OffsetBase'
      calc_ifbk_OffsetBase = ((uint16_T)0U);

      // Disable for Outport: '<S485>/state_OffsetBase'
      state_OffsetBase = ((uint8_T)0U);

      // Disable for Outport: '<S485>/hs_OffsetRod'
      hs_OffsetRod = ((uint16_T)0U);

      // Disable for Outport: '<S485>/ls_OffsetRod'
      ls_OffsetRod = false;

      // Disable for Outport: '<S485>/errorCC_OffsetRod'
      errorCC_OffsetRod = 0;

      // Disable for Outport: '<S485>/calc_ifbk_OffsetRod'
      calc_ifbk_OffsetRod = ((uint16_T)0U);
      MX_Gtwy_Control_DWork.Offset_MODE = false;
    }
  }

  // End of Logic: '<S293>/Logical Operator'
  // End of Outputs for SubSystem: '<S293>/Offset'
}

// System initialize for atomic system: '<S4>/PB_Valve'
void MX_Gtwy_Control_PB_Valve_Init(void)
{
  // InitializeConditions for UnitDelay: '<S294>/Unit Delay3'
  MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_h0lf = NORMAL;

  // InitializeConditions for UnitDelay: '<S294>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_enrc = NORMAL;

  // Chart: '<S294>/PBValve'
  // Entry: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  // Entry Internal: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  // Transition: '<S537>:10'
  MX_Gtwy_Control_DWork.bitsForTID1.is_c40_MX_Gtwy_Control =
    MX_Gtwy_Contro_IN_INACTIVE_h2aq;

  // Entry 'INACTIVE': '<S537>:1'
  dout_PBValve = ((int32_T)INACTIVE != 0);

  // SystemInitialize for Enabled SubSystem: '<S294>/dout_chk'
  MX_Gtwy_Control_dout_chk_Init(&MX_Gtwy_Control_B.OutportBufferForstate,
    &MX_Gtwy_Control_B.dout_chk_k45l, &MX_Gtwy_Control_DWork.dout_chk_k45l);

  // End of SystemInitialize for SubSystem: '<S294>/dout_chk'

  // SystemInitialize for Enabled SubSystem: '<S294>/relay_oc'
  MX_Gtwy_Control_relay_oc_Init(&MX_Gtwy_Control_B.state_Output_idoi,
    &state_PBValveRelay, &MX_Gtwy_Control_B.relay_oc_mc2f,
    &MX_Gtwy_Control_DWork.relay_oc_mc2f);

  // End of SystemInitialize for SubSystem: '<S294>/relay_oc'
}

// Output and update for atomic system: '<S4>/PB_Valve'
void MX_Gtwy_Control_PB_Valve(void)
{
  boolean_T rtb_LogicalOperator1_io14;
  boolean_T Compare_lv2j;
  boolean_T rtb_HiddenBuf_InsertedFor_relay;
  boolean_T rtb_ErrorDetectionEnable;

  // RelationalOperator: '<S532>/Compare' incorporates:
  //   Constant: '<S532>/Constant'

  Compare_lv2j = (MX_Gtwy_Control_B.RateTransition37_bstc > ((uint16_T)512U));

  // Logic: '<S294>/Logical Operator1' incorporates:
  //   Constant: '<S294>/Light1FeedbackState1'
  //   Constant: '<S535>/Constant'
  //   Constant: '<S536>/Constant'
  //   RelationalOperator: '<S535>/Compare'
  //   RelationalOperator: '<S536>/Compare'

  rtb_LogicalOperator1_io14 = ((CONSTANT_DATA->PBVALVE_RELAY_FEEDBACK_FUNCTION
    != NON_FUNCTIONAL) && (state_VBattery != OORL));

  // SignalConversion: '<S294>/HiddenBuf_InsertedFor_relay_oc_at_inport_3'
  rtb_HiddenBuf_InsertedFor_relay = rtb_LogicalOperator1_io14;

  // Logic: '<S294>/Logical Operator2' incorporates:
  //   Constant: '<S294>/Light1FeedbackState'
  //   Constant: '<S533>/Constant'
  //   Constant: '<S534>/Constant'
  //   RelationalOperator: '<S533>/Compare'
  //   RelationalOperator: '<S534>/Compare'

  rtb_ErrorDetectionEnable = ((CONSTANT_DATA->PBVALVE_FEEDBACK_FUNCTION !=
    NON_FUNCTIONAL) && (state_VBattery != OORL));

  // Chart: '<S294>/PBValve' incorporates:
  //   UnitDelay: '<S294>/Unit Delay1'
  //   UnitDelay: '<S294>/Unit Delay3'

  // Gateway: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  // During: MX_Gtwy_Control/Outputs/PB_Valve/PBValve
  if (MX_Gtwy_Control_DWork.bitsForTID1.is_c40_MX_Gtwy_Control ==
      MX_Gtwy_Control_IN_ACTIVE_ftsh) {
    // During 'ACTIVE': '<S537>:2'
    if ((((MX_Gtwy_Control_B.RateTransition38_cu5w != AUX_FLOW_HIGH) ||
          (MX_Gtwy_Control_B.RateTransition39_gsng == INACTIVE)) &&
         (Compare_lv2j == (int32_T)INACTIVE)) ||
        (MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_h0lf != NORMAL) ||
        (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_enrc != NORMAL)) {
      // Transition: '<S537>:14'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c40_MX_Gtwy_Control =
        MX_Gtwy_Contro_IN_INACTIVE_h2aq;

      // Entry 'INACTIVE': '<S537>:1'
      dout_PBValve = ((int32_T)INACTIVE != 0);
    }
  } else {
    // During 'INACTIVE': '<S537>:1'
    if ((CONSTANT_DATA->PBVALVE_FUNCTION != NON_FUNCTIONAL) &&
        (((MX_Gtwy_Control_B.RateTransition38_cu5w == AUX_FLOW_HIGH) &&
          (MX_Gtwy_Control_B.RateTransition39_gsng == ACTIVE)) || (Compare_lv2j ==
          (int32_T)ACTIVE)) && (MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_h0lf ==
         NORMAL) && (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_enrc == NORMAL)) {
      // Transition: '<S537>:8'
      MX_Gtwy_Control_DWork.bitsForTID1.is_c40_MX_Gtwy_Control =
        MX_Gtwy_Control_IN_ACTIVE_ftsh;

      // Entry 'ACTIVE': '<S537>:2'
      dout_PBValve = ((int32_T)ACTIVE != 0);
    }
  }

  // End of Chart: '<S294>/PBValve'

  // Outputs for Enabled SubSystem: '<S294>/dout_chk'
  MX_Gtwy_Control_dout_chk(rtb_ErrorDetectionEnable, dout_PBValve,
    MX_Gtwy_Control_B.RateTransition32_dkx3,
    &MX_Gtwy_Control_B.OutportBufferForstate, &MX_Gtwy_Control_B.dout_chk_k45l,
    &MX_Gtwy_Control_DWork.dout_chk_k45l,
    CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_ON);

  // End of Outputs for SubSystem: '<S294>/dout_chk'

  // Outputs for Enabled SubSystem: '<S294>/relay_oc'
  MX_Gtwy_Control_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_PBValve,
    MX_Gtwy_Control_B.RateTransition32_dkx3,
    MX_Gtwy_Control_B.RateTransition35_gogg,
    &MX_Gtwy_Control_B.state_Output_idoi, &state_PBValveRelay,
    &MX_Gtwy_Control_B.relay_oc_mc2f, &MX_Gtwy_Control_DWork.relay_oc_mc2f,
    CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->PBVALVE_DEBOUNCE_ERROR_ON,
    CONSTANT_DATA->PBVALVE_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S294>/relay_oc'

  // Switch: '<S294>/Switch' incorporates:
  //   Logic: '<S294>/Logical Operator3'

  if (!rtb_LogicalOperator1_io14) {
    state_PBValveOutput = MX_Gtwy_Control_B.OutportBufferForstate;
  } else {
    state_PBValveOutput = MX_Gtwy_Control_B.state_Output_idoi;
  }

  // End of Switch: '<S294>/Switch'

  // Update for UnitDelay: '<S294>/Unit Delay3'
  MX_Gtwy_Control_DWork.UnitDelay3_DSTATE_h0lf = state_PBValveOutput;

  // Update for UnitDelay: '<S294>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_enrc = state_PBValveRelay;
}

// System initialize for atomic system: '<S4>/Starter'
void MX_Gtwy_Control_Starter_Init(void)
{
  // InitializeConditions for UnitDelay: '<S295>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE_eduf = ((uint8_T)8U);

  // InitializeConditions for UnitDelay: '<S295>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_jgsb = ((uint8_T)8U);

  // SystemInitialize for Chart: '<S295>/Starter'
  MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fajt;
  MX_Gtwy_Control_DWork.bitsForTID0.is_MANUAL = MX_Gtwy_IN_NO_ACTIVE_CHILD_fajt;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c64_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c64_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_fajt;
  MX_Gtwy_Control_DWork.debounceAuto = 0U;
  dout_Starter = false;

  // SystemInitialize for Enabled SubSystem: '<S295>/relay_oc'
  MX_Gtwy_Control_relay_oc_Init(&state_StarterOutput, &state_StarterRelay,
    &MX_Gtwy_Control_B.relay_oc_n5e3, &MX_Gtwy_Control_DWork.relay_oc_n5e3);

  // End of SystemInitialize for SubSystem: '<S295>/relay_oc'
}

// Output and update for atomic system: '<S4>/Starter'
void MX_Gtwy_Control_Starter(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;

  // SignalConversion: '<S295>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S295>/FunctionState'
  //   Constant: '<S542>/Constant'
  //   Constant: '<S543>/Constant'
  //   Logic: '<S295>/Logical Operator1'
  //   RelationalOperator: '<S542>/Compare'
  //   RelationalOperator: '<S543>/Compare'

  rtb_HiddenBuf_InsertedFor_relay = ((CONSTANT_DATA->STARTER_FEEDBACK_FUNCTION
    != NON_FUNCTIONAL) && (MX_Gtwy_Control_B.RateTransition20_arnl != OORL));

  // Lookup: '<S295>/Starter_Engage_RPM' incorporates:
  //   Inport: '<Root>/ecu_EOT'

  //
  //  About '<S295>/Starter_Engage_RPM':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Below
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;
    BINARYSEARCH_U16_iL( &(iLeft), ecu_EOT, (&(MXGTW_STARTER_AUTOMATED_OIL_TEMP
      [0])), 9U);
    level_StarterAutomatedEngage =
      MXGTW_STARTER_AUTOMATED_RPM_ENGAGE_LEVEL[iLeft];
  }

  // Lookup: '<S295>/Starter_Disenage_RPM' incorporates:
  //   Inport: '<Root>/ecu_EOT'

  //
  //  About '<S295>/Starter_Disenage_RPM':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Below
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;
    BINARYSEARCH_U16_iL( &(iLeft), ecu_EOT, (&(MXGTW_STARTER_AUTOMATED_OIL_TEMP
      [0])), 9U);
    level_StarterAutomatedDisengage =
      MXGTW_STARTER_AUTOMATED_RPM_DISENGAGE_LEVEL[iLeft];
  }

  // Lookup: '<S295>/Starter_Max_Time' incorporates:
  //   Inport: '<Root>/ecu_EOT'

  //
  //  About '<S295>/Starter_Max_Time':
  //  Input0  Data Type:  Integer        U16
  //  Output0 Data Type:  Integer        U16
  //  Saturation Mode: Saturate
  //  Lookup Method: Below
  //
  //  XData parameter uses the same data type and scaling as Input0
  //  YData parameter uses the same data type and scaling as Output0

  {
    uint32_T iLeft;
    BINARYSEARCH_U16_iL( &(iLeft), ecu_EOT, (&(MXGTW_STARTER_AUTOMATED_OIL_TEMP
      [0])), 9U);
    time_StarterAutomated = MXGTW_STARTER_AUTOMATED_MAX_TIME[iLeft];
  }

  // Chart: '<S295>/Starter' incorporates:
  //   UnitDelay: '<S295>/Unit Delay'
  //   UnitDelay: '<S295>/Unit Delay1'

  // Gateway: MX_Gtwy_Control/Outputs/Starter/Starter
  // During: MX_Gtwy_Control/Outputs/Starter/Starter
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID0.is_active_c64_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/Starter/Starter
    MX_Gtwy_Control_DWork.bitsForTID0.is_active_c64_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/Starter/Starter
    // Transition: '<S544>:32'
    MX_Gtwy_Control_DWork.bitsForTID0.is_c64_MX_Gtwy_Control =
      MX_Gtwy__IN_NON_FUNCTIONAL_gcn1;

    // Entry 'NON_FUNCTIONAL': '<S544>:30'
    dout_Starter = ((int32_T)INACTIVE != 0);
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c64_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_AUTOMATED:
      // During 'AUTOMATED': '<S544>:34'
      switch (MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED) {
       case MX_Gtwy_Control_IN_ACTIVE_bwmt:
        // During 'ACTIVE': '<S544>:35'
        if ((state_Engine != ENGINE_CRANKING) ||
            (MX_Gtwy_Control_B.RateTransition20_arnl == OORL) || (error_FuelSec
             != NORMAL) || (state_FuelPriOutput != NORMAL) ||
            (state_FuelPriRelay != NORMAL)) {
          // Transition: '<S544>:37'
          MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
            MX_Gtwy_Contr_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S544>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          if (flt_EngineSpeed >= level_StarterAutomatedEngage) {
            // Transition: '<S544>:44'
            MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
              MX_Gtwy_Co_IN_DEBOUNCE_FOR_AUTO;

            // Entry 'DEBOUNCE_FOR_AUTO': '<S544>:43'
            dout_Starter = ((int32_T)ACTIVE != 0);
            MX_Gtwy_Control_DWork.debounceAuto = 0U;
          }
        }
        break;

       case MX_Gtwy_Cont_IN_AUTOMATED_START:
        // During 'AUTOMATED_START': '<S544>:45'
        if ((flt_EngineSpeed >= level_StarterAutomatedDisengage) ||
            (MX_Gtwy_Control_DWork.debounceAuto >= time_StarterAutomated) ||
            (MX_Gtwy_Control_B.RateTransition20_arnl == OORL) || (error_FuelSec
             != NORMAL) || (state_FuelPriOutput != NORMAL) ||
            (state_FuelPriRelay != NORMAL)) {
          // Transition: '<S544>:48'
          MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
            MX_Gtwy_Contr_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S544>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          MX_Gtwy_Control_DWork.debounceAuto = (uint16_T)(int32_T)((int32_T)
            MX_Gtwy_Control_DWork.debounceAuto + 1);
        }
        break;

       case MX_Gtwy_Co_IN_DEBOUNCE_FOR_AUTO:
        // During 'DEBOUNCE_FOR_AUTO': '<S544>:43'
        if (MX_Gtwy_Control_DWork.debounceAuto >=
            CONSTANT_DATA->STARTER_AUTOMATED_DEBOUNCE_ACTIVATE) {
          // Transition: '<S544>:46'
          MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
            MX_Gtwy_Cont_IN_AUTOMATED_START;

          // Entry 'AUTOMATED_START': '<S544>:45'
          dout_Starter = ((int32_T)ACTIVE != 0);
          MX_Gtwy_Control_DWork.debounceAuto = 0U;
        } else if ((state_Engine != ENGINE_CRANKING) ||
                   (MX_Gtwy_Control_B.RateTransition20_arnl == OORL) ||
                   (error_FuelSec != NORMAL) || (state_FuelPriOutput != NORMAL) ||
                   (state_FuelPriRelay != NORMAL)) {
          // Transition: '<S544>:51'
          MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
            MX_Gtwy_Contr_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S544>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          MX_Gtwy_Control_DWork.debounceAuto = (uint16_T)(int32_T)((int32_T)
            MX_Gtwy_Control_DWork.debounceAuto + 1);
        }
        break;

       default:
        // During 'INACTIVE': '<S544>:38'
        if ((state_Engine == ENGINE_CRANKING) &&
            (MX_Gtwy_Control_B.RateTransition20_arnl != OORL) &&
            (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_eduf != ERROR_ON) &&
            (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_jgsb != ERROR_ON) &&
            (error_FuelSec == NORMAL) && (state_FuelPriOutput == NORMAL) &&
            (state_FuelPriRelay == NORMAL)) {
          // Transition: '<S544>:36'
          MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
            MX_Gtwy_Control_IN_ACTIVE_bwmt;

          // Entry 'ACTIVE': '<S544>:35'
          dout_Starter = ((int32_T)ACTIVE != 0);
        }
        break;
      }
      break;

     case MX_Gtwy_Control_IN_MANUAL:
      // During 'MANUAL': '<S544>:31'
      if (MX_Gtwy_Control_DWork.bitsForTID0.is_MANUAL ==
          MX_Gtwy_Control_IN_ACTIVE_bwmt) {
        // During 'ACTIVE': '<S544>:2'
        if ((state_Engine != ENGINE_CRANKING) ||
            (MX_Gtwy_Control_B.RateTransition20_arnl == OORL) || (error_FuelSec
             != NORMAL) || (state_FuelPriOutput != NORMAL) ||
            (state_FuelPriRelay != NORMAL)) {
          // Transition: '<S544>:6'
          MX_Gtwy_Control_DWork.bitsForTID0.is_MANUAL =
            MX_Gtwy_Contro_IN_INACTIVE_h31q;

          // Entry 'INACTIVE': '<S544>:1'
          dout_Starter = ((int32_T)INACTIVE != 0);
        }
      } else {
        // During 'INACTIVE': '<S544>:1'
        if ((state_Engine == ENGINE_CRANKING) &&
            (MX_Gtwy_Control_B.RateTransition20_arnl != OORL) &&
            (MX_Gtwy_Control_DWork.UnitDelay_DSTATE_eduf != ERROR_ON) &&
            (MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_jgsb != ERROR_ON) &&
            (error_FuelSec == NORMAL) && (state_FuelPriOutput == NORMAL) &&
            (state_FuelPriRelay == NORMAL)) {
          // Transition: '<S544>:5'
          MX_Gtwy_Control_DWork.bitsForTID0.is_MANUAL =
            MX_Gtwy_Control_IN_ACTIVE_bwmt;

          // Entry 'ACTIVE': '<S544>:2'
          dout_Starter = ((int32_T)ACTIVE != 0);
        }
      }
      break;

     default:
      // During 'NON_FUNCTIONAL': '<S544>:30'
      if (CONSTANT_DATA->STARTER_FUNCTION != NON_FUNCTIONAL) {
        // Transition: '<S544>:40'
        if (CONSTANT_DATA->STARTER_AUTOMATED_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S544>:42'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c64_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_AUTOMATED;

          // Entry Internal 'AUTOMATED': '<S544>:34'
          // Transition: '<S544>:33'
          MX_Gtwy_Control_DWork.bitsForTID0.is_AUTOMATED =
            MX_Gtwy_Contr_IN_INACTIVE_h31qw;

          // Entry 'INACTIVE': '<S544>:38'
          dout_Starter = ((int32_T)INACTIVE != 0);
        } else {
          // Transition: '<S544>:41'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c64_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_MANUAL;

          // Entry Internal 'MANUAL': '<S544>:31'
          // Transition: '<S544>:4'
          MX_Gtwy_Control_DWork.bitsForTID0.is_MANUAL =
            MX_Gtwy_Contro_IN_INACTIVE_h31q;

          // Entry 'INACTIVE': '<S544>:1'
          dout_Starter = ((int32_T)INACTIVE != 0);
        }
      }
      break;
    }
  }

  // End of Chart: '<S295>/Starter'

  // Outputs for Enabled SubSystem: '<S295>/relay_oc'

  // Inport: '<Root>/dfbk_StarterOutput' incorporates:
  //   Inport: '<Root>/din_StarterRelay'

  MX_Gtwy_Control_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_Starter,
    dfbk_StarterOutput, din_StarterRelay, &state_StarterOutput,
    &state_StarterRelay, &MX_Gtwy_Control_B.relay_oc_n5e3,
    &MX_Gtwy_Control_DWork.relay_oc_n5e3,
    CONSTANT_DATA->STARTER_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->STARTER_DEBOUNCE_ERROR_ON,
    CONSTANT_DATA->STARTER_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S295>/relay_oc'

  // Update for UnitDelay: '<S295>/Unit Delay'
  MX_Gtwy_Control_DWork.UnitDelay_DSTATE_eduf = state_StarterOutput;

  // Update for UnitDelay: '<S295>/Unit Delay1'
  MX_Gtwy_Control_DWork.UnitDelay1_DSTATE_jgsb = state_StarterRelay;
}

// System initialize for atomic system: '<S4>/SwitchedPower'
void MX_Gtwy_Cont_SwitchedPower_Init(void)
{
  // SystemInitialize for Chart: '<S297>/Relay'
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c50_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_liu3;
  MX_Gtwy_Control_DWork.debounceCount_kmuu = 0U;
  dout_SwitchedPwr = false;

  // SystemInitialize for Enabled SubSystem: '<S297>/relay_oc'
  MX_Gtwy_Control_relay_oc_Init(&state_SwitchedPwrOutput,
    &state_SwitchedPwrRelay, &MX_Gtwy_Control_B.relay_oc_icgt,
    &MX_Gtwy_Control_DWork.relay_oc_icgt);

  // End of SystemInitialize for SubSystem: '<S297>/relay_oc'
}

// Output and update for atomic system: '<S4>/SwitchedPower'
void MX_Gtwy_Control_SwitchedPower(void)
{
  boolean_T rtb_HiddenBuf_InsertedFor_relay;

  // SignalConversion: '<S297>/HiddenBuf_InsertedFor_relay_oc_at_inport_3' incorporates:
  //   Constant: '<S297>/Constant'
  //   Constant: '<S552>/Constant'
  //   Constant: '<S553>/Constant'
  //   Constant: '<S554>/Constant'
  //   Inport: '<Root>/state_System'
  //   Logic: '<S297>/Logical Operator'
  //   RelationalOperator: '<S552>/Compare'
  //   RelationalOperator: '<S553>/Compare'
  //   RelationalOperator: '<S554>/Compare'

  rtb_HiddenBuf_InsertedFor_relay =
    ((CONSTANT_DATA->SWITCHED_POWER_RELAY_FEEDBACK_FUNCTION != NON_FUNCTIONAL) &&
     (MX_Gtwy_Control_B.RateTransition14_b2gt != OORL) && (state_System !=
      SYS_POWER_DOWN));

  // Chart: '<S297>/Relay' incorporates:
  //   Inport: '<Root>/din_RemoteKey'
  //   Inport: '<Root>/state_System'

  // Gateway: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
  // During: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
  if ((uint32_T)MX_Gtwy_Control_DWork.bitsForTID0.is_active_c50_MX_Gtwy_Control ==
      0U) {
    // Entry: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
    MX_Gtwy_Control_DWork.bitsForTID0.is_active_c50_MX_Gtwy_Control = 1U;

    // Entry Internal: MX_Gtwy_Control/Outputs/SwitchedPower/Relay
    // Transition: '<S555>:7'
    MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
      MX_Gtwy_Contro_IN_INACTIVE_bo51;

    // Entry 'INACTIVE': '<S555>:1'
    dout_SwitchedPwr = ((int32_T)INACTIVE != 0);
  } else {
    switch (MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control) {
     case MX_Gtwy_Control_IN_ACTIVE_ftye:
      // During 'ACTIVE': '<S555>:2'
      if ((state_System == SYS_POWER_DOWN) || ((state_System == SYS_LIMITED) &&
           (state_Key == INACTIVE))) {
        // Transition: '<S555>:9'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_DELAY_OFF;

        // Entry 'DELAY_OFF': '<S555>:5'
        MX_Gtwy_Control_DWork.debounceCount_kmuu = 0U;
      }
      break;

     case MX_G_IN_DEBOUNCE_ERROR_ON_CHECK:
      // During 'DEBOUNCE_ERROR_ON_CHECK': '<S555>:3'
      // Transition: '<S555>:27'
      if ((CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_ON == UNLIMITED) ||
          ((int32_T)MX_Gtwy_Control_DWork.debounceCount_kmuu >= (int32_T)
           ((int32_T)CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_ON + 2)))
      {
        // Transition: '<S555>:28'
        // Transition: '<S555>:10'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
          MX_Gtwy_Control_IN_ACTIVE_ftye;

        // Entry 'ACTIVE': '<S555>:2'
        dout_SwitchedPwr = ((int32_T)ACTIVE != 0);
      } else {
        // Transition: '<S555>:30'
        MX_Gtwy_Control_DWork.debounceCount_kmuu = (uint16_T)(int32_T)((int32_T)
          MX_Gtwy_Control_DWork.debounceCount_kmuu + 1);
      }
      break;

     case MX_Gtwy_Control_IN_DELAY_OFF:
      // During 'DELAY_OFF': '<S555>:5'
      if (MX_Gtwy_Control_DWork.debounceCount_kmuu >=
          CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_SHUTDOWN) {
        // Transition: '<S555>:12'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
          MX_Gtwy_Contro_IN_INACTIVE_bo51;

        // Entry 'INACTIVE': '<S555>:1'
        dout_SwitchedPwr = ((int32_T)INACTIVE != 0);
      } else {
        MX_Gtwy_Control_DWork.debounceCount_kmuu = (uint16_T)(int32_T)((int32_T)
          MX_Gtwy_Control_DWork.debounceCount_kmuu + 1);
      }
      break;

     default:
      // During 'INACTIVE': '<S555>:1'
      if ((state_Key != INACTIVE) && (din_RemoteKey == INACTIVE) &&
          (state_System != SYS_POWER_DOWN) && (state_System != SYS_LIMITED)) {
        // Transition: '<S555>:8'
        MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
          MX_G_IN_DEBOUNCE_ERROR_ON_CHECK;

        // Entry 'DEBOUNCE_ERROR_ON_CHECK': '<S555>:3'
        MX_Gtwy_Control_DWork.debounceCount_kmuu = 0U;
      } else {
        if ((din_RemoteKey == ACTIVE) && (state_System != SYS_POWER_DOWN)) {
          // Transition: '<S555>:11'
          MX_Gtwy_Control_DWork.bitsForTID0.is_c50_MX_Gtwy_Control =
            MX_Gtwy_Control_IN_ACTIVE_ftye;

          // Entry 'ACTIVE': '<S555>:2'
          dout_SwitchedPwr = ((int32_T)ACTIVE != 0);
        }
      }
      break;
    }
  }

  // End of Chart: '<S297>/Relay'

  // Outputs for Enabled SubSystem: '<S297>/relay_oc'

  // Inport: '<Root>/dfbk_SwPowerOutput' incorporates:
  //   Inport: '<Root>/din_SwPowerRelay'

  MX_Gtwy_Control_relay_oc(rtb_HiddenBuf_InsertedFor_relay, dout_SwitchedPwr,
    dfbk_SwPowerOutput, din_SwPowerRelay, &state_SwitchedPwrOutput,
    &state_SwitchedPwrRelay, &MX_Gtwy_Control_B.relay_oc_icgt,
    &MX_Gtwy_Control_DWork.relay_oc_icgt,
    CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_OFF,
    CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_ERROR_ON,
    CONSTANT_DATA->SWITCHED_POWER_RELAY_DEBOUNCE_NORMAL);

  // End of Outputs for SubSystem: '<S297>/relay_oc'
}

// Function for Chart: '<S561>/TwoSpeed_Control'
static void MX_Gtwy_Control_Normal(uint8_T *state_TwoSpeedIcon_czcv, uint8_T
  *FixPtRelationalOperator_n1fs)
{
  // During 'Normal': '<S564>:80'
  if (MX_Gtwy_Control_DWork.bitsForTID0.is_Normal_epj5 ==
      MX_Gtwy_Control_IN_Active_pkjk) {
    // During 'Active': '<S564>:14'
    if ((state_Console != ACTIVE) || (MX_Gtwy_Control_B.RateTransition8 == HIGH)
        || (MX_Gtwy_Control_B.RateTransition8 == EXTREMELY_HIGH) ||
        (MX_Gtwy_Control_B.RateTransition6_awvq == HIGH) ||
        (MX_Gtwy_Control_B.RateTransition6_awvq == EXTREMELY_HIGH)) {
      // Transition: '<S564>:28'
      // Exit Internal 'Active': '<S564>:14'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Normal_epj5 =
        MX_Gtwy_Contro_IN_Inactive_mv0f;

      // Entry 'Inactive': '<S564>:12'
      MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
      *state_TwoSpeedIcon_czcv = INACTIVE;
    } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 ==
               MX_Gtwy_Control_IN_High) {
      *state_TwoSpeedIcon_czcv = ACTIVE;

      // During 'High': '<S564>:10'
      if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
        // Transition: '<S564>:156'
        if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S564>:166'
          // Transition: '<S564>:167'
          state_Buzzer = SINGLE_SHORT_BEEP;
        } else {
          // Transition: '<S564>:165'
        }

        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 =
          MX_Gtwy_Control_IN_Low;

        // Entry 'Low': '<S564>:11'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Low': '<S564>:11'
      if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
        // Transition: '<S564>:157'
        if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S564>:160'
          // Transition: '<S564>:161'
          state_Buzzer = DOUBLE_SHORT_BEEP;
        } else {
          // Transition: '<S564>:162'
        }

        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 =
          MX_Gtwy_Control_IN_High;

        // Entry 'High': '<S564>:10'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
        *state_TwoSpeedIcon_czcv = ACTIVE;
      }
    }
  } else {
    *state_TwoSpeedIcon_czcv = INACTIVE;

    // During 'Inactive': '<S564>:12'
    if ((state_Console == ACTIVE) && (MX_Gtwy_Control_B.RateTransition8 != HIGH)
        && (MX_Gtwy_Control_B.RateTransition8 != EXTREMELY_HIGH) &&
        (MX_Gtwy_Control_B.RateTransition6_awvq != HIGH) &&
        (MX_Gtwy_Control_B.RateTransition6_awvq != EXTREMELY_HIGH)) {
      // Transition: '<S564>:31'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Normal_epj5 =
        MX_Gtwy_Control_IN_Active_pkjk;

      // Entry Internal 'Active': '<S564>:14'
      // Transition: '<S564>:24'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 = MX_Gtwy_Control_IN_Low;

      // Entry 'Low': '<S564>:11'
      MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
    }
  }
}

// Function for Chart: '<S561>/TwoSpeed_Control'
static void MX_Gtwy_Control_Control(uint8_T *state_TwoSpeedIcon_czcv, const
  boolean_T *Compare_geoy, const uint16_T *DataTypeConversion3, uint8_T
  *FixPtRelationalOperator_n1fs)
{
  // During 'Control': '<S564>:6'
  switch (MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1) {
   case MX_Gtwy_Control_IN_AutoShift:
    // During 'AutoShift': '<S564>:85'
    if (MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift ==
        MX_Gtwy_Control_IN_Active_pkjk) {
      // During 'Active': '<S564>:90'
      if ((state_Console != ACTIVE) || (MX_Gtwy_Control_B.RateTransition8 ==
           HIGH) || (MX_Gtwy_Control_B.RateTransition8 == EXTREMELY_HIGH) ||
          (MX_Gtwy_Control_B.RateTransition6_awvq == HIGH) ||
          (MX_Gtwy_Control_B.RateTransition6_awvq == EXTREMELY_HIGH)) {
        // Transition: '<S564>:87'
        // Exit Internal 'Active': '<S564>:90'
        // Exit Internal 'Autoshift_Active': '<S564>:95'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift =
          MX_Gtwy_Contro_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S564>:89'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz ==
                 MX_Gtwy_Con_IN_Autoshift_Active) {
        *state_TwoSpeedIcon_czcv = ACTIVE;

        // During 'Autoshift_Active': '<S564>:95'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S564>:93'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S564>:154'
            // Transition: '<S564>:155'
            state_Buzzer = SINGLE_SHORT_BEEP;
          } else {
            // Transition: '<S564>:153'
          }

          // Exit Internal 'Autoshift_Active': '<S564>:95'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz =
            MX_Gtwy_C_IN_Autoshift_Inactive;

          // Entry 'Autoshift_Inactive': '<S564>:94'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
          *state_TwoSpeedIcon_czcv = INACTIVE;
        } else {
          switch (MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active) {
           case MX_Gtwy_Control_IN_Delay_b1g5:
            // During 'Delay': '<S564>:121'
            if (MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 >=
                CONSTANT_DATA->AUTOSHIFT_TRAVEL_DELAY) {
              // Transition: '<S564>:116'
              MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                MX_Gtwy_Control_IN_High_pby2;

              // Entry 'High': '<S564>:104'
              MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
            } else {
              if (*Compare_geoy == (int32_T)INACTIVE) {
                // Transition: '<S564>:117'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                  MX_Gtwy_Contro_IN_Low_No_Travel;

                // Entry 'Low_No_Travel': '<S564>:103'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
              }
            }
            break;

           case MX_Gtwy_Control_IN_High_pby2:
            // During 'High': '<S564>:104'
            if ((*DataTypeConversion3 > MX_Gtwy_Control_B.P_highLookup) &&
                (state_LoadSense == NORMAL)) {
              // Transition: '<S564>:106'
              MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                MX_Gtwy_Cont_IN_Low_Travel_aquv;

              // Entry 'Low_Travel': '<S564>:122'
              MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
            } else {
              if (*Compare_geoy == (int32_T)INACTIVE) {
                // Transition: '<S564>:115'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                  MX_Gtwy_Contro_IN_Low_No_Travel;

                // Entry 'Low_No_Travel': '<S564>:103'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
              }
            }
            break;

           case MX_Gtwy_Contro_IN_Low_No_Travel:
            // During 'Low_No_Travel': '<S564>:103'
            if (*Compare_geoy == (int32_T)ACTIVE) {
              // Transition: '<S564>:105'
              if ((int32_T)CONSTANT_DATA->AUTOSHIFT_TRAVEL_DELAY > 0) {
                // Transition: '<S564>:130'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                  MX_Gtwy_Control_IN_Delay_b1g5;
                MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 = 0U;
              } else {
                // Transition: '<S564>:133'
                // Transition: '<S564>:131'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                  MX_Gtwy_Control_IN_High_pby2;

                // Entry 'High': '<S564>:104'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
              }
            }
            break;

           default:
            // During 'Low_Travel': '<S564>:122'
            if (*Compare_geoy == (int32_T)INACTIVE) {
              // Transition: '<S564>:124'
              MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                MX_Gtwy_Contro_IN_Low_No_Travel;

              // Entry 'Low_No_Travel': '<S564>:103'
              MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
            } else {
              if ((*DataTypeConversion3 < MX_Gtwy_Control_B.P_lowLookup) ||
                  (state_LoadSense != NORMAL)) {
                // Transition: '<S564>:123'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
                  MX_Gtwy_Control_IN_High_pby2;

                // Entry 'High': '<S564>:104'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
              }
            }
            break;
          }
        }
      } else {
        *state_TwoSpeedIcon_czcv = INACTIVE;

        // During 'Autoshift_Inactive': '<S564>:94'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S564>:92'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S564>:148'
            // Transition: '<S564>:149'
            state_Buzzer = DOUBLE_SHORT_BEEP;
          } else {
            // Transition: '<S564>:150'
          }

          MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz =
            MX_Gtwy_Con_IN_Autoshift_Active;

          // Entry 'Autoshift_Active': '<S564>:95'
          *state_TwoSpeedIcon_czcv = ACTIVE;

          // Entry Internal 'Autoshift_Active': '<S564>:95'
          // Transition: '<S564>:101'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
            MX_Gtwy_Contro_IN_Low_No_Travel;

          // Entry 'Low_No_Travel': '<S564>:103'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
        }
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Inactive': '<S564>:89'
      if ((state_Console == ACTIVE) && (MX_Gtwy_Control_B.RateTransition8 !=
           HIGH) && (MX_Gtwy_Control_B.RateTransition8 != EXTREMELY_HIGH) &&
          (MX_Gtwy_Control_B.RateTransition6_awvq != HIGH) &&
          (MX_Gtwy_Control_B.RateTransition6_awvq != EXTREMELY_HIGH)) {
        // Transition: '<S564>:88'
        MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift =
          MX_Gtwy_Control_IN_Active_pkjk;

        // Entry Internal 'Active': '<S564>:90'
        // Transition: '<S564>:107'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz =
          MX_Gtwy_C_IN_Autoshift_Inactive;

        // Entry 'Autoshift_Inactive': '<S564>:94'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
      }
    }
    break;

   case MX_IN_AutoShift_TrackTensioning:
    // During 'AutoShift_TrackTensioning': '<S564>:205'
    if (MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift_TrackTensioning ==
        MX_Gtwy_Control_IN_Active_pkjk) {
      // During 'Active': '<S564>:210'
      if ((state_Console != ACTIVE) || (MX_Gtwy_Control_B.RateTransition8 ==
           HIGH) || (MX_Gtwy_Control_B.RateTransition8 == EXTREMELY_HIGH) ||
          (MX_Gtwy_Control_B.RateTransition6_awvq == HIGH) ||
          (MX_Gtwy_Control_B.RateTransition6_awvq == EXTREMELY_HIGH)) {
        // Transition: '<S564>:208'
        // Exit Internal 'Active': '<S564>:210'
        // Exit Internal 'High_Range_Available': '<S564>:225'
        MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;

        // Exit Internal 'Travel_Autoshift': '<S564>:251'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;

        // Exit Internal 'Low_Range': '<S564>:224'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift_TrackTensioning =
          MX_Gtwy_Contro_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S564>:209'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk ==
                 MX_Gtwy_IN_High_Range_Available) {
        *state_TwoSpeedIcon_czcv = ACTIVE;

        // During 'High_Range_Available': '<S564>:225'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S564>:223'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S564>:220'
            // Transition: '<S564>:218'
            state_Buzzer = SINGLE_SHORT_BEEP;
          } else {
            // Transition: '<S564>:217'
          }

          // Exit Internal 'High_Range_Available': '<S564>:225'
          MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;

          // Exit Internal 'Travel_Autoshift': '<S564>:251'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk =
            MX_Gtwy_Control_IN_Low_Range;

          // Entry 'Low_Range': '<S564>:224'
          *state_TwoSpeedIcon_czcv = INACTIVE;

          // Entry Internal 'Low_Range': '<S564>:224'
          // Transition: '<S564>:247'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
            MX_Gtwy_Control_IN_Normal_h4rfj;

          // Entry 'Normal': '<S564>:246'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available ==
                   MX_Gtwy_Contro_IN_NoTravel_High) {
          // During 'NoTravel_High': '<S564>:252'
          if (*Compare_geoy == (int32_T)ACTIVE) {
            // Transition: '<S564>:256'
            MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
              MX_Gtwy_Con_IN_Travel_Autoshift;

            // Entry Internal 'Travel_Autoshift': '<S564>:251'
            // Transition: '<S564>:228'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
              MX_Gtwy_Control_IN_Low_Delay;
            MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 = 0U;

            // Entry 'Low_Delay': '<S564>:254'
            MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
          }
        } else {
          // During 'Travel_Autoshift': '<S564>:251'
          if (*Compare_geoy == (int32_T)INACTIVE) {
            // Transition: '<S564>:257'
            // Exit Internal 'Travel_Autoshift': '<S564>:251'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
              MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
            MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
              MX_Gtwy_Contro_IN_NoTravel_High;

            // Entry 'NoTravel_High': '<S564>:252'
            MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
          } else {
            switch (MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift) {
             case MX_Gtwy_Control_IN_High:
              // During 'High': '<S564>:241'
              if ((*DataTypeConversion3 > MX_Gtwy_Control_B.P_highLookup) &&
                  (state_LoadSense == NORMAL)) {
                // Transition: '<S564>:237'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
                  MX_Gtwy_Control_IN_Low_Travel;

                // Entry 'Low_Travel': '<S564>:242'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
              }
              break;

             case MX_Gtwy_Control_IN_Low_Delay:
              // During 'Low_Delay': '<S564>:254'
              if (MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 >=
                  CONSTANT_DATA->AUTOSHIFT_TRAVEL_DELAY) {
                // Transition: '<S564>:255'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
                  MX_Gtwy_Control_IN_High;

                // Entry 'High': '<S564>:241'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
              }
              break;

             default:
              // During 'Low_Travel': '<S564>:242'
              if ((*DataTypeConversion3 < MX_Gtwy_Control_B.P_lowLookup) ||
                  (state_LoadSense != NORMAL)) {
                // Transition: '<S564>:238'
                MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
                  MX_Gtwy_Control_IN_High;

                // Entry 'High': '<S564>:241'
                MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
              }
              break;
            }
          }
        }
      } else {
        *state_TwoSpeedIcon_czcv = INACTIVE;

        // During 'Low_Range': '<S564>:224'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S564>:216'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S564>:219'
            // Transition: '<S564>:222'
            state_Buzzer = DOUBLE_SHORT_BEEP;
          } else {
            // Transition: '<S564>:221'
          }

          // Exit Internal 'Low_Range': '<S564>:224'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk =
            MX_Gtwy_IN_High_Range_Available;

          // Entry 'High_Range_Available': '<S564>:225'
          *state_TwoSpeedIcon_czcv = ACTIVE;

          // Entry Internal 'High_Range_Available': '<S564>:225'
          // Transition: '<S564>:253'
          MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
            MX_Gtwy_Contro_IN_NoTravel_High;

          // Entry 'NoTravel_High': '<S564>:252'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range ==
                   MX_Gtwy_Control_IN_Normal_h4rfj) {
          // During 'Normal': '<S564>:246'
          if (*Compare_geoy == (int32_T)INACTIVE) {
            // Transition: '<S564>:243'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
              MX_Gtwy_Con_IN_Track_Tensioning;

            // Entry 'Track_Tensioning': '<S564>:245'
            MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
          }
        } else {
          // During 'Track_Tensioning': '<S564>:245'
          if (*Compare_geoy == (int32_T)ACTIVE) {
            // Transition: '<S564>:244'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
              MX_Gtwy_Control_IN_Normal_h4rfj;

            // Entry 'Normal': '<S564>:246'
            MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
          }
        }
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Inactive': '<S564>:209'
      if ((state_Console == ACTIVE) && (MX_Gtwy_Control_B.RateTransition8 !=
           HIGH) && (MX_Gtwy_Control_B.RateTransition8 != EXTREMELY_HIGH) &&
          (MX_Gtwy_Control_B.RateTransition6_awvq != HIGH) &&
          (MX_Gtwy_Control_B.RateTransition6_awvq != EXTREMELY_HIGH)) {
        // Transition: '<S564>:207'
        MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift_TrackTensioning =
          MX_Gtwy_Control_IN_Active_pkjk;

        // Entry Internal 'Active': '<S564>:210'
        // Transition: '<S564>:215'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk =
          MX_Gtwy_Control_IN_Low_Range;

        // Entry 'Low_Range': '<S564>:224'
        // Entry Internal 'Low_Range': '<S564>:224'
        // Transition: '<S564>:247'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
          MX_Gtwy_Control_IN_Normal_h4rfj;

        // Entry 'Normal': '<S564>:246'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
      }
    }
    break;

   case MX_Gtwy_Contro_IN_NonFunctional:
    *state_TwoSpeedIcon_czcv = INACTIVE;

    // During 'NonFunctional': '<S564>:83'
    // Transition: '<S564>:84'
    if ((CONSTANT_DATA->AUTOSHIFT_FUNCTION != NON_FUNCTIONAL) &&
        (CONSTANT_DATA->TRACKTENSION_FUNCTION != NON_FUNCTIONAL)) {
      // Transition: '<S564>:250'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
        MX_IN_AutoShift_TrackTensioning;

      // Entry Internal 'AutoShift_TrackTensioning': '<S564>:205'
      // Transition: '<S564>:206'
      MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift_TrackTensioning =
        MX_Gtwy_Contro_IN_Inactive_mv0f;

      // Entry 'Inactive': '<S564>:209'
      MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
    } else {
      // Transition: '<S564>:249'
      if (CONSTANT_DATA->AUTOSHIFT_FUNCTION != NON_FUNCTIONAL) {
        // Transition: '<S564>:98'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
          MX_Gtwy_Control_IN_AutoShift;

        // Entry Internal 'AutoShift': '<S564>:85'
        // Transition: '<S564>:86'
        MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift =
          MX_Gtwy_Contro_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S564>:89'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
      } else {
        // Transition: '<S564>:195'
        if (CONSTANT_DATA->TRACKTENSION_FUNCTION != NON_FUNCTIONAL) {
          // Transition: '<S564>:194'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
            MX_Gtwy_Cont_IN_TrackTensioning;

          // Entry Internal 'TrackTensioning': '<S564>:172'
          // Transition: '<S564>:173'
          MX_Gtwy_Control_DWork.bitsForTID0.is_TrackTensioning =
            MX_Gtwy_Contro_IN_Inactive_mv0f;

          // Entry 'Inactive': '<S564>:176'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
        } else {
          // Transition: '<S564>:196'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
            MX_Gtwy_Control_IN_Normal_h4rf;

          // Entry Internal 'Normal': '<S564>:80'
          // Transition: '<S564>:32'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Normal_epj5 =
            MX_Gtwy_Contro_IN_Inactive_mv0f;

          // Entry 'Inactive': '<S564>:12'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
        }
      }
    }
    break;

   case MX_Gtwy_Control_IN_Normal_h4rf:
    MX_Gtwy_Control_Normal(state_TwoSpeedIcon_czcv, FixPtRelationalOperator_n1fs);
    break;

   default:
    // During 'TrackTensioning': '<S564>:172'
    if (MX_Gtwy_Control_DWork.bitsForTID0.is_TrackTensioning ==
        MX_Gtwy_Control_IN_Active_pkjk) {
      // During 'Active': '<S564>:177'
      if (state_Console != ACTIVE) {
        // Transition: '<S564>:174'
        // Exit Internal 'Active': '<S564>:177'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;

        // Exit Internal 'Low': '<S564>:191'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Low =
          MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
        MX_Gtwy_Control_DWork.bitsForTID0.is_TrackTensioning =
          MX_Gtwy_Contro_IN_Inactive_mv0f;

        // Entry 'Inactive': '<S564>:176'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
        *state_TwoSpeedIcon_czcv = INACTIVE;
      } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 ==
                 MX_Gtwy_Control_IN_High) {
        *state_TwoSpeedIcon_czcv = ACTIVE;

        // During 'High': '<S564>:192'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S564>:190'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S564>:187'
            // Transition: '<S564>:185'
            state_Buzzer = SINGLE_SHORT_BEEP;
          } else {
            // Transition: '<S564>:184'
          }

          MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 =
            MX_Gtwy_Control_IN_Low;

          // Entry 'Low': '<S564>:191'
          *state_TwoSpeedIcon_czcv = INACTIVE;

          // Entry Internal 'Low': '<S564>:191'
          // Transition: '<S564>:202'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Low =
            MX_Gtwy_Control_IN_Normal_h4rfj;

          // Entry 'Normal': '<S564>:201'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
        }
      } else {
        *state_TwoSpeedIcon_czcv = INACTIVE;

        // During 'Low': '<S564>:191'
        if ((int32_T)*FixPtRelationalOperator_n1fs != 0) {
          // Transition: '<S564>:183'
          if (CONSTANT_DATA->TWOSPEED_BEEP_FUNCTION != NON_FUNCTIONAL) {
            // Transition: '<S564>:186'
            // Transition: '<S564>:189'
            state_Buzzer = DOUBLE_SHORT_BEEP;
          } else {
            // Transition: '<S564>:188'
          }

          // Exit Internal 'Low': '<S564>:191'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Low =
            MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
          MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 =
            MX_Gtwy_Control_IN_High;

          // Entry 'High': '<S564>:192'
          MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
          *state_TwoSpeedIcon_czcv = ACTIVE;
        } else if (MX_Gtwy_Control_DWork.bitsForTID0.is_Low ==
                   MX_Gtwy_Control_IN_Normal_h4rfj) {
          // During 'Normal': '<S564>:201'
          if (*Compare_geoy == (int32_T)INACTIVE) {
            // Transition: '<S564>:203'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Low =
              MX_Gtwy_Con_IN_Track_Tensioning;

            // Entry 'Track_Tensioning': '<S564>:198'
            MX_Gtwy_Control_DWork.cmd_TwoSpeed = HIGH;
          }
        } else {
          // During 'Track_Tensioning': '<S564>:198'
          if (*Compare_geoy == (int32_T)ACTIVE) {
            // Transition: '<S564>:204'
            MX_Gtwy_Control_DWork.bitsForTID0.is_Low =
              MX_Gtwy_Control_IN_Normal_h4rfj;

            // Entry 'Normal': '<S564>:201'
            MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
          }
        }
      }
    } else {
      *state_TwoSpeedIcon_czcv = INACTIVE;

      // During 'Inactive': '<S564>:176'
      if (state_Console == ACTIVE) {
        // Transition: '<S564>:175'
        MX_Gtwy_Control_DWork.bitsForTID0.is_TrackTensioning =
          MX_Gtwy_Control_IN_Active_pkjk;

        // Entry Internal 'Active': '<S564>:177'
        // Transition: '<S564>:182'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 =
          MX_Gtwy_Control_IN_Low;

        // Entry 'Low': '<S564>:191'
        // Entry Internal 'Low': '<S564>:191'
        // Transition: '<S564>:202'
        MX_Gtwy_Control_DWork.bitsForTID0.is_Low =
          MX_Gtwy_Control_IN_Normal_h4rfj;

        // Entry 'Normal': '<S564>:201'
        MX_Gtwy_Control_DWork.cmd_TwoSpeed = LOW;
      }
    }
    break;
  }
}

// System initialize for atomic system: '<S4>/Two_Speed'
void MX_Gtwy_Control_Two_Speed_Init(void)
{
  uint16_T duty_TwoSpeed_mabj;

  // SystemInitialize for Enabled SubSystem: '<S298>/Two_Speed'
  // InitializeConditions for UnitDelay: '<S562>/Delay Input1'
  MX_Gtwy_Control_DWork.DelayInput1_DSTATE_defa = ((uint8_T)0U);

  // SystemInitialize for Chart: '<S561>/TwoSpeed_Control'
  MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift_TrackTensioning =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 = 0U;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Normal_epj5 =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_TrackTensioning =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Low = MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_Two_Speed_Command =
    MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
  MX_Gtwy_Control_DWork.bitsForTID0.is_active_c47_MX_Gtwy_Control = 0U;
  MX_Gtwy_Control_DWork.cmd_TwoSpeed = 0U;
  duty_TwoSpeed_mabj = 0U;

  // SystemInitialize for Atomic SubSystem: '<S561>/hc_Output'
  MX__output_single_OpenLoop_Init(&MX_Gtwy_Control_B.state_Output,
    &MX_Gtwy_Control_B.hc_Output, &MX_Gtwy_Control_DWork.hc_Output);

  // End of SystemInitialize for SubSystem: '<S561>/hc_Output'

  // End of SystemInitialize for SubSystem: '<S298>/Two_Speed'
}

// Output and update for atomic system: '<S4>/Two_Speed'
void MX_Gtwy_Control_Two_Speed(void)
{
  uint8_T state_TwoSpeedIcon_czcv;
  uint16_T duty_TwoSpeed_mabj;
  boolean_T Compare_geoy;
  uint16_T DataTypeConversion3;
  int16_T rtb_TmpSignalConversionAtP_lowL[2];
  uint16_T rtb_TmpSignalConversionAtP_jztu[2];
  int16_T rtb_Switch_e2ax;
  uint8_T FixPtRelationalOperator_n1fs;

  // RelationalOperator: '<S558>/Compare' incorporates:
  //   Constant: '<S558>/Constant'
  //   Inport: '<Root>/adin_TravelPressureSwitch'

  Compare_geoy = (adin_TravelPressureSwitch > ((uint16_T)512U));

  // DataTypeConversion: '<S298>/Data Type Conversion3'
  DataTypeConversion3 = (uint16_T)(int32_T)(uint32_T)((uint32_T)bar_LoadSense >>
    7);

  // Outputs for Enabled SubSystem: '<S298>/Two_Speed' incorporates:
  //   EnablePort: '<S561>/Enable'

  // Logic: '<S298>/Logical Operator1' incorporates:
  //   Constant: '<S298>/Constant'
  //   Constant: '<S559>/Constant'
  //   Constant: '<S560>/Constant'
  //   Inport: '<Root>/afbk_TwoSpeed'
  //   Inport: '<Root>/state_System'
  //   RelationalOperator: '<S559>/Compare'
  //   RelationalOperator: '<S560>/Compare'

  if ((CONSTANT_DATA->TWOSPEED_FUNCTION != NON_FUNCTIONAL) && (state_System ==
       SYS_NORMAL)) {
    if (!MX_Gtwy_Control_DWork.Two_Speed_MODE) {
      // InitializeConditions for UnitDelay: '<S562>/Delay Input1'
      MX_Gtwy_Control_DWork.DelayInput1_DSTATE_defa = ((uint8_T)0U);

      // SystemReset for Chart: '<S561>/TwoSpeed_Control'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_cebz =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Autoshift_Active =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_AutoShift_TrackTensioning =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_m2xk =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_High_Range_Available =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Travel_Autoshift =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 = 0U;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Low_Range =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Normal_epj5 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_dfj0 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_TrackTensioning =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Active_ipr2 =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Low = MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_Two_Speed_Command =
        MX_Gtwy_IN_NO_ACTIVE_CHILD_ojcz;
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c47_MX_Gtwy_Control = 0U;
      MX_Gtwy_Control_DWork.cmd_TwoSpeed = 0U;
      state_TwoSpeedIcon_czcv = 0U;
      duty_TwoSpeed_mabj = 0U;

      // SystemReset for Atomic SubSystem: '<S561>/hc_Output'
      MX_output_single_OpenLoop_Reset(&MX_Gtwy_Control_B.state_Output,
        &MX_Gtwy_Control_B.hc_Output, &MX_Gtwy_Control_DWork.hc_Output);

      // End of SystemReset for SubSystem: '<S561>/hc_Output'
      MX_Gtwy_Control_DWork.Two_Speed_MODE = true;
    }

    // RelationalOperator: '<S562>/FixPt Relational Operator' incorporates:
    //   Inport: '<Root>/din_TwoSpeedSwitch'
    //   UnitDelay: '<S562>/Delay Input1'

    FixPtRelationalOperator_n1fs = (uint8_T)(din_TwoSpeedSwitch >
      MX_Gtwy_Control_DWork.DelayInput1_DSTATE_defa);

    // Switch: '<S563>/Switch' incorporates:
    //   Constant: '<S563>/Constant8'
    //   Constant: '<S563>/Constant9'
    //   Constant: '<S566>/Constant'
    //   Constant: '<S567>/Constant'
    //   DataTypeConversion: '<S563>/Data Type Conversion'
    //   Logic: '<S563>/Logical Operator'
    //   RelationalOperator: '<S566>/Compare'
    //   RelationalOperator: '<S567>/Compare'
    //   Sum: '<S563>/Sum'

    if ((MX_Gtwy_Control_B.RateTransition8 == OORL) ||
        (MX_Gtwy_Control_B.RateTransition8 == OORH)) {
      rtb_Switch_e2ax = 300;
    } else {
      rtb_Switch_e2ax = (int16_T)(int32_T)((int32_T)(int16_T)
        MX_Gtwy_Control_B.RateTransition9 - (int32_T)((uint8_T)40U));
    }

    // End of Switch: '<S563>/Switch'

    // SignalConversion: '<S563>/TmpSignal ConversionAtP_high LookupInport2' incorporates:
    //   Constant: '<S563>/Constant'
    //   Constant: '<S563>/Constant1'

    rtb_TmpSignalConversionAtP_lowL[0] = CONSTANT_DATA->AUTOSHIFT_PHIGH_TEMP1;
    rtb_TmpSignalConversionAtP_lowL[1] = CONSTANT_DATA->AUTOSHIFT_PHIGH_TEMP2;

    // SignalConversion: '<S563>/TmpSignal ConversionAtP_high LookupInport3' incorporates:
    //   Constant: '<S563>/Constant2'
    //   Constant: '<S563>/Constant3'

    rtb_TmpSignalConversionAtP_jztu[0] = CONSTANT_DATA->AUTOSHIFT_PHIGH1;
    rtb_TmpSignalConversionAtP_jztu[1] = CONSTANT_DATA->AUTOSHIFT_PHIGH2;

    // S-Function (sfix_look1_dyn): '<S563>/P_high Lookup'
    // Dynamic Look-Up Table Block: '<S563>/P_high Lookup'
    //  Input0  Data Type:  Integer        S16
    //  Input1  Data Type:  Integer        S16
    //  Input2  Data Type:  Integer        U16
    //  Output0 Data Type:  Integer        U16
    //  Lookup Method: Linear_Endpoint
    //

    LookUp_U16_S16( &(MX_Gtwy_Control_B.P_highLookup),
                   &rtb_TmpSignalConversionAtP_jztu[0], rtb_Switch_e2ax,
                   &rtb_TmpSignalConversionAtP_lowL[0], 1U);

    // SignalConversion: '<S563>/TmpSignal ConversionAtP_low LookupInport2' incorporates:
    //   Constant: '<S563>/Constant4'
    //   Constant: '<S563>/Constant5'

    rtb_TmpSignalConversionAtP_lowL[0] = CONSTANT_DATA->AUTOSHIFT_PLOW_TEMP1;
    rtb_TmpSignalConversionAtP_lowL[1] = CONSTANT_DATA->AUTOSHIFT_PLOW_TEMP2;

    // SignalConversion: '<S563>/TmpSignal ConversionAtP_low LookupInport3' incorporates:
    //   Constant: '<S563>/Constant6'
    //   Constant: '<S563>/Constant7'

    rtb_TmpSignalConversionAtP_jztu[0] = CONSTANT_DATA->AUTOSHIFT_PLOW1;
    rtb_TmpSignalConversionAtP_jztu[1] = CONSTANT_DATA->AUTOSHIFT_PLOW2;

    // S-Function (sfix_look1_dyn): '<S563>/P_low Lookup'
    // Dynamic Look-Up Table Block: '<S563>/P_low Lookup'
    //  Input0  Data Type:  Integer        S16
    //  Input1  Data Type:  Integer        S16
    //  Input2  Data Type:  Integer        U16
    //  Output0 Data Type:  Integer        U16
    //  Lookup Method: Linear_Endpoint
    //

    LookUp_U16_S16( &(MX_Gtwy_Control_B.P_lowLookup),
                   &rtb_TmpSignalConversionAtP_jztu[0], rtb_Switch_e2ax,
                   &rtb_TmpSignalConversionAtP_lowL[0], 1U);

    // Chart: '<S561>/TwoSpeed_Control'
    // Gateway: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control
    if ((uint32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 < 255U) {
      MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 = (uint8_T)(int32_T)
        ((int32_T)MX_Gtwy_Control_DWork.temporalCounter_i1_ozg1 + 1);
    }

    // During: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control
    if ((uint32_T)
        MX_Gtwy_Control_DWork.bitsForTID0.is_active_c47_MX_Gtwy_Control == 0U) {
      // Entry: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control
      MX_Gtwy_Control_DWork.bitsForTID0.is_active_c47_MX_Gtwy_Control = 1U;

      // Entry Internal: MX_Gtwy_Control/Outputs/Two_Speed/Two_Speed/TwoSpeed_Control 
      // Entry Internal 'Control': '<S564>:6'
      // Transition: '<S564>:82'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Control_ksz1 =
        MX_Gtwy_Contro_IN_NonFunctional;

      // Entry 'NonFunctional': '<S564>:83'
      MX_Gtwy_Control_DWork.cmd_TwoSpeed = INACTIVE;
      state_TwoSpeedIcon_czcv = INACTIVE;

      // Entry Internal 'Two_Speed_Command': '<S564>:16'
      // Transition: '<S564>:38'
      MX_Gtwy_Control_DWork.bitsForTID0.is_Two_Speed_Command =
        MX_Gtwy_Control_IN_Low;

      // Entry 'Low': '<S564>:17'
      duty_TwoSpeed_mabj = 0U;
    } else {
      MX_Gtwy_Control_Control(&state_TwoSpeedIcon_czcv, &Compare_geoy,
        &DataTypeConversion3, &FixPtRelationalOperator_n1fs);

      // During 'Two_Speed_Command': '<S564>:16'
      if (MX_Gtwy_Control_DWork.bitsForTID0.is_Two_Speed_Command ==
          MX_Gtwy_Control_IN_High) {
        duty_TwoSpeed_mabj = FULL_ON;

        // During 'High': '<S564>:7'
        if ((MX_Gtwy_Control_DWork.cmd_TwoSpeed != HIGH) || (state_Engine ==
             ENGINE_CRANKING) || (state_HydEnable != ACTIVE)) {
          // Transition: '<S564>:39'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Two_Speed_Command =
            MX_Gtwy_Control_IN_Low;

          // Entry 'Low': '<S564>:17'
          duty_TwoSpeed_mabj = 0U;
        }
      } else {
        duty_TwoSpeed_mabj = 0U;

        // During 'Low': '<S564>:17'
        if ((MX_Gtwy_Control_DWork.cmd_TwoSpeed == HIGH) && (state_Engine !=
             ENGINE_CRANKING) && (state_HydEnable == ACTIVE)) {
          // Transition: '<S564>:40'
          MX_Gtwy_Control_DWork.bitsForTID0.is_Two_Speed_Command =
            MX_Gtwy_Control_IN_High;

          // Entry 'High': '<S564>:7'
          duty_TwoSpeed_mabj = FULL_ON;
        }
      }
    }

    // End of Chart: '<S561>/TwoSpeed_Control'

    // Outputs for Atomic SubSystem: '<S561>/hc_Output'
    MX_Gtwy__output_single_OpenLoop(duty_TwoSpeed_mabj,
      MX_Gtwy_Control_B.RateTransition11_kahy,
      MX_Gtwy_Control_B.RateTransition10, afbk_TwoSpeed,
      &MX_Gtwy_Control_B.state_Output, &duty_TwoSpeed,
      &MX_Gtwy_Control_B.hc_Output, &MX_Gtwy_Control_DWork.hc_Output,
      CONSTANT_DATA->TWOSPEED_MAX_VOLTS,
      CONSTANT_DATA->TWOSPEED_DEBOUNCE_OPEN_CIRCUIT,
      CONSTANT_DATA->TWOSPEED_DEBOUNCE_SHORT_TO_BATTERY,
      CONSTANT_DATA->TWOSPEED_DEBOUNCE_SHORT_TO_GROUND,
      CONSTANT_DATA->TWOSPEED_FUNCTION, CONSTANT_DATA->TWOSPEED_AFBK_GAIN);

    // End of Outputs for SubSystem: '<S561>/hc_Output'

    // SignalConversion: '<S561>/OutportBufferForstate_TwoSpeed' incorporates:
    //   Inport: '<Root>/afbk_TwoSpeed'

    state_TwoSpeed = MX_Gtwy_Control_B.state_Output;

    // SignalConversion: '<S561>/OutportBufferForstate_TwoSpeedIcon'
    state_TwoSpeedIcon = state_TwoSpeedIcon_czcv;

    // Update for UnitDelay: '<S562>/Delay Input1' incorporates:
    //   Inport: '<Root>/din_TwoSpeedSwitch'

    MX_Gtwy_Control_DWork.DelayInput1_DSTATE_defa = din_TwoSpeedSwitch;
  } else {
    if (MX_Gtwy_Control_DWork.Two_Speed_MODE) {
      // Disable for Atomic SubSystem: '<S561>/hc_Output'
      output_single_OpenLoop_Disable(&MX_Gtwy_Control_B.hc_Output,
        &MX_Gtwy_Control_DWork.hc_Output);

      // End of Disable for SubSystem: '<S561>/hc_Output'

      // Disable for Outport: '<S561>/state_TwoSpeed'
      state_TwoSpeed = ((uint8_T)0U);

      // Disable for Outport: '<S561>/state_TwoSpeedIcon'
      state_TwoSpeedIcon = ((uint8_T)0U);

      // Disable for Outport: '<S561>/duty_TwoSpeed'
      duty_TwoSpeed = ((uint16_T)0U);
      MX_Gtwy_Control_DWork.Two_Speed_MODE = false;
    }
  }

  // End of Logic: '<S298>/Logical Operator1'
  // End of Outputs for SubSystem: '<S298>/Two_Speed'
}

//
//  [EOF]

